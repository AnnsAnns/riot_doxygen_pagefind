<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RIOT OS: SPI</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<!-- <script type="text/javascript" src="jquery.js"></script> -->
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<!-- <link href="/pagefind/pagefind-ui.css" rel="stylesheet"> -->
<script src="/pagefind/pagefind-ui.js"></script>
<script>
  // Check whether the PagefindUI class is available
  if (typeof PagefindUI === 'undefined') {
    console.error('PagefindUI class is not available | Dev Build');
  } else {
    // // Remove the "searchstub" element and initialize the PagefindUI class
    // document.getElementById("#searchstub").remove();
    // Initialize the PagefindUI class with the element id "search"
    window.addEventListener('DOMContentLoaded', (event) => {
        new PagefindUI({ element: "#search", showSubResults: true });
    });
  }
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="global.css" rel="stylesheet" type="text/css" />
</head>
<body>
  <script>
    // Print the data within the NAVTREE variable from the navtreedata.js file
    var navtree = NAVTREE;
    console.log(navtree);
  </script>
<div class="flex flex-row gap-4 w-screen font-sans text-lg max-h-screen overscroll-contain justify-items-stretch bg-neutral-900">
  <!--Sidebar-->
  <div data-pagefind-ignore="all" class="w-1/3 max-w-md flex-auto h-screen bg-neutral-800 ring-2 ring-neutral-700 shadow-neutral-800 shadow-2xl rounded-xl p-3 ml-1 my-2 mr-3 flex flex-col justify-around">
    <div id="top" class="justify-self-center content-center items-center place-content-center">
      <img alt="Logo" src="riot-logo.svg"/>
      <div id="projectbrief">
        The friendly Operating System for the Internet of Things
      </div>
    </div>
    <div id="search" class="place-content-center" class="overflow-y-scroll max-h-64 bg-slate-400 ring-2 ring-white text-white" >
      <h1>Searchbar via Pagefind</h1>
      <!-- <div id="searchstub" class="flex items-center border border-gray-300 rounded-lg p-2 shadow-sm">
        <input type="text" placeholder="Search is only available in Production Build ..." class="flex-grow p-2 outline-none">
      </div> -->
    </div>
    <div id="navtree">
      <script>
        // The navtree variable is always a pair of two elements (key, value)
        // The key is the name we should display and the value is the link to the page
        // Generate the navtree from the navtreedata.js file and put it under the navtree div
        var navtree = NAVTREE[0][2];
        var navtreeHTML = "<h1>Navigation based on Doxygen</h1> <ul>";
        for (var i = 0; i < navtree.length; i++) {
          navtreeHTML += "<li><a href='" + navtree[i][1] + "'>" + navtree[i][0] + "</a></li>";
          if (i == 5) {
            navtreeHTML += '<li><h3 class="ring-2 ring-white"> Random Insert for Demonstration </h3></li>';
          }
        }
        navtreeHTML += "</ul>";
        document.getElementById("navtree").innerHTML = navtreeHTML;
      </script>
    </div>
    <ul>
      <li class="footer">
        Generated on Tue Sep 24 2024 11:16:27 by 
          <a href="http://www.doxygen.org/index.html">
            Doxygen
          </a> 
        1.12.0
      </li>
    </ul>
  </div>
  <!--Main Content-->
  <div class="hidden">
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',true);
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('group__drivers__periph__spi.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">SPI<div class="ingroups"><a class="el" href="group__drivers.html">Drivers</a> &raquo; <a class="el" href="group__drivers__periph.html">Peripheral Driver Interface</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Low-level SPI peripheral driver  
<a href="#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Low-level SPI peripheral driver </p>
<p>This interface defines an abstraction for using a CPU's hardware SPI units. The interface only supports SPI master mode.</p>
<p>As SPI buses can have multiple devices connected to them they are to be considered as shared resources. To reflect this, the SPI interface is based on a transaction model. This requires that the bus needs to be acquired before usage and released afterwards, using the <code><a class="el" href="#ga31d89f231c0d6b18a71f2c8f3804e042" title="Start a new SPI transaction.">spi_acquire()</a></code> and the <code><a class="el" href="#ga9e36100f2b58917366872fca2f9f3bc6" title="Finish an ongoing SPI transaction by releasing the given SPI bus.">spi_release()</a></code> functions.</p>
<p>This interface supports both software and hardware chip select lines. This is reflected by the cpi_cs_t type, which overloads the gpio_t type with platform specific values for defining platform dependent hardware chip select lines.</p>
<p>Some devices have however very uncommon requirements on the usage and the timings of their chip select line. For those cases this interface allows to manage the chip select line manually from the user code (e.g. by calling gpio_set/clear explicitly) while deactivating the SPI driver internal chip select handling by passing <a class="el" href="atmega__common_2include_2periph__cpu__common_8h.html#a3969ce1e494a72d3c2925b10ddeb4604">GPIO_UNDEF</a> as CS parameter.</p>
<p>In the time, when the SPI bus is not used, the SPI unit should be in low-power mode to save energy.</p>
<p>The SPI unit's initialization is split into 3 parts:</p><ol type="1">
<li><code><a class="el" href="#gada6e52541835bc04dcc6ec62f2c74c3a" title="Basic initialization of the given SPI bus.">spi_init()</a></code> should be called once for each SPI unit defined by a board during system initialization.</li>
<li><code><a class="el" href="#ga1ed20d7e5b67938bd35139a819a8c982" title="Initialize the given chip select pin.">spi_init_cs()</a></code> should be called during device driver initialization, as each chip select pin/line is used uniquely by a specific device, i.e. chip select lines are no shared resource.</li>
<li><code><a class="el" href="#ga31d89f231c0d6b18a71f2c8f3804e042" title="Start a new SPI transaction.">spi_acquire()</a></code> needs to be called for each new transaction. This function configures the bus with specific parameters (clock, mode) for the duration of that transaction.</li>
</ol>
<h1><a class="anchor" id="autotoc_md1714"></a>
(Low-) Power Implications</h1>
<p>As SPI buses are shared peripherals and the interfaces implements a transaction based paradigm, we leverage this for the SPI peripherals power management. After calling <a class="el" href="#gada6e52541835bc04dcc6ec62f2c74c3a" title="Basic initialization of the given SPI bus.">spi_init()</a>, the SPI peripheral <b>should</b> be completely powered off (e.g. through peripheral clock gating). It <b>should</b> subsequently only be powered on and enabled in between <a class="el" href="#ga31d89f231c0d6b18a71f2c8f3804e042" title="Start a new SPI transaction.">spi_acquire()</a> and <a class="el" href="#ga9e36100f2b58917366872fca2f9f3bc6" title="Finish an ongoing SPI transaction by releasing the given SPI bus.">spi_release()</a> blocks.</p>
<p>In case the SPI driver implementation puts the active thread to sleep during data transfer (e.g. when using DMA), the implementation might need to block certain power states during that time. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="files" name="files"></a>
Files</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="spi_8h.html">spi.h</a></td></tr>
<tr class="memdesc:spi_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low-level SPI peripheral driver interface definition. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspi__gpio__mode__t.html">spi_gpio_mode_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI gpio mode.  <a href="structspi__gpio__mode__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga84c9407ece0a6914b037d6ee66f55dd1" id="r_ga84c9407ece0a6914b037d6ee66f55dd1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga84c9407ece0a6914b037d6ee66f55dd1">CONFIG_SPI_DMA_THRESHOLD_BYTES</a>&#160;&#160;&#160;16</td></tr>
<tr class="memdesc:ga84c9407ece0a6914b037d6ee66f55dd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Threshold under which polling transfers are used instead of DMA TODO: determine at run-time based on SPI clock.  <br /></td></tr>
<tr class="separator:ga84c9407ece0a6914b037d6ee66f55dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb9420809bc7722e41488a090b53eaf9" id="r_gafb9420809bc7722e41488a090b53eaf9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gafb9420809bc7722e41488a090b53eaf9">SPI_DEV</a>(x)</td></tr>
<tr class="memdesc:gafb9420809bc7722e41488a090b53eaf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default SPI device access macro.  <br /></td></tr>
<tr class="separator:gafb9420809bc7722e41488a090b53eaf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d0505b52e78af9251f6a1921d30214e" id="r_ga0d0505b52e78af9251f6a1921d30214e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0d0505b52e78af9251f6a1921d30214e">SPI_UNDEF</a>&#160;&#160;&#160;(UINT_FAST8_MAX)</td></tr>
<tr class="memdesc:ga0d0505b52e78af9251f6a1921d30214e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define global value for undefined SPI device.  <br /></td></tr>
<tr class="separator:ga0d0505b52e78af9251f6a1921d30214e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b0f414ed05adc20a504e8705587f9f8" id="r_ga8b0f414ed05adc20a504e8705587f9f8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8b0f414ed05adc20a504e8705587f9f8">SPI_CS_UNDEF</a>&#160;&#160;&#160;(<a class="el" href="atmega__common_2include_2periph__cpu__common_8h.html#a3969ce1e494a72d3c2925b10ddeb4604">GPIO_UNDEF</a>)</td></tr>
<tr class="memdesc:ga8b0f414ed05adc20a504e8705587f9f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define value for unused CS line.  <br /></td></tr>
<tr class="separator:ga8b0f414ed05adc20a504e8705587f9f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga292c9a0a5b03329a153ad28343ff2e09" id="r_ga292c9a0a5b03329a153ad28343ff2e09"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga292c9a0a5b03329a153ad28343ff2e09">SPI_HWCS</a>(x)</td></tr>
<tr class="memdesc:ga292c9a0a5b03329a153ad28343ff2e09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default SPI hardware chip select access macro.  <br /></td></tr>
<tr class="separator:ga292c9a0a5b03329a153ad28343ff2e09"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga12004e6f2a2ea6b7c0a96c654a2f3874" id="r_ga12004e6f2a2ea6b7c0a96c654a2f3874"><td class="memItemLeft" align="right" valign="top">typedef uint_fast8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga12004e6f2a2ea6b7c0a96c654a2f3874">spi_t</a></td></tr>
<tr class="memdesc:ga12004e6f2a2ea6b7c0a96c654a2f3874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default type for SPI devices.  <br /></td></tr>
<tr class="separator:ga12004e6f2a2ea6b7c0a96c654a2f3874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5fbaf43946646c588c9372e8906c99e" id="r_gaf5fbaf43946646c588c9372e8906c99e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__drivers__periph__gpio.html#gadacfc0deb08affff1e88f9549c8e2823">gpio_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf5fbaf43946646c588c9372e8906c99e">spi_cs_t</a></td></tr>
<tr class="memdesc:gaf5fbaf43946646c588c9372e8906c99e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chip select pin type overlaps with gpio_t so it can be casted to this.  <br /></td></tr>
<tr class="separator:gaf5fbaf43946646c588c9372e8906c99e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gac12627b43234a2c5005eca7a2a0a88cd" id="r_gac12627b43234a2c5005eca7a2a0a88cd"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<a class="el" href="#ggac12627b43234a2c5005eca7a2a0a88cda2b1fe832bba9b2799c09ddec72f7df75">SPI_OK</a> = 0
, <a class="el" href="#ggac12627b43234a2c5005eca7a2a0a88cda9c11521841e0fa199f2a6c49f441ecb2">SPI_NODEV</a> = -ENXIO
, <a class="el" href="#ggac12627b43234a2c5005eca7a2a0a88cda4955501124d6881ba11dcf3007aa31cc">SPI_NOCS</a> = -EINVAL
, <a class="el" href="#ggac12627b43234a2c5005eca7a2a0a88cda9ff35bd70e3623cf323f8caaafacf8e3">SPI_NOMODE</a> = -EINVAL
, <br />
&#160;&#160;<a class="el" href="#ggac12627b43234a2c5005eca7a2a0a88cda7dc86187e76eb54e02d32e53f4fb08b3">SPI_NOCLK</a> = -EINVAL
<br />
 }</td></tr>
<tr class="memdesc:gac12627b43234a2c5005eca7a2a0a88cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Status codes used by the SPI driver interface.  <a href="#gac12627b43234a2c5005eca7a2a0a88cd">More...</a><br /></td></tr>
<tr class="separator:gac12627b43234a2c5005eca7a2a0a88cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4b206a51636d91c5cffcbcee458c3cb" id="r_gac4b206a51636d91c5cffcbcee458c3cb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac4b206a51636d91c5cffcbcee458c3cb">spi_mode_t</a> { <a class="el" href="#ggac4b206a51636d91c5cffcbcee458c3cba152359b11fb4b43ed0c5485eb0ab0673">SPI_MODE_0</a> = 0
, <a class="el" href="#ggac4b206a51636d91c5cffcbcee458c3cba7c1990cc15e9d69621be8e0e757e634c">SPI_MODE_1</a>
, <a class="el" href="#ggac4b206a51636d91c5cffcbcee458c3cba4d350945d895a4acdc45ae96b0b82fc3">SPI_MODE_2</a>
, <a class="el" href="#ggac4b206a51636d91c5cffcbcee458c3cbaf06ec36087996d6f328df39866ff5de6">SPI_MODE_3</a>
 }</td></tr>
<tr class="memdesc:gac4b206a51636d91c5cffcbcee458c3cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Available SPI modes, defining the configuration of clock polarity and clock phase.  <a href="#gac4b206a51636d91c5cffcbcee458c3cb">More...</a><br /></td></tr>
<tr class="separator:gac4b206a51636d91c5cffcbcee458c3cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae81cec9f03084065c25089e514a57337" id="r_gae81cec9f03084065c25089e514a57337"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae81cec9f03084065c25089e514a57337">spi_clk_t</a> { <br />
&#160;&#160;<a class="el" href="#ggae81cec9f03084065c25089e514a57337ae6cc2c3387e4da1c7cb83aefb10f5d27">SPI_CLK_100KHZ</a> = 0
, <a class="el" href="#ggae81cec9f03084065c25089e514a57337a8db155bff416a59ca71ce9b2a2568bf3">SPI_CLK_400KHZ</a>
, <a class="el" href="#ggae81cec9f03084065c25089e514a57337abf727d641e5cceb12a58d29dc954c111">SPI_CLK_1MHZ</a>
, <a class="el" href="#ggae81cec9f03084065c25089e514a57337a4105210aa902203502e4392d4a3fbe58">SPI_CLK_5MHZ</a>
, <br />
&#160;&#160;<a class="el" href="#ggae81cec9f03084065c25089e514a57337a1693f88bef873b11f7b85ce0bba8175d">SPI_CLK_10MHZ</a>
<br />
 }</td></tr>
<tr class="memdesc:gae81cec9f03084065c25089e514a57337"><td class="mdescLeft">&#160;</td><td class="mdescRight">Available SPI clock speeds.  <a href="#gae81cec9f03084065c25089e514a57337">More...</a><br /></td></tr>
<tr class="separator:gae81cec9f03084065c25089e514a57337"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gada6e52541835bc04dcc6ec62f2c74c3a" id="r_gada6e52541835bc04dcc6ec62f2c74c3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gada6e52541835bc04dcc6ec62f2c74c3a">spi_init</a> (spi_t bus)</td></tr>
<tr class="memdesc:gada6e52541835bc04dcc6ec62f2c74c3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic initialization of the given SPI bus.  <br /></td></tr>
<tr class="separator:gada6e52541835bc04dcc6ec62f2c74c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fcf9ffd48cdc62c6019a2f07aab4ae9" id="r_ga9fcf9ffd48cdc62c6019a2f07aab4ae9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9fcf9ffd48cdc62c6019a2f07aab4ae9">spi_init_pins</a> (spi_t bus)</td></tr>
<tr class="memdesc:ga9fcf9ffd48cdc62c6019a2f07aab4ae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the used SPI bus pins, i.e.  <br /></td></tr>
<tr class="separator:ga9fcf9ffd48cdc62c6019a2f07aab4ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ed20d7e5b67938bd35139a819a8c982" id="r_ga1ed20d7e5b67938bd35139a819a8c982"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1ed20d7e5b67938bd35139a819a8c982">spi_init_cs</a> (spi_t bus, <a class="el" href="#gaf5fbaf43946646c588c9372e8906c99e">spi_cs_t</a> cs)</td></tr>
<tr class="memdesc:ga1ed20d7e5b67938bd35139a819a8c982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the given chip select pin.  <br /></td></tr>
<tr class="separator:ga1ed20d7e5b67938bd35139a819a8c982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab53bb266f74e4aaab19955c9fd199205" id="r_gab53bb266f74e4aaab19955c9fd199205"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab53bb266f74e4aaab19955c9fd199205">spi_deinit_pins</a> (spi_t dev)</td></tr>
<tr class="memdesc:gab53bb266f74e4aaab19955c9fd199205"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the pins of the given SPI bus back to plain GPIO functionality.  <br /></td></tr>
<tr class="separator:gab53bb266f74e4aaab19955c9fd199205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga206fc7968c27b40069ec5c3d7de03eb3" id="r_ga206fc7968c27b40069ec5c3d7de03eb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__drivers__periph__gpio.html#gadacfc0deb08affff1e88f9549c8e2823">gpio_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga206fc7968c27b40069ec5c3d7de03eb3">spi_pin_miso</a> (spi_t dev)</td></tr>
<tr class="memdesc:ga206fc7968c27b40069ec5c3d7de03eb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the MISO pin of the given SPI bus.  <br /></td></tr>
<tr class="separator:ga206fc7968c27b40069ec5c3d7de03eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a1dd3972f11c2383927855a4daf5d89" id="r_ga5a1dd3972f11c2383927855a4daf5d89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__drivers__periph__gpio.html#gadacfc0deb08affff1e88f9549c8e2823">gpio_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5a1dd3972f11c2383927855a4daf5d89">spi_pin_mosi</a> (spi_t dev)</td></tr>
<tr class="memdesc:ga5a1dd3972f11c2383927855a4daf5d89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the MOSI pin of the given SPI bus.  <br /></td></tr>
<tr class="separator:ga5a1dd3972f11c2383927855a4daf5d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64ad55ec9f29b85502d74a1a4230cd45" id="r_ga64ad55ec9f29b85502d74a1a4230cd45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__drivers__periph__gpio.html#gadacfc0deb08affff1e88f9549c8e2823">gpio_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga64ad55ec9f29b85502d74a1a4230cd45">spi_pin_clk</a> (spi_t dev)</td></tr>
<tr class="memdesc:ga64ad55ec9f29b85502d74a1a4230cd45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the CLK pin of the given SPI bus.  <br /></td></tr>
<tr class="separator:ga64ad55ec9f29b85502d74a1a4230cd45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d72c85b39d67a5069d210fae1529c6c" id="r_ga5d72c85b39d67a5069d210fae1529c6c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5d72c85b39d67a5069d210fae1529c6c">spi_init_with_gpio_mode</a> (spi_t bus, const <a class="el" href="structspi__gpio__mode__t.html">spi_gpio_mode_t</a> *mode)</td></tr>
<tr class="memdesc:ga5d72c85b39d67a5069d210fae1529c6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize MOSI/MISO/SCLK pins with adapted GPIO modes.  <br /></td></tr>
<tr class="separator:ga5d72c85b39d67a5069d210fae1529c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31d89f231c0d6b18a71f2c8f3804e042" id="r_ga31d89f231c0d6b18a71f2c8f3804e042"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga31d89f231c0d6b18a71f2c8f3804e042">spi_acquire</a> (spi_t bus, <a class="el" href="#gaf5fbaf43946646c588c9372e8906c99e">spi_cs_t</a> cs, <a class="el" href="msp430_2include_2f2xx__g2xx_2periph__cpu_8h.html#ac4b206a51636d91c5cffcbcee458c3cb">spi_mode_t</a> mode, <a class="el" href="atxmega_2include_2periph__cpu_8h.html#a17adf016c33fa2f2e36c9bec898bc0c8">spi_clk_t</a> clk)</td></tr>
<tr class="memdesc:ga31d89f231c0d6b18a71f2c8f3804e042"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a new SPI transaction.  <br /></td></tr>
<tr class="separator:ga31d89f231c0d6b18a71f2c8f3804e042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e36100f2b58917366872fca2f9f3bc6" id="r_ga9e36100f2b58917366872fca2f9f3bc6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9e36100f2b58917366872fca2f9f3bc6">spi_release</a> (spi_t bus)</td></tr>
<tr class="memdesc:ga9e36100f2b58917366872fca2f9f3bc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finish an ongoing SPI transaction by releasing the given SPI bus.  <br /></td></tr>
<tr class="separator:ga9e36100f2b58917366872fca2f9f3bc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e2f58f7b719d1e8ac5cb05bdeed7c9b" id="r_ga6e2f58f7b719d1e8ac5cb05bdeed7c9b"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6e2f58f7b719d1e8ac5cb05bdeed7c9b">spi_transfer_byte</a> (spi_t bus, <a class="el" href="#gaf5fbaf43946646c588c9372e8906c99e">spi_cs_t</a> cs, bool cont, uint8_t out)</td></tr>
<tr class="memdesc:ga6e2f58f7b719d1e8ac5cb05bdeed7c9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer one byte on the given SPI bus.  <br /></td></tr>
<tr class="separator:ga6e2f58f7b719d1e8ac5cb05bdeed7c9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6ca850b7cb6142b76deecb831357447" id="r_gae6ca850b7cb6142b76deecb831357447"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae6ca850b7cb6142b76deecb831357447">spi_transfer_bytes</a> (spi_t bus, <a class="el" href="#gaf5fbaf43946646c588c9372e8906c99e">spi_cs_t</a> cs, bool cont, const void *out, void *in, size_t len)</td></tr>
<tr class="memdesc:gae6ca850b7cb6142b76deecb831357447"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer a number bytes using the given SPI bus.  <br /></td></tr>
<tr class="separator:gae6ca850b7cb6142b76deecb831357447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2593203a71900ff6d8346398bc5241a1" id="r_ga2593203a71900ff6d8346398bc5241a1"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2593203a71900ff6d8346398bc5241a1">spi_transfer_reg</a> (spi_t bus, <a class="el" href="#gaf5fbaf43946646c588c9372e8906c99e">spi_cs_t</a> cs, uint8_t reg, uint8_t out)</td></tr>
<tr class="memdesc:ga2593203a71900ff6d8346398bc5241a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer one byte to/from a given register address.  <br /></td></tr>
<tr class="separator:ga2593203a71900ff6d8346398bc5241a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6577f294a7dd426badb3d69356bfc850" id="r_ga6577f294a7dd426badb3d69356bfc850"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6577f294a7dd426badb3d69356bfc850">spi_transfer_regs</a> (spi_t bus, <a class="el" href="#gaf5fbaf43946646c588c9372e8906c99e">spi_cs_t</a> cs, uint8_t reg, const void *out, void *in, size_t len)</td></tr>
<tr class="memdesc:ga6577f294a7dd426badb3d69356bfc850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer a number of bytes to/from a given register address.  <br /></td></tr>
<tr class="separator:ga6577f294a7dd426badb3d69356bfc850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98f8710acaf25e728848a499df0b2d27" id="r_ga98f8710acaf25e728848a499df0b2d27"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga98f8710acaf25e728848a499df0b2d27">spi_transfer_u16_be</a> (spi_t bus, <a class="el" href="#gaf5fbaf43946646c588c9372e8906c99e">spi_cs_t</a> cs, bool cont, uint16_t host_number)</td></tr>
<tr class="memdesc:ga98f8710acaf25e728848a499df0b2d27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer a 16 bit number in big endian byte order.  <br /></td></tr>
<tr class="separator:ga98f8710acaf25e728848a499df0b2d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga84c9407ece0a6914b037d6ee66f55dd1" name="ga84c9407ece0a6914b037d6ee66f55dd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84c9407ece0a6914b037d6ee66f55dd1">&#9670;&#160;</a></span>CONFIG_SPI_DMA_THRESHOLD_BYTES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CONFIG_SPI_DMA_THRESHOLD_BYTES&#160;&#160;&#160;16</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Threshold under which polling transfers are used instead of DMA TODO: determine at run-time based on SPI clock. </p>

<p class="definition">Definition at line <a class="el" href="spi_8h_source.html#l00088">88</a> of file <a class="el" href="spi_8h_source.html">spi.h</a>.</p>

</div>
</div>
<a id="ga8b0f414ed05adc20a504e8705587f9f8" name="ga8b0f414ed05adc20a504e8705587f9f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b0f414ed05adc20a504e8705587f9f8">&#9670;&#160;</a></span>SPI_CS_UNDEF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPI_CS_UNDEF&#160;&#160;&#160;(<a class="el" href="atmega__common_2include_2periph__cpu__common_8h.html#a3969ce1e494a72d3c2925b10ddeb4604">GPIO_UNDEF</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define value for unused CS line. </p>

<p class="definition">Definition at line <a class="el" href="spi_8h_source.html#l00109">109</a> of file <a class="el" href="spi_8h_source.html">spi.h</a>.</p>

</div>
</div>
<a id="gafb9420809bc7722e41488a090b53eaf9" name="gafb9420809bc7722e41488a090b53eaf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb9420809bc7722e41488a090b53eaf9">&#9670;&#160;</a></span>SPI_DEV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPI_DEV</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(x)</div>
</div><!-- fragment -->
<p>Default SPI device access macro. </p>

<p class="definition">Definition at line <a class="el" href="spi_8h_source.html#l00095">95</a> of file <a class="el" href="spi_8h_source.html">spi.h</a>.</p>

</div>
</div>
<a id="ga292c9a0a5b03329a153ad28343ff2e09" name="ga292c9a0a5b03329a153ad28343ff2e09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga292c9a0a5b03329a153ad28343ff2e09">&#9670;&#160;</a></span>SPI_HWCS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPI_HWCS</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(<a class="code hl_define" href="#ga8b0f414ed05adc20a504e8705587f9f8">SPI_CS_UNDEF</a>)</div>
<div class="ttc" id="agroup__drivers__periph__spi_html_ga8b0f414ed05adc20a504e8705587f9f8"><div class="ttname"><a href="#ga8b0f414ed05adc20a504e8705587f9f8">SPI_CS_UNDEF</a></div><div class="ttdeci">#define SPI_CS_UNDEF</div><div class="ttdoc">Define value for unused CS line.</div><div class="ttdef"><b>Definition</b> <a href="spi_8h_source.html#l00109">spi.h:109</a></div></div>
</div><!-- fragment -->
<p>Default SPI hardware chip select access macro. </p>
<p>Per default, we map all hardware chip select lines to be not defined. If an implementation makes use of HW chip select lines, this value needs to be overridden by the corresponding CPU. </p>

<p class="definition">Definition at line <a class="el" href="spi_8h_source.html#l00120">120</a> of file <a class="el" href="spi_8h_source.html">spi.h</a>.</p>

</div>
</div>
<a id="ga0d0505b52e78af9251f6a1921d30214e" name="ga0d0505b52e78af9251f6a1921d30214e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d0505b52e78af9251f6a1921d30214e">&#9670;&#160;</a></span>SPI_UNDEF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPI_UNDEF&#160;&#160;&#160;(UINT_FAST8_MAX)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define global value for undefined SPI device. </p>

<p class="definition">Definition at line <a class="el" href="spi_8h_source.html#l00102">102</a> of file <a class="el" href="spi_8h_source.html">spi.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gaf5fbaf43946646c588c9372e8906c99e" name="gaf5fbaf43946646c588c9372e8906c99e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5fbaf43946646c588c9372e8906c99e">&#9670;&#160;</a></span>spi_cs_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__drivers__periph__gpio.html#gadacfc0deb08affff1e88f9549c8e2823">gpio_t</a> <a class="el" href="#gaf5fbaf43946646c588c9372e8906c99e">spi_cs_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Chip select pin type overlaps with gpio_t so it can be casted to this. </p>

<p class="definition">Definition at line <a class="el" href="spi_8h_source.html#l00135">135</a> of file <a class="el" href="spi_8h_source.html">spi.h</a>.</p>

</div>
</div>
<a id="ga12004e6f2a2ea6b7c0a96c654a2f3874" name="ga12004e6f2a2ea6b7c0a96c654a2f3874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12004e6f2a2ea6b7c0a96c654a2f3874">&#9670;&#160;</a></span>spi_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint_fast8_t spi_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default type for SPI devices. </p>

<p class="definition">Definition at line <a class="el" href="spi_8h_source.html#l00127">127</a> of file <a class="el" href="spi_8h_source.html">spi.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gac12627b43234a2c5005eca7a2a0a88cd" name="gac12627b43234a2c5005eca7a2a0a88cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac12627b43234a2c5005eca7a2a0a88cd">&#9670;&#160;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Status codes used by the SPI driver interface. </p>
<dl class="deprecated"><dt><b>Deprecated</b></dt><dd>Use negative errno codes instead. The enum is still provided for backwards compatibility </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggac12627b43234a2c5005eca7a2a0a88cda2b1fe832bba9b2799c09ddec72f7df75" name="ggac12627b43234a2c5005eca7a2a0a88cda2b1fe832bba9b2799c09ddec72f7df75"></a>SPI_OK&#160;</td><td class="fielddoc"><p>everything went as planned </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac12627b43234a2c5005eca7a2a0a88cda9c11521841e0fa199f2a6c49f441ecb2" name="ggac12627b43234a2c5005eca7a2a0a88cda9c11521841e0fa199f2a6c49f441ecb2"></a>SPI_NODEV&#160;</td><td class="fielddoc"><p>invalid SPI bus specified </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac12627b43234a2c5005eca7a2a0a88cda4955501124d6881ba11dcf3007aa31cc" name="ggac12627b43234a2c5005eca7a2a0a88cda4955501124d6881ba11dcf3007aa31cc"></a>SPI_NOCS&#160;</td><td class="fielddoc"><p>invalid chip select line specified </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac12627b43234a2c5005eca7a2a0a88cda9ff35bd70e3623cf323f8caaafacf8e3" name="ggac12627b43234a2c5005eca7a2a0a88cda9ff35bd70e3623cf323f8caaafacf8e3"></a>SPI_NOMODE&#160;</td><td class="fielddoc"><p>selected mode is not supported </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac12627b43234a2c5005eca7a2a0a88cda7dc86187e76eb54e02d32e53f4fb08b3" name="ggac12627b43234a2c5005eca7a2a0a88cda7dc86187e76eb54e02d32e53f4fb08b3"></a>SPI_NOCLK&#160;</td><td class="fielddoc"><p>selected clock value is not supported </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="spi_8h_source.html#l00144">144</a> of file <a class="el" href="spi_8h_source.html">spi.h</a>.</p>

</div>
</div>
<a id="gae81cec9f03084065c25089e514a57337" name="gae81cec9f03084065c25089e514a57337"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae81cec9f03084065c25089e514a57337">&#9670;&#160;</a></span>spi_clk_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="atxmega_2include_2periph__cpu_8h.html#a17adf016c33fa2f2e36c9bec898bc0c8">spi_clk_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Available SPI clock speeds. </p>
<p>The actual speed of the bus can vary to some extend, as the combination of CPU clock and available prescaler values on certain platforms may not make the exact values possible. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggae81cec9f03084065c25089e514a57337ae6cc2c3387e4da1c7cb83aefb10f5d27" name="ggae81cec9f03084065c25089e514a57337ae6cc2c3387e4da1c7cb83aefb10f5d27"></a>SPI_CLK_100KHZ&#160;</td><td class="fielddoc"><p>drive the SPI bus with 100KHz </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae81cec9f03084065c25089e514a57337a8db155bff416a59ca71ce9b2a2568bf3" name="ggae81cec9f03084065c25089e514a57337a8db155bff416a59ca71ce9b2a2568bf3"></a>SPI_CLK_400KHZ&#160;</td><td class="fielddoc"><p>drive the SPI bus with 400KHz </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae81cec9f03084065c25089e514a57337abf727d641e5cceb12a58d29dc954c111" name="ggae81cec9f03084065c25089e514a57337abf727d641e5cceb12a58d29dc954c111"></a>SPI_CLK_1MHZ&#160;</td><td class="fielddoc"><p>drive the SPI bus with 1MHz </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae81cec9f03084065c25089e514a57337a4105210aa902203502e4392d4a3fbe58" name="ggae81cec9f03084065c25089e514a57337a4105210aa902203502e4392d4a3fbe58"></a>SPI_CLK_5MHZ&#160;</td><td class="fielddoc"><p>drive the SPI bus with 5MHz </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae81cec9f03084065c25089e514a57337a1693f88bef873b11f7b85ce0bba8175d" name="ggae81cec9f03084065c25089e514a57337a1693f88bef873b11f7b85ce0bba8175d"></a>SPI_CLK_10MHZ&#160;</td><td class="fielddoc"><p>drive the SPI bus with 10MHz </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="spi_8h_source.html#l00185">185</a> of file <a class="el" href="spi_8h_source.html">spi.h</a>.</p>

</div>
</div>
<a id="gac4b206a51636d91c5cffcbcee458c3cb" name="gac4b206a51636d91c5cffcbcee458c3cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4b206a51636d91c5cffcbcee458c3cb">&#9670;&#160;</a></span>spi_mode_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="msp430_2include_2f2xx__g2xx_2periph__cpu_8h.html#ac4b206a51636d91c5cffcbcee458c3cb">spi_mode_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Available SPI modes, defining the configuration of clock polarity and clock phase. </p>
<p>RIOT is using the mode numbers as commonly defined by most vendors (<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface_Bus#Mode_numbers">https://en.wikipedia.org/wiki/Serial_Peripheral_Interface_Bus#Mode_numbers</a>):</p>
<ul>
<li>MODE_0: CPOL=0, CPHA=0 - The first data bit is sampled by the receiver on the first SCK rising SCK edge (this mode is used most often).</li>
<li>MODE_1: CPOL=0, CPHA=1 - The first data bit is sampled by the receiver on the second rising SCK edge.</li>
<li>MODE_2: CPOL=1, CPHA=0 - The first data bit is sampled by the receiver on the first falling SCK edge.</li>
<li>MODE_3: CPOL=1, CPHA=1 - The first data bit is sampled by the receiver on the second falling SCK edge. </li>
</ul>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggac4b206a51636d91c5cffcbcee458c3cba152359b11fb4b43ed0c5485eb0ab0673" name="ggac4b206a51636d91c5cffcbcee458c3cba152359b11fb4b43ed0c5485eb0ab0673"></a>SPI_MODE_0&#160;</td><td class="fielddoc"><p>CPOL=0, CPHA=0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac4b206a51636d91c5cffcbcee458c3cba7c1990cc15e9d69621be8e0e757e634c" name="ggac4b206a51636d91c5cffcbcee458c3cba7c1990cc15e9d69621be8e0e757e634c"></a>SPI_MODE_1&#160;</td><td class="fielddoc"><p>CPOL=0, CPHA=1. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac4b206a51636d91c5cffcbcee458c3cba4d350945d895a4acdc45ae96b0b82fc3" name="ggac4b206a51636d91c5cffcbcee458c3cba4d350945d895a4acdc45ae96b0b82fc3"></a>SPI_MODE_2&#160;</td><td class="fielddoc"><p>CPOL=1, CPHA=0. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac4b206a51636d91c5cffcbcee458c3cbaf06ec36087996d6f328df39866ff5de6" name="ggac4b206a51636d91c5cffcbcee458c3cbaf06ec36087996d6f328df39866ff5de6"></a>SPI_MODE_3&#160;</td><td class="fielddoc"><p>CPOL=1, CPHA=1. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="spi_8h_source.html#l00169">169</a> of file <a class="el" href="spi_8h_source.html">spi.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga31d89f231c0d6b18a71f2c8f3804e042" name="ga31d89f231c0d6b18a71f2c8f3804e042"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31d89f231c0d6b18a71f2c8f3804e042">&#9670;&#160;</a></span>spi_acquire()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spi_acquire </td>
          <td>(</td>
          <td class="paramtype">spi_t</td>          <td class="paramname"><span class="paramname"><em>bus</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaf5fbaf43946646c588c9372e8906c99e">spi_cs_t</a></td>          <td class="paramname"><span class="paramname"><em>cs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="msp430_2include_2f2xx__g2xx_2periph__cpu_8h.html#ac4b206a51636d91c5cffcbcee458c3cb">spi_mode_t</a></td>          <td class="paramname"><span class="paramname"><em>mode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="atxmega_2include_2periph__cpu_8h.html#a17adf016c33fa2f2e36c9bec898bc0c8">spi_clk_t</a></td>          <td class="paramname"><span class="paramname"><em>clk</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start a new SPI transaction. </p>
<p>Starting a new SPI transaction will get exclusive access to the SPI bus and configure it according to the given values. If another SPI transaction is active when this function is called, this function will block until the other transaction is complete (spi_relase was called).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bus</td><td>SPI device to access </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cs</td><td>chip select pin/line to use, set to SPI_CS_UNDEF if chip select should not be handled by the SPI driver </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>mode to use for the new transaction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clk</td><td>bus clock speed to use for the transaction</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>All parameters are valid and supported, otherwise an assertion blows up (if assertions are enabled). </dd></dl>

</div>
</div>
<a id="gab53bb266f74e4aaab19955c9fd199205" name="gab53bb266f74e4aaab19955c9fd199205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab53bb266f74e4aaab19955c9fd199205">&#9670;&#160;</a></span>spi_deinit_pins()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spi_deinit_pins </td>
          <td>(</td>
          <td class="paramtype">spi_t</td>          <td class="paramname"><span class="paramname"><em>dev</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the pins of the given SPI bus back to plain GPIO functionality. </p>
<p>The pin mux of the MISO, MOSI and CLK pins of the bus will be changed back to default (GPIO) mode and the SPI bus is powered off. This allows to use the SPI pins for another function and return to SPI functionality again by calling <a class="el" href="#ga9fcf9ffd48cdc62c6019a2f07aab4ae9" title="Initialize the used SPI bus pins, i.e.">spi_init_pins()</a></p>
<p>If you want the pin to be in a defined state, call <a class="el" href="group__drivers__periph__gpio.html#gab7d8ecaeb639070a28027a8fd31a0955" title="Initialize the given pin as general purpose input or output.">gpio_init()</a> on it.</p>
<p>The bus MUST not be acquired before initializing it, as this is handled internally by the <a class="el" href="#gab53bb266f74e4aaab19955c9fd199205" title="Change the pins of the given SPI bus back to plain GPIO functionality.">spi_deinit_pins()</a> function!</p>
<p>Calls to <a class="el" href="#ga31d89f231c0d6b18a71f2c8f3804e042" title="Start a new SPI transaction.">spi_acquire()</a> will block until <a class="el" href="#ga9fcf9ffd48cdc62c6019a2f07aab4ae9" title="Initialize the used SPI bus pins, i.e.">spi_init_pins()</a> is called again.</p>
<dl class="section note"><dt>Note</dt><dd>Until this is implemented on all platforms, this requires the periph_spi_reconfigure feature to be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>the device to de-initialize </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gada6e52541835bc04dcc6ec62f2c74c3a" name="gada6e52541835bc04dcc6ec62f2c74c3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada6e52541835bc04dcc6ec62f2c74c3a">&#9670;&#160;</a></span>spi_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spi_init </td>
          <td>(</td>
          <td class="paramtype">spi_t</td>          <td class="paramname"><span class="paramname"><em>bus</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Basic initialization of the given SPI bus. </p>
<p>This function does the basic initialization including pin configuration for MISO, MOSI, and CLK pins. After initialization, the given device should be in power down state.</p>
<p>This function is intended to be called by the board initialization code during system startup to prepare the (shared) SPI device for further usage. It uses the board specific initialization parameters as defined in the board's <code>periph_conf.h</code>.</p>
<p>Errors (e.g. invalid <code>bus</code> parameter) are not signaled through a return value, but should be signaled using the <a class="el" href="assert_8h.html#a3153a272f18d0f805028fce7e4337b53" title="abort the program if assertion is false">assert()</a> function internally.</p>
<dl class="section note"><dt>Note</dt><dd>This function MUST not be called more than once per bus!</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bus</td><td>SPI device to initialize </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1ed20d7e5b67938bd35139a819a8c982" name="ga1ed20d7e5b67938bd35139a819a8c982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ed20d7e5b67938bd35139a819a8c982">&#9670;&#160;</a></span>spi_init_cs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spi_init_cs </td>
          <td>(</td>
          <td class="paramtype">spi_t</td>          <td class="paramname"><span class="paramname"><em>bus</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaf5fbaf43946646c588c9372e8906c99e">spi_cs_t</a></td>          <td class="paramname"><span class="paramname"><em>cs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the given chip select pin. </p>
<p>The chip select can be any generic GPIO pin (e.g. <a class="el" href="atmega1284p_2include_2periph__cpu_8h.html#ae29846b3ecd19a0b7c44ff80a37ae7c1" title="Define a CPU specific GPIO pin generator macro.">GPIO_PIN(x,y)</a>), or it can be a hardware chip select line. The existence and number of hardware chip select lines depends on the underlying platform and the actual pins used for hardware chip select lines are defined in the board's <code>periph_conf.h</code>.</p>
<p>Define the used chip select line using the <a class="el" href="gd32v_2include_2periph__cpu_8h.html#a292c9a0a5b03329a153ad28343ff2e09">SPI_HWCS(x)</a> macro for hardware chip select line <code>x</code> or the <a class="el" href="atmega1284p_2include_2periph__cpu_8h.html#ae29846b3ecd19a0b7c44ff80a37ae7c1" title="Define a CPU specific GPIO pin generator macro.">GPIO_PIN(x,y)</a> macro for using any GPIO pin for manual chip select.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bus</td><td>SPI device that is used with the given CS line </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cs</td><td>chip select pin to initialize</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>success </td></tr>
    <tr><td class="paramname">-ENXIO</td><td>invalid device </td></tr>
    <tr><td class="paramname">-EINVAL</td><td>invalid CS pin/line </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9fcf9ffd48cdc62c6019a2f07aab4ae9" name="ga9fcf9ffd48cdc62c6019a2f07aab4ae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9fcf9ffd48cdc62c6019a2f07aab4ae9">&#9670;&#160;</a></span>spi_init_pins()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spi_init_pins </td>
          <td>(</td>
          <td class="paramtype">spi_t</td>          <td class="paramname"><span class="paramname"><em>bus</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the used SPI bus pins, i.e. </p>
<p>MISO, MOSI, and CLK</p>
<p>After calling spi_init, the pins must be initialized (i.e. spi_init is calling this function internally). In normal cases, this function will not be used. But there are some devices (e.g. CC110x), that use SPI bus lines also for other purposes and need the option to dynamically re-configure one or more of the used pins. So they can take control over certain pins and return control back to the SPI driver using this function.</p>
<p>This function must be called after <a class="el" href="#gab53bb266f74e4aaab19955c9fd199205">spi_deinit_pins</a> to return the pins to SPI operation.</p>
<p>The pins used are configured in the board's periph_conf.h.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bus</td><td>SPI device the pins are configure for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5d72c85b39d67a5069d210fae1529c6c" name="ga5d72c85b39d67a5069d210fae1529c6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d72c85b39d67a5069d210fae1529c6c">&#9670;&#160;</a></span>spi_init_with_gpio_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spi_init_with_gpio_mode </td>
          <td>(</td>
          <td class="paramtype">spi_t</td>          <td class="paramname"><span class="paramname"><em>bus</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structspi__gpio__mode__t.html">spi_gpio_mode_t</a> *</td>          <td class="paramname"><span class="paramname"><em>mode</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize MOSI/MISO/SCLK pins with adapted GPIO modes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bus</td><td>SPI device that is used with the given CS line </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>a pointer to a struct containing the 3 modes to use on each pin</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>success </td></tr>
    <tr><td class="paramname">&lt;0</td><td>error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga64ad55ec9f29b85502d74a1a4230cd45" name="ga64ad55ec9f29b85502d74a1a4230cd45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64ad55ec9f29b85502d74a1a4230cd45">&#9670;&#160;</a></span>spi_pin_clk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__drivers__periph__gpio.html#gadacfc0deb08affff1e88f9549c8e2823">gpio_t</a> spi_pin_clk </td>
          <td>(</td>
          <td class="paramtype">spi_t</td>          <td class="paramname"><span class="paramname"><em>dev</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the CLK pin of the given SPI bus. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>The device to query</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Until this is implemented on all platforms, this requires the periph_spi_reconfigure feature to be used.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The GPIO used for the SPI CLK line. </dd></dl>

</div>
</div>
<a id="ga206fc7968c27b40069ec5c3d7de03eb3" name="ga206fc7968c27b40069ec5c3d7de03eb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga206fc7968c27b40069ec5c3d7de03eb3">&#9670;&#160;</a></span>spi_pin_miso()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__drivers__periph__gpio.html#gadacfc0deb08affff1e88f9549c8e2823">gpio_t</a> spi_pin_miso </td>
          <td>(</td>
          <td class="paramtype">spi_t</td>          <td class="paramname"><span class="paramname"><em>dev</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the MISO pin of the given SPI bus. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>The device to query</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Until this is implemented on all platforms, this requires the periph_spi_reconfigure feature to be used.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The GPIO used for the SPI MISO line. </dd></dl>

</div>
</div>
<a id="ga5a1dd3972f11c2383927855a4daf5d89" name="ga5a1dd3972f11c2383927855a4daf5d89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a1dd3972f11c2383927855a4daf5d89">&#9670;&#160;</a></span>spi_pin_mosi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__drivers__periph__gpio.html#gadacfc0deb08affff1e88f9549c8e2823">gpio_t</a> spi_pin_mosi </td>
          <td>(</td>
          <td class="paramtype">spi_t</td>          <td class="paramname"><span class="paramname"><em>dev</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the MOSI pin of the given SPI bus. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>The device to query</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Until this is implemented on all platforms, this requires the periph_spi_reconfigure feature to be used.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The GPIO used for the SPI MOSI line. </dd></dl>

</div>
</div>
<a id="ga9e36100f2b58917366872fca2f9f3bc6" name="ga9e36100f2b58917366872fca2f9f3bc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e36100f2b58917366872fca2f9f3bc6">&#9670;&#160;</a></span>spi_release()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spi_release </td>
          <td>(</td>
          <td class="paramtype">spi_t</td>          <td class="paramname"><span class="paramname"><em>bus</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finish an ongoing SPI transaction by releasing the given SPI bus. </p>
<p>After release, the given SPI bus should be fully powered down until acquired again.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bus</td><td>SPI device to release </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6e2f58f7b719d1e8ac5cb05bdeed7c9b" name="ga6e2f58f7b719d1e8ac5cb05bdeed7c9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e2f58f7b719d1e8ac5cb05bdeed7c9b">&#9670;&#160;</a></span>spi_transfer_byte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t spi_transfer_byte </td>
          <td>(</td>
          <td class="paramtype">spi_t</td>          <td class="paramname"><span class="paramname"><em>bus</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaf5fbaf43946646c588c9372e8906c99e">spi_cs_t</a></td>          <td class="paramname"><span class="paramname"><em>cs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>cont</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>out</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transfer one byte on the given SPI bus. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bus</td><td>SPI device to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cs</td><td>chip select pin/line to use, set to SPI_CS_UNDEF if chip select should not be handled by the SPI driver </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cont</td><td>if true, keep device selected after transfer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">out</td><td>byte to send out</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the received byte </dd></dl>

</div>
</div>
<a id="gae6ca850b7cb6142b76deecb831357447" name="gae6ca850b7cb6142b76deecb831357447"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6ca850b7cb6142b76deecb831357447">&#9670;&#160;</a></span>spi_transfer_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spi_transfer_bytes </td>
          <td>(</td>
          <td class="paramtype">spi_t</td>          <td class="paramname"><span class="paramname"><em>bus</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaf5fbaf43946646c588c9372e8906c99e">spi_cs_t</a></td>          <td class="paramname"><span class="paramname"><em>cs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>cont</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transfer a number bytes using the given SPI bus. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bus</td><td>SPI device to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cs</td><td>chip select pin/line to use, set to SPI_CS_UNDEF if chip select should not be handled by the SPI driver </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cont</td><td>if true, keep device selected after transfer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">out</td><td>buffer to send data from, set NULL if only receiving </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">in</td><td>buffer to read into, set NULL if only sending </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>number of bytes to transfer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2593203a71900ff6d8346398bc5241a1" name="ga2593203a71900ff6d8346398bc5241a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2593203a71900ff6d8346398bc5241a1">&#9670;&#160;</a></span>spi_transfer_reg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t spi_transfer_reg </td>
          <td>(</td>
          <td class="paramtype">spi_t</td>          <td class="paramname"><span class="paramname"><em>bus</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaf5fbaf43946646c588c9372e8906c99e">spi_cs_t</a></td>          <td class="paramname"><span class="paramname"><em>cs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>reg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>out</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transfer one byte to/from a given register address. </p>
<p>This function is a shortcut function for easier handling of SPI devices that implement a register based access scheme.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bus</td><td>SPI device to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cs</td><td>chip select pin/line to use, set to SPI_CS_UNDEF if chip select should not be handled by the SPI driver </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reg</td><td>register address to transfer data to/from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">out</td><td>byte to send</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value that was read from the given register address </dd></dl>

</div>
</div>
<a id="ga6577f294a7dd426badb3d69356bfc850" name="ga6577f294a7dd426badb3d69356bfc850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6577f294a7dd426badb3d69356bfc850">&#9670;&#160;</a></span>spi_transfer_regs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spi_transfer_regs </td>
          <td>(</td>
          <td class="paramtype">spi_t</td>          <td class="paramname"><span class="paramname"><em>bus</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaf5fbaf43946646c588c9372e8906c99e">spi_cs_t</a></td>          <td class="paramname"><span class="paramname"><em>cs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>reg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transfer a number of bytes to/from a given register address. </p>
<p>This function is a shortcut function for easier handling of SPI devices that implement a register based access scheme.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bus</td><td>SPI device to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cs</td><td>chip select pin/line to use, set to SPI_CS_UNDEF if chip select should not be handled by the SPI driver </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reg</td><td>register address to transfer data to/from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">out</td><td>buffer to send data from, set NULL if only receiving </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">in</td><td>buffer to read into, set NULL if only sending </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>number of bytes to transfer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga98f8710acaf25e728848a499df0b2d27" name="ga98f8710acaf25e728848a499df0b2d27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98f8710acaf25e728848a499df0b2d27">&#9670;&#160;</a></span>spi_transfer_u16_be()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t spi_transfer_u16_be </td>
          <td>(</td>
          <td class="paramtype">spi_t</td>          <td class="paramname"><span class="paramname"><em>bus</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaf5fbaf43946646c588c9372e8906c99e">spi_cs_t</a></td>          <td class="paramname"><span class="paramname"><em>cs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>cont</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>host_number</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer a 16 bit number in big endian byte order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bus</td><td>SPI device to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cs</td><td>chip select pin/line to use, set to SPI_CS_UNDEF if chip select should not be handled by the SPI driver </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cont</td><td>if true, keep device selected after transfer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">host_number</td><td>number to transfer in host byte order </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 16 bit number received in host byte order </dd></dl>

<p class="definition">Definition at line <a class="el" href="spi_8h_source.html#l00444">444</a> of file <a class="el" href="spi_8h_source.html">spi.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->

    </div>
  </body>
</html>
