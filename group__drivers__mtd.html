<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RIOT OS: Memory Technology Device</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<!-- <script type="text/javascript" src="jquery.js"></script> -->
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<!-- <link href="/pagefind/pagefind-ui.css" rel="stylesheet"> -->
<script src="/pagefind/pagefind-ui.js"></script>
<script>
  // Check whether the PagefindUI class is available
  if (typeof PagefindUI === 'undefined') {
    console.error('PagefindUI class is not available | Dev Build');
  } else {
    // // Remove the "searchstub" element and initialize the PagefindUI class
    // document.getElementById("#searchstub").remove();
    // Initialize the PagefindUI class with the element id "search"
    window.addEventListener('DOMContentLoaded', (event) => {
        new PagefindUI({ element: "#search", showSubResults: true });
    });
  }
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="global.css" rel="stylesheet" type="text/css" />
</head>
<body>
  <script>
    // Print the data within the NAVTREE variable from the navtreedata.js file
    var navtree = NAVTREE;
    console.log(navtree);
  </script>
<div class="flex flex-row gap-4 w-screen font-sans text-lg max-h-screen overscroll-contain justify-items-stretch bg-neutral-900">
  <!--Sidebar-->
  <div data-pagefind-ignore="all" class="w-1/3 max-w-md flex-auto h-screen bg-neutral-800 ring-2 ring-neutral-700 shadow-neutral-800 shadow-2xl rounded-xl p-3 ml-1 my-2 mr-3 flex flex-col justify-around">
    <div id="top" class="justify-self-center content-center items-center place-content-center">
      <img alt="Logo" src="riot-logo.svg"/>
      <div id="projectbrief">
        The friendly Operating System for the Internet of Things
      </div>
    </div>
    <div id="search" class="place-content-center" class="overflow-y-scroll max-h-64 bg-slate-400 ring-2 ring-white text-white" >
      <h1>Searchbar via Pagefind</h1>
      <!-- <div id="searchstub" class="flex items-center border border-gray-300 rounded-lg p-2 shadow-sm">
        <input type="text" placeholder="Search is only available in Production Build ..." class="flex-grow p-2 outline-none">
      </div> -->
    </div>
    <div id="navtree">
      <script>
        // The navtree variable is always a pair of two elements (key, value)
        // The key is the name we should display and the value is the link to the page
        // Generate the navtree from the navtreedata.js file and put it under the navtree div
        var navtree = NAVTREE[0][2];
        var navtreeHTML = "<h1>Navigation based on Doxygen</h1> <ul>";
        for (var i = 0; i < navtree.length; i++) {
          navtreeHTML += "<li><a href='" + navtree[i][1] + "'>" + navtree[i][0] + "</a></li>";
          if (i == 5) {
            navtreeHTML += '<li><h3 class="ring-2 ring-white"> Random Insert for Demonstration </h3></li>';
          }
        }
        navtreeHTML += "</ul>";
        document.getElementById("navtree").innerHTML = navtreeHTML;
      </script>
    </div>
    <ul>
      <li class="footer">
        Generated on Tue Sep 24 2024 11:16:27 by 
          <a href="http://www.doxygen.org/index.html">
            Doxygen
          </a> 
        1.12.0
      </li>
    </ul>
  </div>
  <!--Main Content-->
  <div class="hidden">
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',true);
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('group__drivers__mtd.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#groups">Topics</a> &#124;
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">Memory Technology Device<div class="ingroups"><a class="el" href="group__drivers.html">Drivers</a> &raquo; <a class="el" href="group__drivers__storage.html">Storage Device Drivers</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Low level Memory Technology Device interface  
<a href="#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Low level Memory Technology Device interface </p>
<p>Generic memory technology device interface</p>
<p>Unlike the <a class="el" href="group__drivers__periph__flashpage.html">Flash page driver</a>, this is device driver based (i.e. all functions take a <a class="el" href="structmtd__dev__t.html">mtd_dev_t</a> as a first argument), so that SPI based EEPROMs (e.g. <a class="el" href="group__drivers__mtd__at25xxx.html">AT25xxx</a>) can be accessed the same way as <a class="el" href="group__drivers__mtd__flashpage.html">internal flash</a> or <a class="el" href="group__drivers__mtd__sdcard.html">SD cards</a>), all inside the same application.</p>
<p>MTD devices expose a block based erase and write interface. In that, they are the distinct from block devices (like hard disks) on which individual bytes can be overwritten. The <a href="http://www.linux-mtd.infradead.org/faq/general.html">Linux MTD FAQ</a> has a convenient comparison (beware though of terminology differences outlined below). They can be erased (with some granularity, often wearing out the erased area a bit), and erased areas can be written to (sometimes multiple times).</p>
<p>MTD devices are described in terms of sectors, pages and feature flags:</p>
<ul>
<li><p class="startli">A <b>sector</b> is the device's erase unit. Calls to <a class="el" href="#gaabab7f7b0b1cfcdbe2b32d2e26bbf4d7">mtd_erase</a> need to work in alignment with this number (commonly somewhere around 1kiB).</p>
<p class="startli">(Note that this corresponds to the term "page" as used in the flashpage API, and the term "eraseblock" in Linux's MTD).</p>
</li>
<li><p class="startli">A <b>page</b> is the largest a device can write in one transfer.</p>
<p class="startli">Applications rarely need to deal with this; it offers no guarantees on atomicity, but writing within a page is generally faster than across page boundaries.</p>
<p class="startli">Pages are a subdivision of sectors.</p>
</li>
<li><p class="startli">The <b>write size</b> is the minimum size of writes to the device, and also the required alignment of writes.</p>
<p class="startli">The write size is a divider of the page. It is often between 1 to 4 bytes long, but may be up to the full page size.</p>
</li>
<li>The device's <b>flags</b> indicate features, eg. whether a memory location can be overwritten without erasing it first.</li>
</ul>
<p>Unless a flag (such as <a class="el" href="#gacd32ebfc4ee09f64d7e2490c4f5504fb">MTD_DRIVER_FLAG_DIRECT_WRITE</a> or <a class="el" href="#ga08bad3026290086a5215b85bd1c62f51">MTD_DRIVER_FLAG_CLEARING_OVERWRITE</a>) allows it, this MTD API does not allow memory areas to be written to twice between erase operations. Drivers are not expected to count write accesses, and neither do this module's functions: The performance impact would be too great. It is up to the application to only write to erased memory once. Failure to do so may damage hardware.</p>
<p>This MTD API currently does not specify which value will be read from an erased sector. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="groups" name="groups"></a>
Topics</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drivers__mtd__emulated.html">MTD wrapper for emulated MTD devices</a></td></tr>
<tr class="memdesc:group__drivers__mtd__emulated"><td class="mdescLeft">&#160;</td><td class="mdescRight">MTD device that is emulated in RAM for test purposes <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drivers__mtd__native.html">Native MTD</a></td></tr>
<tr class="memdesc:group__drivers__mtd__native"><td class="mdescLeft">&#160;</td><td class="mdescRight"><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="files" name="files"></a>
Files</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mtd_8h.html">mtd.h</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmtd__dev__t.html">mtd_dev_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">MTD device descriptor.  <a href="structmtd__dev__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmtd__desc.html">mtd_desc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">MTD driver interface.  <a href="structmtd__desc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaf0ba0e302d3f3711c691fdfbda1461ac" id="r_gaf0ba0e302d3f3711c691fdfbda1461ac"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf0ba0e302d3f3711c691fdfbda1461ac">MTD_XFA_ADD</a>(dev,  idx)</td></tr>
<tr class="memdesc:gaf0ba0e302d3f3711c691fdfbda1461ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define MTD device pointer variable <code>mtd&lt;idx&gt;</code>  <br /></td></tr>
<tr class="separator:gaf0ba0e302d3f3711c691fdfbda1461ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed6dda925a94ee38ebfa0b6105461893" id="r_gaed6dda925a94ee38ebfa0b6105461893"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaed6dda925a94ee38ebfa0b6105461893">MTD_NUMOF</a>&#160;&#160;&#160;<a class="el" href="xfa_8h.html#ad15d5dae13c2d1ffdab3fd64d78e1b4b">XFA_LEN</a>(<a class="el" href="structmtd__dev__t.html">mtd_dev_t</a> *, <a class="el" href="#ga290552e29a4074f1b34c0067e39886df">mtd_dev_xfa</a>)</td></tr>
<tr class="memdesc:gaed6dda925a94ee38ebfa0b6105461893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of MTDs defined in the MTD device array in XFA.  <br /></td></tr>
<tr class="separator:gaed6dda925a94ee38ebfa0b6105461893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd32ebfc4ee09f64d7e2490c4f5504fb" id="r_gacd32ebfc4ee09f64d7e2490c4f5504fb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gacd32ebfc4ee09f64d7e2490c4f5504fb">MTD_DRIVER_FLAG_DIRECT_WRITE</a>&#160;&#160;&#160;(1 &lt;&lt; 0)</td></tr>
<tr class="memdesc:gacd32ebfc4ee09f64d7e2490c4f5504fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">MTD driver can write any data to the storage without erasing it first.  <br /></td></tr>
<tr class="separator:gacd32ebfc4ee09f64d7e2490c4f5504fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08bad3026290086a5215b85bd1c62f51" id="r_ga08bad3026290086a5215b85bd1c62f51"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga08bad3026290086a5215b85bd1c62f51">MTD_DRIVER_FLAG_CLEARING_OVERWRITE</a>&#160;&#160;&#160;(1 &lt;&lt; 1)</td></tr>
<tr class="memdesc:ga08bad3026290086a5215b85bd1c62f51"><td class="mdescLeft">&#160;</td><td class="mdescRight">MTD driver supports arbitrary clearing overwrites.  <br /></td></tr>
<tr class="separator:ga08bad3026290086a5215b85bd1c62f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga016431acc3cc8d6f5a40149225dabc05" id="r_ga016431acc3cc8d6f5a40149225dabc05"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structmtd__desc.html">mtd_desc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga016431acc3cc8d6f5a40149225dabc05">mtd_desc_t</a></td></tr>
<tr class="memdesc:ga016431acc3cc8d6f5a40149225dabc05"><td class="mdescLeft">&#160;</td><td class="mdescRight">MTD driver interface.  <br /></td></tr>
<tr class="separator:ga016431acc3cc8d6f5a40149225dabc05"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga2e588df22ed1a520ba154adbd93b1455" id="r_ga2e588df22ed1a520ba154adbd93b1455"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2e588df22ed1a520ba154adbd93b1455">mtd_power_state</a> { <a class="el" href="#gga2e588df22ed1a520ba154adbd93b1455a860be5ff4a3cfb933b479391d2538939">MTD_POWER_UP</a>
, <a class="el" href="#gga2e588df22ed1a520ba154adbd93b1455a81eb56a249bbf2eebd5cfbd8ef2c7ce8">MTD_POWER_DOWN</a>
 }</td></tr>
<tr class="memdesc:ga2e588df22ed1a520ba154adbd93b1455"><td class="mdescLeft">&#160;</td><td class="mdescRight">MTD power states.  <a href="#ga2e588df22ed1a520ba154adbd93b1455">More...</a><br /></td></tr>
<tr class="separator:ga2e588df22ed1a520ba154adbd93b1455"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga6bcf582eaf56330ea31c1162ea535076" id="r_ga6bcf582eaf56330ea31c1162ea535076"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6bcf582eaf56330ea31c1162ea535076">mtd_init</a> (<a class="el" href="structmtd__dev__t.html">mtd_dev_t</a> *mtd)</td></tr>
<tr class="memdesc:ga6bcf582eaf56330ea31c1162ea535076"><td class="mdescLeft">&#160;</td><td class="mdescRight">mtd_init Initialize a MTD device  <br /></td></tr>
<tr class="separator:ga6bcf582eaf56330ea31c1162ea535076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74ffca1da0436aada58ef3f18f469e36" id="r_ga74ffca1da0436aada58ef3f18f469e36"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga74ffca1da0436aada58ef3f18f469e36">mtd_read</a> (<a class="el" href="structmtd__dev__t.html">mtd_dev_t</a> *mtd, void *dest, uint32_t addr, uint32_t count)</td></tr>
<tr class="memdesc:ga74ffca1da0436aada58ef3f18f469e36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from a MTD device.  <br /></td></tr>
<tr class="separator:ga74ffca1da0436aada58ef3f18f469e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b72c0b58ed1f5a3ff4cc7cd4965dd83" id="r_ga8b72c0b58ed1f5a3ff4cc7cd4965dd83"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8b72c0b58ed1f5a3ff4cc7cd4965dd83">mtd_read_page</a> (<a class="el" href="structmtd__dev__t.html">mtd_dev_t</a> *mtd, void *dest, uint32_t page, uint32_t offset, uint32_t size)</td></tr>
<tr class="memdesc:ga8b72c0b58ed1f5a3ff4cc7cd4965dd83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from a MTD device with pagewise addressing.  <br /></td></tr>
<tr class="separator:ga8b72c0b58ed1f5a3ff4cc7cd4965dd83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f36fb25e0daada2e9a873475c532d94" id="r_ga5f36fb25e0daada2e9a873475c532d94"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5f36fb25e0daada2e9a873475c532d94">mtd_write</a> (<a class="el" href="structmtd__dev__t.html">mtd_dev_t</a> *mtd, const void *src, uint32_t addr, uint32_t count)</td></tr>
<tr class="memdesc:ga5f36fb25e0daada2e9a873475c532d94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to a MTD device.  <br /></td></tr>
<tr class="separator:ga5f36fb25e0daada2e9a873475c532d94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cb5d1eed19f88f4e4b970541f7dcbf6" id="r_ga6cb5d1eed19f88f4e4b970541f7dcbf6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6cb5d1eed19f88f4e4b970541f7dcbf6">mtd_write_page_raw</a> (<a class="el" href="structmtd__dev__t.html">mtd_dev_t</a> *mtd, const void *src, uint32_t page, uint32_t offset, uint32_t size)</td></tr>
<tr class="memdesc:ga6cb5d1eed19f88f4e4b970541f7dcbf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to a MTD device with pagewise addressing.  <br /></td></tr>
<tr class="separator:ga6cb5d1eed19f88f4e4b970541f7dcbf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad52a5002206227b278f6cbb1efb605d3" id="r_gad52a5002206227b278f6cbb1efb605d3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad52a5002206227b278f6cbb1efb605d3">mtd_write_page</a> (<a class="el" href="structmtd__dev__t.html">mtd_dev_t</a> *mtd, const void *src, uint32_t page, uint32_t offset, uint32_t size)</td></tr>
<tr class="memdesc:gad52a5002206227b278f6cbb1efb605d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to a MTD device with pagewise addressing.  <br /></td></tr>
<tr class="separator:gad52a5002206227b278f6cbb1efb605d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabab7f7b0b1cfcdbe2b32d2e26bbf4d7" id="r_gaabab7f7b0b1cfcdbe2b32d2e26bbf4d7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaabab7f7b0b1cfcdbe2b32d2e26bbf4d7">mtd_erase</a> (<a class="el" href="structmtd__dev__t.html">mtd_dev_t</a> *mtd, uint32_t addr, uint32_t count)</td></tr>
<tr class="memdesc:gaabab7f7b0b1cfcdbe2b32d2e26bbf4d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase sectors of a MTD device.  <br /></td></tr>
<tr class="separator:gaabab7f7b0b1cfcdbe2b32d2e26bbf4d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9c761bda55271360e1797491ef2ef7f" id="r_gaf9c761bda55271360e1797491ef2ef7f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf9c761bda55271360e1797491ef2ef7f">mtd_erase_sector</a> (<a class="el" href="structmtd__dev__t.html">mtd_dev_t</a> *mtd, uint32_t sector, uint32_t num)</td></tr>
<tr class="memdesc:gaf9c761bda55271360e1797491ef2ef7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase sectors of a MTD device.  <br /></td></tr>
<tr class="separator:gaf9c761bda55271360e1797491ef2ef7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40c7db24bb97158581694edc4eaf20aa" id="r_ga40c7db24bb97158581694edc4eaf20aa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga40c7db24bb97158581694edc4eaf20aa">mtd_write_sector</a> (<a class="el" href="structmtd__dev__t.html">mtd_dev_t</a> *mtd, const void *src, uint32_t sector, uint32_t num)</td></tr>
<tr class="memdesc:ga40c7db24bb97158581694edc4eaf20aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to a MTD device with whole sector writes.  <br /></td></tr>
<tr class="separator:ga40c7db24bb97158581694edc4eaf20aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf44f35470c2180ebd4b772f3b25d31fc" id="r_gaf44f35470c2180ebd4b772f3b25d31fc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf44f35470c2180ebd4b772f3b25d31fc">mtd_power</a> (<a class="el" href="structmtd__dev__t.html">mtd_dev_t</a> *mtd, enum <a class="el" href="#ga2e588df22ed1a520ba154adbd93b1455">mtd_power_state</a> power)</td></tr>
<tr class="memdesc:gaf44f35470c2180ebd4b772f3b25d31fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set power mode on a MTD device.  <br /></td></tr>
<tr class="separator:gaf44f35470c2180ebd4b772f3b25d31fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab30ea4a0cbe3dde3af8ba0460dc7320a" id="r_gab30ea4a0cbe3dde3af8ba0460dc7320a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structmtd__dev__t.html">mtd_dev_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab30ea4a0cbe3dde3af8ba0460dc7320a">mtd_dev_get</a> (unsigned idx)</td></tr>
<tr class="memdesc:gab30ea4a0cbe3dde3af8ba0460dc7320a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an MTD device by index.  <br /></td></tr>
<tr class="separator:gab30ea4a0cbe3dde3af8ba0460dc7320a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga290552e29a4074f1b34c0067e39886df" id="r_ga290552e29a4074f1b34c0067e39886df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmtd__dev__t.html">mtd_dev_t</a> *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga290552e29a4074f1b34c0067e39886df">mtd_dev_xfa</a> []</td></tr>
<tr class="memdesc:ga290552e29a4074f1b34c0067e39886df"><td class="mdescLeft">&#160;</td><td class="mdescRight">MTD device array as XFA.  <br /></td></tr>
<tr class="separator:ga290552e29a4074f1b34c0067e39886df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47b37b36f751674b439437dfa622aba7" id="r_ga47b37b36f751674b439437dfa622aba7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structmtd__dev__t.html">mtd_dev_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga47b37b36f751674b439437dfa622aba7">mtd_default_get_dev</a> (unsigned idx)</td></tr>
<tr class="memdesc:ga47b37b36f751674b439437dfa622aba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default MTD device configuration.  <br /></td></tr>
<tr class="separator:ga47b37b36f751674b439437dfa622aba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga08bad3026290086a5215b85bd1c62f51" name="ga08bad3026290086a5215b85bd1c62f51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08bad3026290086a5215b85bd1c62f51">&#9670;&#160;</a></span>MTD_DRIVER_FLAG_CLEARING_OVERWRITE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MTD_DRIVER_FLAG_CLEARING_OVERWRITE&#160;&#160;&#160;(1 &lt;&lt; 1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>MTD driver supports arbitrary clearing overwrites. </p>
<p>If this is set, (arbitrarily) many writes are permitted per write size, and the result is the old value bitwise-AND the written value.</p>
<p>This property is common for managed flash memories. (By comparison, the raw flash often used internally by MCUs may not allow overwrites, or may allow them with the same semantics, but only for a limited number of writes between erasures; there is currently no flag describing these any further). </p>

<p class="definition">Definition at line <a class="el" href="mtd_8h_source.html#l00192">192</a> of file <a class="el" href="mtd_8h_source.html">mtd.h</a>.</p>

</div>
</div>
<a id="gacd32ebfc4ee09f64d7e2490c4f5504fb" name="gacd32ebfc4ee09f64d7e2490c4f5504fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd32ebfc4ee09f64d7e2490c4f5504fb">&#9670;&#160;</a></span>MTD_DRIVER_FLAG_DIRECT_WRITE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MTD_DRIVER_FLAG_DIRECT_WRITE&#160;&#160;&#160;(1 &lt;&lt; 0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>MTD driver can write any data to the storage without erasing it first. </p>
<p>If this is set, a write completely overrides the previous values. </p>

<p class="definition">Definition at line <a class="el" href="mtd_8h_source.html#l00179">179</a> of file <a class="el" href="mtd_8h_source.html">mtd.h</a>.</p>

</div>
</div>
<a id="gaed6dda925a94ee38ebfa0b6105461893" name="gaed6dda925a94ee38ebfa0b6105461893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed6dda925a94ee38ebfa0b6105461893">&#9670;&#160;</a></span>MTD_NUMOF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MTD_NUMOF&#160;&#160;&#160;<a class="el" href="xfa_8h.html#ad15d5dae13c2d1ffdab3fd64d78e1b4b">XFA_LEN</a>(<a class="el" href="structmtd__dev__t.html">mtd_dev_t</a> *, <a class="el" href="#ga290552e29a4074f1b34c0067e39886df">mtd_dev_xfa</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of MTDs defined in the MTD device array in XFA. </p>

<p class="definition">Definition at line <a class="el" href="mtd_8h_source.html#l00172">172</a> of file <a class="el" href="mtd_8h_source.html">mtd.h</a>.</p>

</div>
</div>
<a id="gaf0ba0e302d3f3711c691fdfbda1461ac" name="gaf0ba0e302d3f3711c691fdfbda1461ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0ba0e302d3f3711c691fdfbda1461ac">&#9670;&#160;</a></span>MTD_XFA_ADD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MTD_XFA_ADD</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>dev</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>idx</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <a class="code hl_define" href="xfa_8h.html#a75af4442640ca0b89f1e4fc8a8c5cc80">XFA_CONST</a>(<a class="code hl_variable" href="#ga290552e29a4074f1b34c0067e39886df">mtd_dev_xfa</a>, idx) <a class="code hl_struct" href="structmtd__dev__t.html">mtd_dev_t</a> *mtd ## idx = (<a class="code hl_struct" href="structmtd__dev__t.html">mtd_dev_t</a> *)&amp;(dev)</div>
<div class="ttc" id="agroup__drivers__mtd_html_ga290552e29a4074f1b34c0067e39886df"><div class="ttname"><a href="#ga290552e29a4074f1b34c0067e39886df">mtd_dev_xfa</a></div><div class="ttdeci">mtd_dev_t *const mtd_dev_xfa[]</div><div class="ttdoc">MTD device array as XFA.</div><div class="ttdef"><b>Definition</b> <a href="mtd_8h_source.html#l00139">mtd.h:139</a></div></div>
<div class="ttc" id="astructmtd__dev__t_html"><div class="ttname"><a href="structmtd__dev__t.html">mtd_dev_t</a></div><div class="ttdoc">MTD device descriptor.</div><div class="ttdef"><b>Definition</b> <a href="mtd_8h_source.html#l00112">mtd.h:112</a></div></div>
<div class="ttc" id="axfa_8h_html_a75af4442640ca0b89f1e4fc8a8c5cc80"><div class="ttname"><a href="xfa_8h.html#a75af4442640ca0b89f1e4fc8a8c5cc80">XFA_CONST</a></div><div class="ttdeci">#define XFA_CONST(xfa_name, prio)</div><div class="ttdoc">Define variable in read-only cross-file array.</div><div class="ttdef"><b>Definition</b> <a href="xfa_8h_source.html#l00158">xfa.h:158</a></div></div>
</div><!-- fragment -->
<p>Define MTD device pointer variable <code>mtd&lt;idx&gt;</code> </p>
<p>The macro defines the MTD device pointer variable <code>mtd&lt;idx&gt;</code>, sets it to the address of the MTD device specified by the <code>dev</code> parameter, and adds it to the XFA of MTD device pointers <a class="el" href="#ga290552e29a4074f1b34c0067e39886df">mtd_dev_xfa</a>. For example </p><div class="fragment"><div class="line"><a class="code hl_define" href="#gaf0ba0e302d3f3711c691fdfbda1461ac">MTD_XFA_ADD</a>(my_dev, 1);</div>
<div class="ttc" id="agroup__drivers__mtd_html_gaf0ba0e302d3f3711c691fdfbda1461ac"><div class="ttname"><a href="#gaf0ba0e302d3f3711c691fdfbda1461ac">MTD_XFA_ADD</a></div><div class="ttdeci">#define MTD_XFA_ADD(dev, idx)</div><div class="ttdoc">Define MTD device pointer variable mtd&lt;idx&gt;</div><div class="ttdef"><b>Definition</b> <a href="mtd_8h_source.html#l00166">mtd.h:166</a></div></div>
</div><!-- fragment --><p> defines the variable <code>mtd1</code> pointing to the device <code>my_dev</code>.</p>
<p>The parameter <code>idx</code> is used as priority of the MTD device pointer within the XFA. That means it determines the order of the MTD device pointers within <a class="el" href="#ga290552e29a4074f1b34c0067e39886df">mtd_dev_xfa</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Only if each MTD device is added with a unique priority and only if the priorities start at 0 and are used in consecutive order, the parameter <code>idx</code> corresponds to the position of the MTD device pointer within the <a class="el" href="#ga290552e29a4074f1b34c0067e39886df">mtd_dev_xfa</a> XFA and <code>mtd_dev_xfa[i]</code> points to the i-th MTD device.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev</td><td>MTD device </td></tr>
    <tr><td class="paramname">idx</td><td>Priority of the MTD device pointer within the XFA </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mtd_8h_source.html#l00166">166</a> of file <a class="el" href="mtd_8h_source.html">mtd.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga016431acc3cc8d6f5a40149225dabc05" name="ga016431acc3cc8d6f5a40149225dabc05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga016431acc3cc8d6f5a40149225dabc05">&#9670;&#160;</a></span>mtd_desc_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structmtd__desc.html">mtd_desc</a> <a class="el" href="#ga016431acc3cc8d6f5a40149225dabc05">mtd_desc_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>MTD driver interface. </p>
<p>This define the functions to access a MTD.</p>
<p>A MTD is composed of pages combined into sectors. A sector is the smallest erasable unit. The number of pages in a sector must be constant for the whole MTD.</p>
<p>The erase operation is available only for entire sectors. </p>

<p class="definition">Definition at line <a class="el" href="mtd_8h_source.html#l00104">104</a> of file <a class="el" href="mtd_8h_source.html">mtd.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga2e588df22ed1a520ba154adbd93b1455" name="ga2e588df22ed1a520ba154adbd93b1455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e588df22ed1a520ba154adbd93b1455">&#9670;&#160;</a></span>mtd_power_state</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ga2e588df22ed1a520ba154adbd93b1455">mtd_power_state</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>MTD power states. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga2e588df22ed1a520ba154adbd93b1455a860be5ff4a3cfb933b479391d2538939" name="gga2e588df22ed1a520ba154adbd93b1455a860be5ff4a3cfb933b479391d2538939"></a>MTD_POWER_UP&#160;</td><td class="fielddoc"><p>Power up. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2e588df22ed1a520ba154adbd93b1455a81eb56a249bbf2eebd5cfbd8ef2c7ce8" name="gga2e588df22ed1a520ba154adbd93b1455a81eb56a249bbf2eebd5cfbd8ef2c7ce8"></a>MTD_POWER_DOWN&#160;</td><td class="fielddoc"><p>Power down. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="mtd_8h_source.html#l00089">89</a> of file <a class="el" href="mtd_8h_source.html">mtd.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga47b37b36f751674b439437dfa622aba7" name="ga47b37b36f751674b439437dfa622aba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47b37b36f751674b439437dfa622aba7">&#9670;&#160;</a></span>mtd_default_get_dev()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structmtd__dev__t.html">mtd_dev_t</a> * mtd_default_get_dev </td>
          <td>(</td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>idx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default MTD device configuration. </p>
<p>Helpers for generic MTD use.</p>
<dl class="section author"><dt>Author</dt><dd>Benjamin Valentin <a href="#" onclick="location.href='mai'+'lto:'+'ben'+'ja'+'min'+'.v'+'ale'+'nt'+'in@'+'ml'+'-pa'+'.c'+'om'; return false;">benja<span class="obfuscator">.nosp@m.</span>min.<span class="obfuscator">.nosp@m.</span>valen<span class="obfuscator">.nosp@m.</span>tin@<span class="obfuscator">.nosp@m.</span>ml-pa<span class="obfuscator">.nosp@m.</span>.com</a></dd></dl>
<p>Get the default MTD device by index</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000008">Deprecated</a></b></dt><dd>Use <a class="el" href="#gab30ea4a0cbe3dde3af8ba0460dc7320a">mtd_dev_get</a> instead</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>Index of the MTD device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MTD_0 for <code>idx</code> 0 and so on NULL if no MTD device exists for the given index </dd></dl>

<p class="definition">Definition at line <a class="el" href="mtd__default_8h_source.html#l00054">54</a> of file <a class="el" href="mtd__default_8h_source.html">mtd_default.h</a>.</p>

</div>
</div>
<a id="gab30ea4a0cbe3dde3af8ba0460dc7320a" name="gab30ea4a0cbe3dde3af8ba0460dc7320a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab30ea4a0cbe3dde3af8ba0460dc7320a">&#9670;&#160;</a></span>mtd_dev_get()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structmtd__dev__t.html">mtd_dev_t</a> * mtd_dev_get </td>
          <td>(</td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>idx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an MTD device by index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>Index of the MTD device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MTD_0 for <code>idx</code> 0 and so on NULL if no MTD device exists for the given index </dd></dl>

<p class="definition">Definition at line <a class="el" href="mtd_8h_source.html#l00535">535</a> of file <a class="el" href="mtd_8h_source.html">mtd.h</a>.</p>

</div>
</div>
<a id="gaabab7f7b0b1cfcdbe2b32d2e26bbf4d7" name="gaabab7f7b0b1cfcdbe2b32d2e26bbf4d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaabab7f7b0b1cfcdbe2b32d2e26bbf4d7">&#9670;&#160;</a></span>mtd_erase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mtd_erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmtd__dev__t.html">mtd_dev_t</a> *</td>          <td class="paramname"><span class="paramname"><em>mtd</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>addr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase sectors of a MTD device. </p>
<p><code>addr</code> must be aligned on a sector boundary. <code>count</code> must be a multiple of a sector size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">mtd</td><td>the device to erase </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>the address of the first sector to erase </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>the number of bytes to erase</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if erase successful </td></tr>
    <tr><td class="paramname">&lt;0</td><td>if an error occurred </td></tr>
    <tr><td class="paramname">-ENODEV</td><td>if <code>mtd</code> is not a valid device </td></tr>
    <tr><td class="paramname">-ENOTSUP</td><td>if operation is not supported on <code>mtd</code> </td></tr>
    <tr><td class="paramname">-EOVERFLOW</td><td>if <code>addr</code> or <code>count</code> are not valid, i.e. outside memory </td></tr>
    <tr><td class="paramname">-EIO</td><td>if I/O error occurred </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf9c761bda55271360e1797491ef2ef7f" name="gaf9c761bda55271360e1797491ef2ef7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9c761bda55271360e1797491ef2ef7f">&#9670;&#160;</a></span>mtd_erase_sector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mtd_erase_sector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmtd__dev__t.html">mtd_dev_t</a> *</td>          <td class="paramname"><span class="paramname"><em>mtd</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>sector</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>num</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase sectors of a MTD device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">mtd</td><td>the device to erase </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sector</td><td>the first sector number to erase </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>the number of sectors to erase</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if erase successful </td></tr>
    <tr><td class="paramname">&lt;0</td><td>if an error occurred </td></tr>
    <tr><td class="paramname">-ENODEV</td><td>if <code>mtd</code> is not a valid device </td></tr>
    <tr><td class="paramname">-ENOTSUP</td><td>if operation is not supported on <code>mtd</code> </td></tr>
    <tr><td class="paramname">-EOVERFLOW</td><td>if <code>addr</code> or <code>sector</code> are not valid, i.e. outside memory </td></tr>
    <tr><td class="paramname">-EIO</td><td>if I/O error occurred </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6bcf582eaf56330ea31c1162ea535076" name="ga6bcf582eaf56330ea31c1162ea535076"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6bcf582eaf56330ea31c1162ea535076">&#9670;&#160;</a></span>mtd_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mtd_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmtd__dev__t.html">mtd_dev_t</a> *</td>          <td class="paramname"><span class="paramname"><em>mtd</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>mtd_init Initialize a MTD device </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtd</td><td>the device to initialize</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success </td></tr>
    <tr><td class="paramname">&lt;0</td><td>on error probably errno </td></tr>
    <tr><td class="paramname">-ENODEV</td><td>if no device if given or no driver is set </td></tr>
    <tr><td class="paramname">-ENOTSUP</td><td>if device has no init function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf44f35470c2180ebd4b772f3b25d31fc" name="gaf44f35470c2180ebd4b772f3b25d31fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf44f35470c2180ebd4b772f3b25d31fc">&#9670;&#160;</a></span>mtd_power()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mtd_power </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmtd__dev__t.html">mtd_dev_t</a> *</td>          <td class="paramname"><span class="paramname"><em>mtd</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="#ga2e588df22ed1a520ba154adbd93b1455">mtd_power_state</a></td>          <td class="paramname"><span class="paramname"><em>power</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set power mode on a MTD device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">mtd</td><td>the device to access </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">power</td><td>the power mode to set</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if power mode successfully set </td></tr>
    <tr><td class="paramname">&lt;0</td><td>if an error occurred </td></tr>
    <tr><td class="paramname">-ENODEV</td><td>if <code>mtd</code> is not a valid device </td></tr>
    <tr><td class="paramname">-ENOTSUP</td><td>if operation or <code>power</code> state is not supported on <code>mtd</code> </td></tr>
    <tr><td class="paramname">-EIO</td><td>if I/O error occurred </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga74ffca1da0436aada58ef3f18f469e36" name="ga74ffca1da0436aada58ef3f18f469e36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga74ffca1da0436aada58ef3f18f469e36">&#9670;&#160;</a></span>mtd_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mtd_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmtd__dev__t.html">mtd_dev_t</a> *</td>          <td class="paramname"><span class="paramname"><em>mtd</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>addr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read data from a MTD device. </p>
<p>No alignment is required on <code>addr</code> and <code>count</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">mtd</td><td>the device to read from </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>the buffer to fill in </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>the start address to read from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>the number of bytes to read</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success </td></tr>
    <tr><td class="paramname">&lt;0</td><td>if an error occurred </td></tr>
    <tr><td class="paramname">-ENODEV</td><td>if <code>mtd</code> is not a valid device </td></tr>
    <tr><td class="paramname">-ENOTSUP</td><td>if operation is not supported on <code>mtd</code> </td></tr>
    <tr><td class="paramname">-EOVERFLOW</td><td>if <code>addr</code> or <code>count</code> are not valid, i.e. outside memory </td></tr>
    <tr><td class="paramname">-EIO</td><td>if I/O error occurred </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8b72c0b58ed1f5a3ff4cc7cd4965dd83" name="ga8b72c0b58ed1f5a3ff4cc7cd4965dd83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b72c0b58ed1f5a3ff4cc7cd4965dd83">&#9670;&#160;</a></span>mtd_read_page()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mtd_read_page </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmtd__dev__t.html">mtd_dev_t</a> *</td>          <td class="paramname"><span class="paramname"><em>mtd</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>page</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read data from a MTD device with pagewise addressing. </p>
<p>The MTD layer will take care of splitting up the transaction into multiple reads if it is required by the underlying storage media.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">mtd</td><td>the device to read from </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>the buffer to fill in </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">page</td><td>Page number to start reading from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>offset from the start of the page (in bytes) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the number of bytes to read</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success </td></tr>
    <tr><td class="paramname">&lt;0</td><td>value on error </td></tr>
    <tr><td class="paramname">-ENODEV</td><td>if <code>mtd</code> is not a valid device </td></tr>
    <tr><td class="paramname">-ENOTSUP</td><td>if operation is not supported on <code>mtd</code> </td></tr>
    <tr><td class="paramname">-EOVERFLOW</td><td>if <code>addr</code> or <code>count</code> are not valid, i.e. outside memory </td></tr>
    <tr><td class="paramname">-EIO</td><td>if I/O error occurred </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5f36fb25e0daada2e9a873475c532d94" name="ga5f36fb25e0daada2e9a873475c532d94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f36fb25e0daada2e9a873475c532d94">&#9670;&#160;</a></span>mtd_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mtd_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmtd__dev__t.html">mtd_dev_t</a> *</td>          <td class="paramname"><span class="paramname"><em>mtd</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>addr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write data to a MTD device. </p>
<p><code>addr</code> + <code>count</code> must be inside a page boundary. <code>addr</code> can be anywhere but the buffer cannot overlap two pages.</p>
<p>Both parameters must be multiples of the device's write size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">mtd</td><td>the device to write to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>the buffer to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>the start address to write to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>the number of bytes to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success </td></tr>
    <tr><td class="paramname">&lt;0</td><td>if an error occurred </td></tr>
    <tr><td class="paramname">-ENODEV</td><td>if <code>mtd</code> is not a valid device </td></tr>
    <tr><td class="paramname">-ENOTSUP</td><td>if operation is not supported on <code>mtd</code> </td></tr>
    <tr><td class="paramname">-EOVERFLOW</td><td>if <code>addr</code> or <code>count</code> are not valid, i.e. outside memory, or overlapping two pages </td></tr>
    <tr><td class="paramname">-EIO</td><td>if I/O error occurred </td></tr>
    <tr><td class="paramname">-EINVAL</td><td>if parameters are invalid (invalid alignment for instance) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad52a5002206227b278f6cbb1efb605d3" name="gad52a5002206227b278f6cbb1efb605d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad52a5002206227b278f6cbb1efb605d3">&#9670;&#160;</a></span>mtd_write_page()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mtd_write_page </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmtd__dev__t.html">mtd_dev_t</a> *</td>          <td class="paramname"><span class="paramname"><em>mtd</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>page</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write data to a MTD device with pagewise addressing. </p>
<p>The MTD layer will take care of splitting up the transaction into multiple writes if it is required by the underlying storage media.</p>
<p>If the underlying sector needs to be erased before it can be written, the MTD layer will take care of the read-modify-write operation.</p>
<p><code>offset</code> must be smaller than the page size</p>
<dl class="section note"><dt>Note</dt><dd>this requires the <code>mtd_write_page</code> module</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">mtd</td><td>the device to write to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>the buffer to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">page</td><td>Page number to start writing to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>byte offset from the start of the page </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the number of bytes to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success </td></tr>
    <tr><td class="paramname">&lt;0</td><td>value on error </td></tr>
    <tr><td class="paramname">-ENODEV</td><td>if <code>mtd</code> is not a valid device </td></tr>
    <tr><td class="paramname">-ENOTSUP</td><td>if operation is not supported on <code>mtd</code> </td></tr>
    <tr><td class="paramname">-EOVERFLOW</td><td>if <code>addr</code> or <code>count</code> are not valid, i.e. outside memory, </td></tr>
    <tr><td class="paramname">-EIO</td><td>if I/O error occurred </td></tr>
    <tr><td class="paramname">-EINVAL</td><td>if parameters are invalid </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6cb5d1eed19f88f4e4b970541f7dcbf6" name="ga6cb5d1eed19f88f4e4b970541f7dcbf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6cb5d1eed19f88f4e4b970541f7dcbf6">&#9670;&#160;</a></span>mtd_write_page_raw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mtd_write_page_raw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmtd__dev__t.html">mtd_dev_t</a> *</td>          <td class="paramname"><span class="paramname"><em>mtd</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>page</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write data to a MTD device with pagewise addressing. </p>
<p>The MTD layer will take care of splitting up the transaction into multiple writes if it is required by the underlying storage media.</p>
<p>This performs a raw write, no automatic read-modify-write cycle is performed.</p>
<p>Both <code>offset</code> and <code>size</code> must be multiples of the device's write size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">mtd</td><td>the device to write to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>the buffer to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">page</td><td>Page number to start writing to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>byte offset from the start of the page </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>the number of bytes to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success </td></tr>
    <tr><td class="paramname">&lt;0</td><td>value on error </td></tr>
    <tr><td class="paramname">-ENODEV</td><td>if <code>mtd</code> is not a valid device </td></tr>
    <tr><td class="paramname">-ENOTSUP</td><td>if operation is not supported on <code>mtd</code> </td></tr>
    <tr><td class="paramname">-EOVERFLOW</td><td>if <code>addr</code> or <code>count</code> are not valid, i.e. outside memory, </td></tr>
    <tr><td class="paramname">-EIO</td><td>if I/O error occurred </td></tr>
    <tr><td class="paramname">-EINVAL</td><td>if parameters are invalid </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga40c7db24bb97158581694edc4eaf20aa" name="ga40c7db24bb97158581694edc4eaf20aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40c7db24bb97158581694edc4eaf20aa">&#9670;&#160;</a></span>mtd_write_sector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mtd_write_sector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmtd__dev__t.html">mtd_dev_t</a> *</td>          <td class="paramname"><span class="paramname"><em>mtd</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>sector</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>num</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write data to a MTD device with whole sector writes. </p>
<p>The MTD layer will take care of splitting up the transaction into multiple writes if it is required by the underlying storage media.</p>
<p>The sectors will be erased before writing if needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">mtd</td><td>Device to write to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Buffer to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sector</td><td>Sector number to start writing to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>Number of sectors to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success </td></tr>
    <tr><td class="paramname">&lt;0</td><td>value on error </td></tr>
    <tr><td class="paramname">-ENODEV</td><td>if <code>mtd</code> is not a valid device </td></tr>
    <tr><td class="paramname">-ENOTSUP</td><td>if operation is not supported on <code>mtd</code> </td></tr>
    <tr><td class="paramname">-EOVERFLOW</td><td>if <code>addr</code> or <code>count</code> are not valid, i.e. outside memory, </td></tr>
    <tr><td class="paramname">-EIO</td><td>if I/O error occurred </td></tr>
    <tr><td class="paramname">-EINVAL</td><td>if parameters are invalid </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga290552e29a4074f1b34c0067e39886df" name="ga290552e29a4074f1b34c0067e39886df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga290552e29a4074f1b34c0067e39886df">&#9670;&#160;</a></span>mtd_dev_xfa</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmtd__dev__t.html">mtd_dev_t</a>* const mtd_dev_xfa[]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>MTD device array as XFA. </p>
<p>The array contains the addresses of all MTD devices that are defined using the <a class="el" href="#gaf0ba0e302d3f3711c691fdfbda1461ac">MTD_XFA_ADD</a> macro, for example: </p><div class="fragment"><div class="line"><a class="code hl_define" href="#gaf0ba0e302d3f3711c691fdfbda1461ac">MTD_XFA_ADD</a>(my_dev, 0);</div>
</div><!-- fragment --><p> The MTD devices in this array can be used for automatic functions such as with the <code>mtd_default</code> module. The i-th device in this array can then be accessed with <code>mtd_dev_xfa[i]</code>. The number of MTDs defined in this array is <code><a class="el" href="xfa_8h.html#ad15d5dae13c2d1ffdab3fd64d78e1b4b" title="Calculate number of entries in cross-file array.">XFA_LEN(mtd_dev_xfa)</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="mtd_8h_source.html#l00139">139</a> of file <a class="el" href="mtd_8h_source.html">mtd.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->

    </div>
  </body>
</html>
