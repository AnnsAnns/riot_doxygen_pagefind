<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RIOT OS: Autoconn</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<!-- <script type="text/javascript" src="jquery.js"></script> -->
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<!-- <link href="/pagefind/pagefind-ui.css" rel="stylesheet"> -->
<script src="/pagefind/pagefind-ui.js"></script>
<script>
  // Check whether the PagefindUI class is available
  if (typeof PagefindUI === 'undefined') {
    console.error('PagefindUI class is not available | Dev Build');
  } else {
    // // Remove the "searchstub" element and initialize the PagefindUI class
    // document.getElementById("#searchstub").remove();
    // Initialize the PagefindUI class with the element id "search"
    window.addEventListener('DOMContentLoaded', (event) => {
        new PagefindUI({ element: "#search", showSubResults: true });
    });
  }
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="global.css" rel="stylesheet" type="text/css" />
</head>
<body>
  <script>
    // Print the data within the NAVTREE variable from the navtreedata.js file
    var navtree = NAVTREE;
    console.log(navtree);
  </script>
<div class="flex flex-row gap-4 w-screen font-sans text-lg max-h-screen overscroll-contain justify-items-stretch bg-neutral-900">
  <!--Sidebar-->
  <div data-pagefind-ignore="all" class="w-1/3 max-w-md flex-auto h-screen bg-neutral-800 ring-2 ring-neutral-700 shadow-neutral-800 shadow-2xl rounded-xl p-3 ml-1 my-2 mr-3 flex flex-col justify-around">
    <div id="top" class="justify-self-center content-center items-center place-content-center">
      <img alt="Logo" src="riot-logo.svg"/>
      <div id="projectbrief">
        The friendly Operating System for the Internet of Things
      </div>
    </div>
    <div id="search" class="place-content-center" class="overflow-y-scroll max-h-64 bg-slate-400 ring-2 ring-white text-white" >
      <h1>Searchbar via Pagefind</h1>
      <!-- <div id="searchstub" class="flex items-center border border-gray-300 rounded-lg p-2 shadow-sm">
        <input type="text" placeholder="Search is only available in Production Build ..." class="flex-grow p-2 outline-none">
      </div> -->
    </div>
    <div id="navtree">
      <script>
        // The navtree variable is always a pair of two elements (key, value)
        // The key is the name we should display and the value is the link to the page
        // Generate the navtree from the navtreedata.js file and put it under the navtree div
        var navtree = NAVTREE[0][2];
        var navtreeHTML = "<h1>Navigation based on Doxygen</h1> <ul>";
        for (var i = 0; i < navtree.length; i++) {
          navtreeHTML += "<li><a href='" + navtree[i][1] + "'>" + navtree[i][0] + "</a></li>";
          if (i == 5) {
            navtreeHTML += '<li><h3 class="ring-2 ring-white"> Random Insert for Demonstration </h3></li>';
          }
        }
        navtreeHTML += "</ul>";
        document.getElementById("navtree").innerHTML = navtreeHTML;
      </script>
    </div>
    <ul>
      <li class="footer">
        Generated on Tue Sep 24 2024 11:16:26 by 
          <a href="http://www.doxygen.org/index.html">
            Doxygen
          </a> 
        1.12.0
      </li>
    </ul>
  </div>
  <!--Main Content-->
  <div class="hidden">
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',true);
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('group__pkg__nimble__autoconn.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Autoconn<div class="ingroups"><a class="el" href="group__pkg.html">Packages</a> &#124; <a class="el" href="group__net.html">Networking</a> &raquo; <a class="el" href="group__ble.html">Bluetooth Low Energy (BLE)</a> &raquo; <a class="el" href="group__pkg__nimble.html">NimBLE</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Simple connection manager that automatically opens BLE connections to any node that fits some given filter criteria  
<a href="#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Simple connection manager that automatically opens BLE connections to any node that fits some given filter criteria </p>
<dl class="section warning"><dt>Warning</dt><dd><b class="text-danger">This feature is experimental!</b><br  />
 </dd></dl>
<h1><a class="anchor" id="autotoc_md1848"></a>
WARNING</h1>
<p>This module is highly experimental! Expect bugs, instabilities and sudden API changes :-)</p>
<h1><a class="anchor" id="autotoc_md1849"></a>
About</h1>
<p>This NimBLE submodule implements a connection manager for BLE. It takes care of scanning, advertising, and opening connections to neighboring nodes. For this autoconn periodically switches between advertising and scanning mode, hence from accepting incoming connection requests to scanning actively for new neighbors.</p>
<h1><a class="anchor" id="autotoc_md1850"></a>
Concept</h1>
<p>The IETF and BT SIG standards describing IP-over-BLE only describe how to transfer IP data over L2CAP connection oriented channels. But they do not say anything about when BLE connections should be established between two BLE nodes in the first place. While this can be done manually (e.g. via RIOTs <code>ble</code> shell command), this is certainly no option in massive M2M deployments.</p>
<p>To enable nodes to automatically connect to their neighbors, autoconn implements a naive strategy which makes nodes to connect to any neighbor they see, as long as the neighbor signals a predefined set of capabilities.</p>
<p>In particular, neighbors are simply filtered by looking at the 16-bit service UUIDs included in the <code>Incomplete List of 16-bit Service UUIDs</code> field in the advertising data that is received from neighbors.</p>
<p>The logical network topology (as seen by IP) is formed by the established BLE link layer connections. It is important to node, that the autoconn module will form a random topology on the link layer, as no further context information is used for the connection decisions. This can potentially lead to fragmented, non-connected sub-networks in larger deployments!</p>
<h1><a class="anchor" id="autotoc_md1851"></a>
State Machine</h1>
<p>Autoconn implements a state machine, that switches a nodes role periodically between scanning and advertising. To make sure, that nodes always have a chance to see each other, especially when booted at the same point in time, the intervals of each role consist of a constant amount of time plus a random interval. This way two nodes will eventually see each other and be able to establish a connection.</p>
<p>All timing values for the interval duration and the maximum amount of the random offset are configurable.</p>
<h1><a class="anchor" id="autotoc_md1852"></a>
Usage</h1>
<p>In the current state, the filtering of neighbors is hard coded into the autoconn module. Two options are implemented:</p>
<ol type="1">
<li>connect to any neighbor capable of IP-over-BLE -&gt; <a class="el" href="group__ble__defs.html#gaddb36be01640aefd1cf9d1273092a4e3">BLE_GATT_SVC_IPSS</a> UUID included in the BLE_GAP_AD_UUID16_INCOMP field of the received advertising data</li>
<li>connect to any neighbor capable of NDN-over-BLE -&gt; <a class="el" href="group__ble__defs.html#ga917cc9eba844f34f5c71f9065668d6ff">BLE_GATT_SVC_NDNSS</a> UUID included in the BLE_GAP_AD_UUID16_INCOMP field of the received advertising data</li>
</ol>
<p>The active filter used in autoconn is selected using one of two submodules during build time:</p>
<ol type="1">
<li><code>USEMDOULE += nimble_autoconn_ipsp</code></li>
<li>&lsquo;USEMODULE += nibmle_autoconn_ndnsp&rsquo;</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>The NDN support service (NDNSP) is defined by us and it is not at all standardized nor sanctioned by the BT SIG. For experimental use only...</dd></dl>
<h1><a class="anchor" id="autotoc_md1853"></a>
Implementation Status</h1>
<ul>
<li>The filter function could be more powerful. It is probably a good idea to extend this module to allow for passing custom filter functions using a function pointer</li>
<li>Currently this module does not allow to use NimBLE as IP-over-BLE node and as a GATT server concurrently. This could be enabled by adding an additional callback function which exposes some/all GAP events to a user application (i.e. BLE_GAP_EVENT_SUBSCRIBE, BLE_GAP_EVENT_NOTIFY_RX, BLE_GAP_EVENT_NOTIFY_TX).</li>
<li>It might make sense to get rid of the periodic switching between scanning and advertising in favor of doing both in parallel. This would simplify the code (and configuration) quite a bit. But in the past, there were severe stability issues with NimBLE doing this, so it needs to be evaluated in the future if this is a feasible option. </li>
</ul>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="files" name="files"></a>
Files</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nimble__autoconn_8h.html">nimble_autoconn.h</a></td></tr>
<tr class="memdesc:nimble__autoconn_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple automated connection manager for NimBLE netif. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nimble__autoconn__params_8h.html">nimble_autoconn_params.h</a></td></tr>
<tr class="memdesc:nimble__autoconn__params_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default configuration for the nimble_autoconn module. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnimble__autoconn__params__t.html">nimble_autoconn_params_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of configuration parameters needed to run autoconn.  <a href="structnimble__autoconn__params__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gacf031a18714fab9c47677ce9eba30e70" id="r_gacf031a18714fab9c47677ce9eba30e70"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="#ggacf031a18714fab9c47677ce9eba30e70ae3b2f68607077056f0392724e95b5897">NIMBLE_AUTOCONN_OK</a> = 0
, <a class="el" href="#ggacf031a18714fab9c47677ce9eba30e70ad4f9c31382c5ba24737e394d1aee3b41">NIMBLE_AUTOCONN_PARAMERR</a> = -1
, <a class="el" href="#ggacf031a18714fab9c47677ce9eba30e70a12dff9b5332609748fbd09b3c3192cc5">NIMBLE_AUTOCONN_ADERR</a> = -2
 }</td></tr>
<tr class="memdesc:gacf031a18714fab9c47677ce9eba30e70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return codes used by the autoconn module.  <a href="#gacf031a18714fab9c47677ce9eba30e70">More...</a><br /></td></tr>
<tr class="separator:gacf031a18714fab9c47677ce9eba30e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga4104186cd847c39ff064bc6a4774ab62" id="r_ga4104186cd847c39ff064bc6a4774ab62"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4104186cd847c39ff064bc6a4774ab62">nimble_autoconn_init</a> (const <a class="el" href="structnimble__autoconn__params__t.html">nimble_autoconn_params_t</a> *params, const uint8_t *ad, size_t adlen)</td></tr>
<tr class="memdesc:ga4104186cd847c39ff064bc6a4774ab62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize and enable the autoconn module.  <br /></td></tr>
<tr class="separator:ga4104186cd847c39ff064bc6a4774ab62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c4f680c8cc944eff73beb5cd2bfd547" id="r_ga3c4f680c8cc944eff73beb5cd2bfd547"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3c4f680c8cc944eff73beb5cd2bfd547">nimble_autoconn_eventcb</a> (<a class="el" href="group__pkg__nimble__netif.html#gab1da1302e4fc013bf5c6d65029da922b">nimble_netif_eventcb_t</a> cb)</td></tr>
<tr class="memdesc:ga3c4f680c8cc944eff73beb5cd2bfd547"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a callback that is called on netif events.  <br /></td></tr>
<tr class="separator:ga3c4f680c8cc944eff73beb5cd2bfd547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf71c33159e24daef7cbf59d95e65ea8" id="r_gacf71c33159e24daef7cbf59d95e65ea8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gacf71c33159e24daef7cbf59d95e65ea8">nimble_autoconn_update</a> (const <a class="el" href="structnimble__autoconn__params__t.html">nimble_autoconn_params_t</a> *params, const uint8_t *ad, size_t adlen)</td></tr>
<tr class="memdesc:gacf71c33159e24daef7cbf59d95e65ea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the used parameters (timing and node ID)  <br /></td></tr>
<tr class="separator:gacf71c33159e24daef7cbf59d95e65ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab65002584b89e7588bcf25e2893b82c" id="r_gaab65002584b89e7588bcf25e2893b82c"><td class="memItemLeft" align="right" valign="top"><a id="gaab65002584b89e7588bcf25e2893b82c" name="gaab65002584b89e7588bcf25e2893b82c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>nimble_autoconn_enable</b> (void)</td></tr>
<tr class="memdesc:gaab65002584b89e7588bcf25e2893b82c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable automated creation of new BLE connections. <br /></td></tr>
<tr class="separator:gaab65002584b89e7588bcf25e2893b82c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07c0e1179a5ebfab831989e9c2725da4" id="r_ga07c0e1179a5ebfab831989e9c2725da4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga07c0e1179a5ebfab831989e9c2725da4">nimble_autoconn_disable</a> (void)</td></tr>
<tr class="memdesc:ga07c0e1179a5ebfab831989e9c2725da4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the automated connection management.  <br /></td></tr>
<tr class="separator:ga07c0e1179a5ebfab831989e9c2725da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gacf031a18714fab9c47677ce9eba30e70" name="gacf031a18714fab9c47677ce9eba30e70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf031a18714fab9c47677ce9eba30e70">&#9670;&#160;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return codes used by the autoconn module. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggacf031a18714fab9c47677ce9eba30e70ae3b2f68607077056f0392724e95b5897" name="ggacf031a18714fab9c47677ce9eba30e70ae3b2f68607077056f0392724e95b5897"></a>NIMBLE_AUTOCONN_OK&#160;</td><td class="fielddoc"><p>like a walk in the park </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacf031a18714fab9c47677ce9eba30e70ad4f9c31382c5ba24737e394d1aee3b41" name="ggacf031a18714fab9c47677ce9eba30e70ad4f9c31382c5ba24737e394d1aee3b41"></a>NIMBLE_AUTOCONN_PARAMERR&#160;</td><td class="fielddoc"><p>invalid parameters given </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacf031a18714fab9c47677ce9eba30e70a12dff9b5332609748fbd09b3c3192cc5" name="ggacf031a18714fab9c47677ce9eba30e70a12dff9b5332609748fbd09b3c3192cc5"></a>NIMBLE_AUTOCONN_ADERR&#160;</td><td class="fielddoc"><p>error generating advertising data </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="nimble__autoconn_8h_source.html#l00123">123</a> of file <a class="el" href="nimble__autoconn_8h_source.html">nimble_autoconn.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga07c0e1179a5ebfab831989e9c2725da4" name="ga07c0e1179a5ebfab831989e9c2725da4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07c0e1179a5ebfab831989e9c2725da4">&#9670;&#160;</a></span>nimble_autoconn_disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nimble_autoconn_disable </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable the automated connection management. </p>
<dl class="section note"><dt>Note</dt><dd>All existing connections are kept, only the scanning and advertising is canceled </dd></dl>

</div>
</div>
<a id="ga3c4f680c8cc944eff73beb5cd2bfd547" name="ga3c4f680c8cc944eff73beb5cd2bfd547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c4f680c8cc944eff73beb5cd2bfd547">&#9670;&#160;</a></span>nimble_autoconn_eventcb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nimble_autoconn_eventcb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__pkg__nimble__netif.html#gab1da1302e4fc013bf5c6d65029da922b">nimble_netif_eventcb_t</a></td>          <td class="paramname"><span class="paramname"><em>cb</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a callback that is called on netif events. </p>
<p>The registered callback function is a simple pass-through of nimble_netif events. The callback is executed in the context of NimBLE's host thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>event callback to register, may be NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4104186cd847c39ff064bc6a4774ab62" name="ga4104186cd847c39ff064bc6a4774ab62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4104186cd847c39ff064bc6a4774ab62">&#9670;&#160;</a></span>nimble_autoconn_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nimble_autoconn_init </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnimble__autoconn__params__t.html">nimble_autoconn_params_t</a> *</td>          <td class="paramname"><span class="paramname"><em>params</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>ad</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>adlen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize and enable the autoconn module. </p>
<dl class="section warning"><dt>Warning</dt><dd>This function <b>must</b> only be called once. Typically this is during system initialization or at the beginning of the user application. Use <a class="el" href="#gacf71c33159e24daef7cbf59d95e65ea8" title="Update the used parameters (timing and node ID)">nimble_autoconn_update()</a> to update parameters at runtime.</dd>
<dd>
Autoconn expects nimble_netif to be initialized. So make sure <a class="el" href="group__pkg__nimble__netif.html#ga571a0f63aa1f6d4c3a8a4588d2b971b2" title="Initialize the netif implementation, spawns the netif thread.">nimble_netif_init()</a> was called before calling <a class="el" href="#ga4104186cd847c39ff064bc6a4774ab62" title="Initialize and enable the autoconn module.">nimble_autoconn_init()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>timing parameters to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ad</td><td>advertising data, if NULL it is generated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">adlen</td><td>length of <code>ad</code> in bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacf71c33159e24daef7cbf59d95e65ea8" name="gacf71c33159e24daef7cbf59d95e65ea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf71c33159e24daef7cbf59d95e65ea8">&#9670;&#160;</a></span>nimble_autoconn_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nimble_autoconn_update </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnimble__autoconn__params__t.html">nimble_autoconn_params_t</a> *</td>          <td class="paramname"><span class="paramname"><em>params</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>ad</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>adlen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the used parameters (timing and node ID) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>new parameters to apply </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ad</td><td>advertising data, if NULL it is generated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">adlen</td><td>length of <code>ad</code> in bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NIMBLE_AUTOCONN_OK if everything went fine </dd>
<dd>
NIMBLE_AUTOCONN_INVALID if given parameters can not be applied </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->

    </div>
  </body>
</html>
