<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RIOT OS: Stack-independent helpers for IPv6 over X</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<!-- <script type="text/javascript" src="jquery.js"></script> -->
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<!-- <link href="/pagefind/pagefind-ui.css" rel="stylesheet"> -->
<script src="/pagefind/pagefind-ui.js"></script>
<script>
  // Check whether the PagefindUI class is available
  if (typeof PagefindUI === 'undefined') {
    console.error('PagefindUI class is not available | Dev Build');
  } else {
    // // Remove the "searchstub" element and initialize the PagefindUI class
    // document.getElementById("#searchstub").remove();
    // Initialize the PagefindUI class with the element id "search"
    window.addEventListener('DOMContentLoaded', (event) => {
        new PagefindUI({ element: "#search", showSubResults: true });
    });
  }
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="global.css" rel="stylesheet" type="text/css" />
</head>
<body>
  <script>
    // Print the data within the NAVTREE variable from the navtreedata.js file
    var navtree = NAVTREE;
    console.log(navtree);
  </script>
<div class="flex flex-row gap-4 w-screen font-sans text-lg max-h-screen overscroll-contain justify-items-stretch bg-neutral-900">
  <!--Sidebar-->
  <div data-pagefind-ignore="all" class="w-1/3 max-w-md flex-auto h-screen bg-neutral-800 ring-2 ring-neutral-700 shadow-neutral-800 shadow-2xl rounded-xl p-3 ml-1 my-2 mr-3 flex flex-col justify-around">
    <div id="top" class="justify-self-center content-center items-center place-content-center">
      <img alt="Logo" src="riot-logo.svg"/>
      <div id="projectbrief">
        The friendly Operating System for the Internet of Things
      </div>
    </div>
    <div id="search" class="place-content-center" class="overflow-y-scroll max-h-64 bg-slate-400 ring-2 ring-white text-white" >
      <h1>Searchbar via Pagefind</h1>
      <!-- <div id="searchstub" class="flex items-center border border-gray-300 rounded-lg p-2 shadow-sm">
        <input type="text" placeholder="Search is only available in Production Build ..." class="flex-grow p-2 outline-none">
      </div> -->
    </div>
    <div id="navtree">
      <script>
        // The navtree variable is always a pair of two elements (key, value)
        // The key is the name we should display and the value is the link to the page
        // Generate the navtree from the navtreedata.js file and put it under the navtree div
        var navtree = NAVTREE[0][2];
        var navtreeHTML = "<h1>Navigation based on Doxygen</h1> <ul>";
        for (var i = 0; i < navtree.length; i++) {
          navtreeHTML += "<li><a href='" + navtree[i][1] + "'>" + navtree[i][0] + "</a></li>";
          if (i == 5) {
            navtreeHTML += '<li><h3 class="ring-2 ring-white"> Random Insert for Demonstration </h3></li>';
          }
        }
        navtreeHTML += "</ul>";
        document.getElementById("navtree").innerHTML = navtreeHTML;
      </script>
    </div>
    <ul>
      <li class="footer">
        Generated on Tue Sep 24 2024 11:16:27 by 
          <a href="http://www.doxygen.org/index.html">
            Doxygen
          </a> 
        1.12.0
      </li>
    </ul>
  </div>
  <!--Main Content-->
  <div class="hidden">
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',true);
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('group__net__l2util.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Stack-independent helpers for IPv6 over X<div class="ingroups"><a class="el" href="group__net.html">Networking</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>This implements some common helper functions for IPv6 over X implementations based on [network device types] (<a class="el" href="group__drivers__netdev__api.html#net_netdev_type">net_netdev_type</a>).  
<a href="#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This implements some common helper functions for IPv6 over X implementations based on [network device types] (<a class="el" href="group__drivers__netdev__api.html#net_netdev_type">net_netdev_type</a>). </p>
<dl class="section attention"><dt>Attention</dt><dd>If you add a new <a class="el" href="group__drivers__netdev__api.html#net_netdev_type">network device type</a> have at least a look at the implementation of these functions. </dd></dl>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="files" name="files"></a>
Files</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="l2util_8h.html">l2util.h</a></td></tr>
<tr class="memdesc:l2util_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Link-layer helper function definitions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaba3a9961273c671516cf4c03a26b3fe7" id="r_gaba3a9961273c671516cf4c03a26b3fe7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaba3a9961273c671516cf4c03a26b3fe7">L2UTIL_ADDR_MAX_LEN</a>&#160;&#160;&#160;(8U)</td></tr>
<tr class="memdesc:gaba3a9961273c671516cf4c03a26b3fe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximum expected length for addresses  <br /></td></tr>
<tr class="separator:gaba3a9961273c671516cf4c03a26b3fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga020ec2ca8f4855a9f893ee386eec34e6" id="r_ga020ec2ca8f4855a9f893ee386eec34e6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga020ec2ca8f4855a9f893ee386eec34e6">l2util_eui64_from_addr</a> (int dev_type, const uint8_t *addr, size_t addr_len, <a class="el" href="unioneui64__t.html">eui64_t</a> *eui64)</td></tr>
<tr class="memdesc:ga020ec2ca8f4855a9f893ee386eec34e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a given hardware address to an EUI-64.  <br /></td></tr>
<tr class="separator:ga020ec2ca8f4855a9f893ee386eec34e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59e4110fa917f59738899558171f531c" id="r_ga59e4110fa917f59738899558171f531c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga59e4110fa917f59738899558171f531c">l2util_ipv6_iid_from_addr</a> (int dev_type, const uint8_t *addr, size_t addr_len, <a class="el" href="unioneui64__t.html">eui64_t</a> *iid)</td></tr>
<tr class="memdesc:ga59e4110fa917f59738899558171f531c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a given hardware address to an IPv6 IID.  <br /></td></tr>
<tr class="separator:ga59e4110fa917f59738899558171f531c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac685fa77c277cbe1cf8ace342867f97c" id="r_gac685fa77c277cbe1cf8ace342867f97c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac685fa77c277cbe1cf8ace342867f97c">l2util_ipv6_iid_to_addr</a> (int dev_type, const <a class="el" href="unioneui64__t.html">eui64_t</a> *iid, uint8_t *addr)</td></tr>
<tr class="memdesc:gac685fa77c277cbe1cf8ace342867f97c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an IPv6 IID to a hardware address.  <br /></td></tr>
<tr class="separator:gac685fa77c277cbe1cf8ace342867f97c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4786395f69ace734b00f4351fa360b0f" id="r_ga4786395f69ace734b00f4351fa360b0f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4786395f69ace734b00f4351fa360b0f">l2util_ndp_addr_len_from_l2ao</a> (int dev_type, const <a class="el" href="structndp__opt__t.html">ndp_opt_t</a> *opt)</td></tr>
<tr class="memdesc:ga4786395f69ace734b00f4351fa360b0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derives the length of the link-layer address in an NDP link-layer address option from that option's length field and the given device type.  <br /></td></tr>
<tr class="separator:ga4786395f69ace734b00f4351fa360b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9bd8721c1275326fbbb7a5f9cd05a8d" id="r_gae9bd8721c1275326fbbb7a5f9cd05a8d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae9bd8721c1275326fbbb7a5f9cd05a8d">l2util_ipv6_group_to_l2_group</a> (int dev_type, const <a class="el" href="unionipv6__addr__t.html">ipv6_addr_t</a> *ipv6_group, uint8_t *l2_group)</td></tr>
<tr class="memdesc:gae9bd8721c1275326fbbb7a5f9cd05a8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an IPv6 multicast address to a multicast address of the respective link layer.  <br /></td></tr>
<tr class="separator:gae9bd8721c1275326fbbb7a5f9cd05a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa49618a5f26e8c9ae3db4ce85c2d434" id="r_gafa49618a5f26e8c9ae3db4ce85c2d434"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gafa49618a5f26e8c9ae3db4ce85c2d434">l2util_addr_to_str</a> (const uint8_t *addr, size_t addr_len, char *out)</td></tr>
<tr class="memdesc:gafa49618a5f26e8c9ae3db4ce85c2d434"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a hardware address to a human readable string.  <br /></td></tr>
<tr class="separator:gafa49618a5f26e8c9ae3db4ce85c2d434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa4c7f588480db684853d97de113361b" id="r_gaaa4c7f588480db684853d97de113361b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaaa4c7f588480db684853d97de113361b">l2util_addr_from_str</a> (const char *str, uint8_t *out)</td></tr>
<tr class="memdesc:gaaa4c7f588480db684853d97de113361b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a string of colon-separated hexadecimals to a hardware address.  <br /></td></tr>
<tr class="separator:gaaa4c7f588480db684853d97de113361b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0cb89f915e1ca055865d5a53a317c0a" id="r_gaf0cb89f915e1ca055865d5a53a317c0a"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf0cb89f915e1ca055865d5a53a317c0a">l2util_addr_equal</a> (const uint8_t *addr_a, uint8_t addr_a_len, const uint8_t *addr_b, uint8_t addr_b_len)</td></tr>
<tr class="memdesc:gaf0cb89f915e1ca055865d5a53a317c0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two l2 addresses are equal.  <br /></td></tr>
<tr class="separator:gaf0cb89f915e1ca055865d5a53a317c0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gaba3a9961273c671516cf4c03a26b3fe7" name="gaba3a9961273c671516cf4c03a26b3fe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba3a9961273c671516cf4c03a26b3fe7">&#9670;&#160;</a></span>L2UTIL_ADDR_MAX_LEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define L2UTIL_ADDR_MAX_LEN&#160;&#160;&#160;(8U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>maximum expected length for addresses </p>

<p class="definition">Definition at line <a class="el" href="l2util_8h_source.html#l00037">37</a> of file <a class="el" href="l2util_8h_source.html">l2util.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaf0cb89f915e1ca055865d5a53a317c0a" name="gaf0cb89f915e1ca055865d5a53a317c0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0cb89f915e1ca055865d5a53a317c0a">&#9670;&#160;</a></span>l2util_addr_equal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool l2util_addr_equal </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>addr_a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>addr_a_len</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>addr_b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>addr_b_len</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if two l2 addresses are equal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr_a</td><td>First hardware address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr_a_len</td><td>Length of first hardware address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr_b</td><td>Second hardware address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr_b_len</td><td>Length of second hardware address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the addresses match, false if not. </dd></dl>

<p class="definition">Definition at line <a class="el" href="l2util_8h_source.html#l00203">203</a> of file <a class="el" href="l2util_8h_source.html">l2util.h</a>.</p>

</div>
</div>
<a id="gaaa4c7f588480db684853d97de113361b" name="gaaa4c7f588480db684853d97de113361b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa4c7f588480db684853d97de113361b">&#9670;&#160;</a></span>l2util_addr_from_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t l2util_addr_from_str </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *</td>          <td class="paramname"><span class="paramname"><em>out</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses a string of colon-separated hexadecimals to a hardware address. </p>
<p>The input format must be like <code>xx:xx:xx:xx</code> where <code>xx</code> will be the bytes of <code>addr</code> in hexadecimal representation.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>(out != NULL)</code> </dd>
<dd>
<code>out</code> <b>MUST</b> have allocated at least <a class="el" href="group__net__gnrc__netif__conf.html#ga907d9c7ff80e5dbd6f338f02bf276947">GNRC_NETIF_L2ADDR_MAXLEN</a> bytes.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>A string of colon-separated hexadecimals. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>The resulting hardware address. Must at least have <a class="el" href="group__net__gnrc__netif__conf.html#ga907d9c7ff80e5dbd6f338f02bf276947">GNRC_NETIF_L2ADDR_MAXLEN</a> bytes allocated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Actual length of <code>out</code> on success. </dd>
<dd>
0, on failure. </dd></dl>

</div>
</div>
<a id="gafa49618a5f26e8c9ae3db4ce85c2d434" name="gafa49618a5f26e8c9ae3db4ce85c2d434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa49618a5f26e8c9ae3db4ce85c2d434">&#9670;&#160;</a></span>l2util_addr_to_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * l2util_addr_to_str </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>addr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>addr_len</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>out</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a hardware address to a human readable string. </p>
<p>The format will be like <code>xx:xx:xx:xx</code> where <code>xx</code> are the bytes of <code>addr</code> in hexadecimal representation.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>(out != NULL) &amp;&amp; ((addr != NULL) || (addr_len == 0))</code> </dd>
<dd>
<code>out</code> <b>MUST</b> have allocated at least 3 * <code>addr_len</code> bytes.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>A hardware address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr_len</td><td>Length of <code>addr</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>A string to store the output in. Must at least have 3 * <code>addr_len</code> bytes allocated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>out</code>. </dd></dl>

</div>
</div>
<a id="ga020ec2ca8f4855a9f893ee386eec34e6" name="ga020ec2ca8f4855a9f893ee386eec34e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga020ec2ca8f4855a9f893ee386eec34e6">&#9670;&#160;</a></span>l2util_eui64_from_addr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int l2util_eui64_from_addr </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dev_type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>addr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>addr_len</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unioneui64__t.html">eui64_t</a> *</td>          <td class="paramname"><span class="paramname"><em>eui64</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a given hardware address to an EUI-64. </p>
<dl class="section attention"><dt>Attention</dt><dd>When the link-layer of the interface has link-layer addresses, and <code>NDEBUG</code> is not defined, the node fails with an assertion instead returning <code>-ENOTSUP</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev_type</td><td>The network device type of the device <code>addr</code> came from (either because it is the configured address of the device or from a packet that came over it). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>A hardware address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr_len</td><td>Number of bytes in <code>addr</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">eui64</td><td>The EUI-64 based on <a class="el" href="structgnrc__netif__t.html#a269e7bb2472a008176c8e173cd152600" title="Device type.">gnrc_netif_t::device_type</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>sizeof(eui64_t)</code> on success. </dd>
<dd>
<code>-ENOTSUP</code>, when <code>dev_type</code> does not support EUI-64 conversion. </dd>
<dd>
<code>-EINVAL</code>, when <code>addr_len</code> is invalid for the <code>dev_type</code>. </dd></dl>

</div>
</div>
<a id="gae9bd8721c1275326fbbb7a5f9cd05a8d" name="gae9bd8721c1275326fbbb7a5f9cd05a8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9bd8721c1275326fbbb7a5f9cd05a8d">&#9670;&#160;</a></span>l2util_ipv6_group_to_l2_group()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int l2util_ipv6_group_to_l2_group </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dev_type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="unionipv6__addr__t.html">ipv6_addr_t</a> *</td>          <td class="paramname"><span class="paramname"><em>ipv6_group</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *</td>          <td class="paramname"><span class="paramname"><em>l2_group</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an IPv6 multicast address to a multicast address of the respective link layer. </p>
<dl class="section pre"><dt>Precondition</dt><dd>There is enough allocated space in <code>l2_group</code> for an address for a device of type <code>dev_type</code> (e.g. 6 bytes for an ethernet address).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev_type</td><td>The network device type of the device <code>l2_addr</code> should be generated for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ipv6_group</td><td>An IPv6 multicast address. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">l2_group</td><td>A link layer multicast address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Length of <code>l2_group</code> in bytes </dd>
<dd>
<code>-ENOTSUP</code> if link layer does not support multicast. </dd></dl>

</div>
</div>
<a id="ga59e4110fa917f59738899558171f531c" name="ga59e4110fa917f59738899558171f531c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59e4110fa917f59738899558171f531c">&#9670;&#160;</a></span>l2util_ipv6_iid_from_addr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int l2util_ipv6_iid_from_addr </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dev_type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *</td>          <td class="paramname"><span class="paramname"><em>addr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>addr_len</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unioneui64__t.html">eui64_t</a> *</td>          <td class="paramname"><span class="paramname"><em>iid</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a given hardware address to an IPv6 IID. </p>
<dl class="section attention"><dt>Attention</dt><dd>When the link-layer of the interface has link-layer addresses, and <code>NDEBUG</code> is not defined, the node fails with an assertion instead returning <code>-ENOTSUP</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev_type</td><td>The network device type of the device <code>addr</code> came from (either because it is the configured address of the device or from a packet that came over it). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>A hardware address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr_len</td><td>Number of bytes in <code>addr</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">iid</td><td>The IID based on <a class="el" href="structgnrc__netif__t.html#a269e7bb2472a008176c8e173cd152600" title="Device type.">gnrc_netif_t::device_type</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>sizeof(eui64_t)</code> on success. </dd>
<dd>
<code>-ENOTSUP</code>, when <code>dev_type</code> does not support IID conversion. </dd>
<dd>
<code>-EINVAL</code>, when <code>addr_len</code> is invalid for the <code>dev_type</code>. </dd></dl>

</div>
</div>
<a id="gac685fa77c277cbe1cf8ace342867f97c" name="gac685fa77c277cbe1cf8ace342867f97c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac685fa77c277cbe1cf8ace342867f97c">&#9670;&#160;</a></span>l2util_ipv6_iid_to_addr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int l2util_ipv6_iid_to_addr </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dev_type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="unioneui64__t.html">eui64_t</a> *</td>          <td class="paramname"><span class="paramname"><em>iid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *</td>          <td class="paramname"><span class="paramname"><em>addr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts an IPv6 IID to a hardware address. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>iid</code> was based on a hardware address </dd>
<dd>
The number of bytes available at <code>addr</code> is less or equal to <a class="el" href="#gaba3a9961273c671516cf4c03a26b3fe7">L2UTIL_ADDR_MAX_LEN</a>.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>When <code>NDEBUG</code> is not defined, the node fails with an assertion instead of returning <code>-ENOTSUP</code></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev_type</td><td>The network device type of the device the <code>iid</code> came from (either because it is based on the configured address of the device or from a packet that came over it). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iid</td><td>An IID based on <code>dev_type</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">addr</td><td>The hardware address. It is assumed that <code>iid</code> was based on a hardware address and that the available number of bytes in <code>addr</code> are greater or equal to <a class="el" href="#gaba3a9961273c671516cf4c03a26b3fe7">L2UTIL_ADDR_MAX_LEN</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Length of resulting <code>addr</code> on success. </dd>
<dd>
<code>-ENOTSUP</code>, when <code>dev_type</code> does not support reverse IID conversion. </dd></dl>

</div>
</div>
<a id="ga4786395f69ace734b00f4351fa360b0f" name="ga4786395f69ace734b00f4351fa360b0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4786395f69ace734b00f4351fa360b0f">&#9670;&#160;</a></span>l2util_ndp_addr_len_from_l2ao()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int l2util_ndp_addr_len_from_l2ao </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dev_type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structndp__opt__t.html">ndp_opt_t</a> *</td>          <td class="paramname"><span class="paramname"><em>opt</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Derives the length of the link-layer address in an NDP link-layer address option from that option's length field and the given device type. </p>
<dl class="section note"><dt>Note</dt><dd>If an RFC exists that specifies how IPv6 operates over a link-layer, this function usually implements the section "Unicast Address
         Mapping".</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://tools.ietf.org/html/rfc4861#section-4.6.1">RFC 4861, section 4.6.1</a></dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>When <code>NDEBUG</code> is not defined, the node fails with an assertion instead of returning <code>-ENOTSUP</code></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev_type</td><td>The network device type of the device the <code>opt</code> came over in an NDP message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opt</td><td>An NDP source/target link-layer address option.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Length of the link-layer address in <code>opt</code> on success </dd>
<dd>
<code>-ENOTSUP</code>, when implementation does not know how to derive the length of the link-layer address from <code>opt's</code> length field based on <code>dev_type</code>. </dd>
<dd>
<code>-EINVAL</code> if <code>opt-&gt;len</code> was an invalid value for the given <code>dev_type</code>. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->

    </div>
  </body>
</html>
