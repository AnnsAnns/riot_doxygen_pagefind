<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RIOT OS: Secure Element Key Management</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<!-- <script type="text/javascript" src="jquery.js"></script> -->
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<!-- <link href="/pagefind/pagefind-ui.css" rel="stylesheet"> -->
<script src="/pagefind/pagefind-ui.js"></script>
<script>
  // Check whether the PagefindUI class is available
  if (typeof PagefindUI === 'undefined') {
    console.error('PagefindUI class is not available | Dev Build');
  } else {
    // // Remove the "searchstub" element and initialize the PagefindUI class
    // document.getElementById("#searchstub").remove();
    // Initialize the PagefindUI class with the element id "search"
    window.addEventListener('DOMContentLoaded', (event) => {
        new PagefindUI({ element: "#search", showSubResults: true });
    });
  }
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="global.css" rel="stylesheet" type="text/css" />
</head>
<body>
  <script>
    // Print the data within the NAVTREE variable from the navtreedata.js file
    var navtree = NAVTREE;
    console.log(navtree);
  </script>
<div class="flex flex-row gap-4 w-screen font-sans text-lg max-h-screen overscroll-contain justify-items-stretch bg-neutral-900">
  <!--Sidebar-->
  <div data-pagefind-ignore="all" class="w-1/3 max-w-md flex-auto h-screen bg-neutral-800 ring-2 ring-neutral-700 shadow-neutral-800 shadow-2xl rounded-xl p-3 ml-1 my-2 mr-3 flex flex-col justify-around">
    <div id="top" class="justify-self-center content-center items-center place-content-center">
      <img alt="Logo" src="riot-logo.svg"/>
      <div id="projectbrief">
        The friendly Operating System for the Internet of Things
      </div>
    </div>
    <div id="search" class="place-content-center" class="overflow-y-scroll max-h-64 bg-slate-400 ring-2 ring-white text-white" >
      <h1>Searchbar via Pagefind</h1>
      <!-- <div id="searchstub" class="flex items-center border border-gray-300 rounded-lg p-2 shadow-sm">
        <input type="text" placeholder="Search is only available in Production Build ..." class="flex-grow p-2 outline-none">
      </div> -->
    </div>
    <div id="navtree">
      <script>
        // The navtree variable is always a pair of two elements (key, value)
        // The key is the name we should display and the value is the link to the page
        // Generate the navtree from the navtreedata.js file and put it under the navtree div
        var navtree = NAVTREE[0][2];
        var navtreeHTML = "<h1>Navigation based on Doxygen</h1> <ul>";
        for (var i = 0; i < navtree.length; i++) {
          navtreeHTML += "<li><a href='" + navtree[i][1] + "'>" + navtree[i][0] + "</a></li>";
          if (i == 5) {
            navtreeHTML += '<li><h3 class="ring-2 ring-white"> Random Insert for Demonstration </h3></li>';
          }
        }
        navtreeHTML += "</ul>";
        document.getElementById("navtree").innerHTML = navtreeHTML;
      </script>
    </div>
    <ul>
      <li class="footer">
        Generated on Tue Sep 24 2024 11:16:27 by 
          <a href="http://www.doxygen.org/index.html">
            Doxygen
          </a> 
        1.12.0
      </li>
    </ul>
  </div>
  <!--Main Content-->
  <div class="hidden">
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',true);
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('group__se__key__management.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle"><div class="title">Secure Element Key Management<div class="ingroups"><a class="el" href="group__sys.html">System</a> &raquo; <a class="el" href="group__sys__psa__crypto.html">PSA Cryptographic API</a> &raquo; <a class="el" href="group__sys__psa__crypto__se__driver.html">PSA Crypto Secure Element Wrapper</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Currently, key management is limited to importing keys in the clear, destroying keys, and exporting keys in the clear. Whether a key may be exported is determined by the key policies in place on the key slot. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpsa__drv__se__key__management__t.html">psa_drv_se_key_management_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct containing all of the function pointers needed to for secure element key management.  <a href="structpsa__drv__se__key__management__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaab9a5d39285c68ac29264017e0119d98" id="r_gaab9a5d39285c68ac29264017e0119d98"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="psa__crypto_2psa_2error_8h.html#a05676e70ba5c6a7565aff3c36677c1f9">psa_status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaab9a5d39285c68ac29264017e0119d98">psa_drv_se_allocate_key_t</a>) (<a class="el" href="structpsa__drv__se__context__t.html">psa_drv_se_context_t</a> *drv_context, void *persistent_data, const <a class="el" href="crypto__types_8h.html#a0ec645e1fdafe59d591104451ebf5680">psa_key_attributes_t</a> *attributes, <a class="el" href="#ga984d5535962320e0c4692bb4ede486ef">psa_key_creation_method_t</a> method, <a class="el" href="group__se__init.html#ga90828ba6e282dd39260c81af68532e1d">psa_key_slot_number_t</a> *key_slot)</td></tr>
<tr class="memdesc:gaab9a5d39285c68ac29264017e0119d98"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function that allocates a slot for a key.  <br /></td></tr>
<tr class="separator:gaab9a5d39285c68ac29264017e0119d98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26c4b96c6d68dbd74b0512475d29f934" id="r_ga26c4b96c6d68dbd74b0512475d29f934"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="psa__crypto_2psa_2error_8h.html#a05676e70ba5c6a7565aff3c36677c1f9">psa_status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga26c4b96c6d68dbd74b0512475d29f934">psa_drv_se_validate_slot_number_t</a>) (<a class="el" href="structpsa__drv__se__context__t.html">psa_drv_se_context_t</a> *drv_context, void *persistent_data, const <a class="el" href="crypto__types_8h.html#a0ec645e1fdafe59d591104451ebf5680">psa_key_attributes_t</a> *attributes, <a class="el" href="#ga984d5535962320e0c4692bb4ede486ef">psa_key_creation_method_t</a> method, <a class="el" href="group__se__init.html#ga90828ba6e282dd39260c81af68532e1d">psa_key_slot_number_t</a> key_slot)</td></tr>
<tr class="memdesc:ga26c4b96c6d68dbd74b0512475d29f934"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function that determines whether a slot number is valid for a key.  <br /></td></tr>
<tr class="separator:ga26c4b96c6d68dbd74b0512475d29f934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e04e71aff4837259e54598708edcf7d" id="r_ga9e04e71aff4837259e54598708edcf7d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="psa__crypto_2psa_2error_8h.html#a05676e70ba5c6a7565aff3c36677c1f9">psa_status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9e04e71aff4837259e54598708edcf7d">psa_drv_se_import_key_t</a>) (<a class="el" href="structpsa__drv__se__context__t.html">psa_drv_se_context_t</a> *drv_context, <a class="el" href="group__se__init.html#ga90828ba6e282dd39260c81af68532e1d">psa_key_slot_number_t</a> key_slot, const <a class="el" href="crypto__types_8h.html#a0ec645e1fdafe59d591104451ebf5680">psa_key_attributes_t</a> *attributes, const uint8_t *data, size_t data_length, size_t *bits)</td></tr>
<tr class="memdesc:ga9e04e71aff4837259e54598708edcf7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function that imports a key into a secure element in binary format.  <br /></td></tr>
<tr class="separator:ga9e04e71aff4837259e54598708edcf7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf8c22c4a5b87035fcb594858d68e1ba" id="r_gaaf8c22c4a5b87035fcb594858d68e1ba"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="psa__crypto_2psa_2error_8h.html#a05676e70ba5c6a7565aff3c36677c1f9">psa_status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaaf8c22c4a5b87035fcb594858d68e1ba">psa_drv_se_destroy_key_t</a>) (<a class="el" href="structpsa__drv__se__context__t.html">psa_drv_se_context_t</a> *drv_context, void *persistent_data, <a class="el" href="group__se__init.html#ga90828ba6e282dd39260c81af68532e1d">psa_key_slot_number_t</a> key_slot)</td></tr>
<tr class="memdesc:gaaf8c22c4a5b87035fcb594858d68e1ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function that destroys a secure element key and restore the slot to its default state.  <br /></td></tr>
<tr class="separator:gaaf8c22c4a5b87035fcb594858d68e1ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9779816d17fa8ab42345b7c297dc843" id="r_gab9779816d17fa8ab42345b7c297dc843"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="psa__crypto_2psa_2error_8h.html#a05676e70ba5c6a7565aff3c36677c1f9">psa_status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab9779816d17fa8ab42345b7c297dc843">psa_drv_se_export_key_t</a>) (<a class="el" href="structpsa__drv__se__context__t.html">psa_drv_se_context_t</a> *drv_context, <a class="el" href="group__se__init.html#ga90828ba6e282dd39260c81af68532e1d">psa_key_slot_number_t</a> key_slot, uint8_t *p_data, size_t data_size, size_t *p_data_length)</td></tr>
<tr class="memdesc:gab9779816d17fa8ab42345b7c297dc843"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function that exports a secure element key in binary format.  <br /></td></tr>
<tr class="separator:gab9779816d17fa8ab42345b7c297dc843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62df4bbc6b63ab5ef8183012b12a6cf8" id="r_ga62df4bbc6b63ab5ef8183012b12a6cf8"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="psa__crypto_2psa_2error_8h.html#a05676e70ba5c6a7565aff3c36677c1f9">psa_status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga62df4bbc6b63ab5ef8183012b12a6cf8">psa_drv_se_generate_key_t</a>) (<a class="el" href="structpsa__drv__se__context__t.html">psa_drv_se_context_t</a> *drv_context, <a class="el" href="group__se__init.html#ga90828ba6e282dd39260c81af68532e1d">psa_key_slot_number_t</a> key_slot, const <a class="el" href="crypto__types_8h.html#a0ec645e1fdafe59d591104451ebf5680">psa_key_attributes_t</a> *attributes, uint8_t *pubkey, size_t pubkey_size, size_t *pubkey_length)</td></tr>
<tr class="memdesc:ga62df4bbc6b63ab5ef8183012b12a6cf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function that generates a symmetric or asymmetric key on a secure element.  <br /></td></tr>
<tr class="separator:ga62df4bbc6b63ab5ef8183012b12a6cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga984d5535962320e0c4692bb4ede486ef" id="r_ga984d5535962320e0c4692bb4ede486ef"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga984d5535962320e0c4692bb4ede486ef">psa_key_creation_method_t</a> { <a class="el" href="#gga984d5535962320e0c4692bb4ede486efa9d61c409158f958b864b759662adbbed">PSA_KEY_CREATION_IMPORT</a>
, <a class="el" href="#gga984d5535962320e0c4692bb4ede486efab197db75a74e331a570562ba3b3e04a9">PSA_KEY_CREATION_GENERATE</a>
, <a class="el" href="#gga984d5535962320e0c4692bb4ede486efaae615ce8bde386039d1ee1b348f6552c">PSA_KEY_CREATION_DERIVE</a>
, <a class="el" href="#gga984d5535962320e0c4692bb4ede486efa61d76b2af65ab3fb904b5eedd8f46363">PSA_KEY_CREATION_COPY</a>
 }</td></tr>
<tr class="memdesc:ga984d5535962320e0c4692bb4ede486ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">An enumeration indicating how a key is created.  <a href="#ga984d5535962320e0c4692bb4ede486ef">More...</a><br /></td></tr>
<tr class="separator:ga984d5535962320e0c4692bb4ede486ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gaab9a5d39285c68ac29264017e0119d98" name="gaab9a5d39285c68ac29264017e0119d98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab9a5d39285c68ac29264017e0119d98">&#9670;&#160;</a></span>psa_drv_se_allocate_key_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="psa__crypto_2psa_2error_8h.html#a05676e70ba5c6a7565aff3c36677c1f9">psa_status_t</a>(* psa_drv_se_allocate_key_t) (<a class="el" href="structpsa__drv__se__context__t.html">psa_drv_se_context_t</a> *drv_context, void *persistent_data, const <a class="el" href="crypto__types_8h.html#a0ec645e1fdafe59d591104451ebf5680">psa_key_attributes_t</a> *attributes, <a class="el" href="#ga984d5535962320e0c4692bb4ede486ef">psa_key_creation_method_t</a> method, <a class="el" href="group__se__init.html#ga90828ba6e282dd39260c81af68532e1d">psa_key_slot_number_t</a> *key_slot)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function that allocates a slot for a key. </p>
<p>To create a key in a specific slot in a secure element, the core first calls this function to determine a valid slot number, then calls a function to create the key material in that slot. In nominal conditions (that is, if no error occurs), the effect of a call to a key creation function in the PSA Cryptography API with a lifetime that places the key in a secure element is the following:</p><ol type="1">
<li>The core calls <a class="el" href="structpsa__drv__se__key__management__t.html#ada92ba1ee99afb1e8ac719e2feeee4cc">psa_drv_se_key_management_t::p_allocate</a> (or in some implementations <a class="el" href="structpsa__drv__se__key__management__t.html#a45c3a420a662f4bf67b4eaed5038fb34">psa_drv_se_key_management_t::p_validate_slot_number</a>). The driver selects (or validates) a suitable slot number given the key attributes and the state of the secure element.</li>
<li>The core calls a key creation function in the driver.</li>
</ol>
<p>The key creation functions in the PSA Cryptography API are:</p><ul>
<li><a class="el" href="crypto_8h.html#ad088d8ebc854d2f7a5b5c1769bc9ed40">psa_import_key()</a>, which causes a call to <code>p_allocate</code> with <code>method</code> = <a class="el" href="#gga984d5535962320e0c4692bb4ede486efa9d61c409158f958b864b759662adbbed">PSA_KEY_CREATION_IMPORT</a> then a call to <a class="el" href="structpsa__drv__se__key__management__t.html#a6764bfd7ca6d9822b2a98c0830a722de">psa_drv_se_key_management_t::p_import</a>.</li>
<li><a class="el" href="crypto_8h.html#a950b4199ae7a0164006bd3d6927d1efe">psa_generate_key()</a>, which causes a call to <code>p_allocate</code> with <code>method</code> = <a class="el" href="#gga984d5535962320e0c4692bb4ede486efab197db75a74e331a570562ba3b3e04a9">PSA_KEY_CREATION_GENERATE</a> then a call to <a class="el" href="structpsa__drv__se__key__management__t.html#a6764bfd7ca6d9822b2a98c0830a722de">psa_drv_se_key_management_t::p_import</a>.</li>
<li><a class="el" href="crypto_8h.html#ad286b675f3f8b46fa6cab620de6bead3">psa_key_derivation_output_key()</a>, which causes a call to <code>p_allocate</code> with <code>method</code> = <a class="el" href="#gga984d5535962320e0c4692bb4ede486efaae615ce8bde386039d1ee1b348f6552c">PSA_KEY_CREATION_DERIVE</a> then a call to <a class="el" href="structpsa__drv__se__key__derivation__t.html#a81357f9add831e2866698c2c05deffef">psa_drv_se_key_derivation_t::p_derive</a>.</li>
<li><a class="el" href="crypto_8h.html#a78da90274bd8f8680017a4bb513803a1">psa_copy_key()</a>, which causes a call to <code>p_allocate</code> with <code>method</code> = <a class="el" href="#gga984d5535962320e0c4692bb4ede486efa61d76b2af65ab3fb904b5eedd8f46363">PSA_KEY_CREATION_COPY</a> then a call to <a class="el" href="structpsa__drv__se__key__management__t.html#a28d37267c379b03e48fa4a3134d7c71b">psa_drv_se_key_management_t::p_export</a>.</li>
</ul>
<p>In case of errors, other behaviors are possible.</p><ul>
<li>If the PSA Cryptography subsystem dies after the first step, for example because the device has lost power abruptly, the second step may never happen, or may happen after a reset and re-initialization. Alternatively, after a reset and re-initialization, the core may call <a class="el" href="structpsa__drv__se__key__management__t.html#ab5bfb924e670c3aa65093a27ede91780">psa_drv_se_key_management_t::p_destroy</a> on the slot number that was allocated (or validated) instead of calling a key creation function.</li>
<li>If an error occurs, the core may call <a class="el" href="structpsa__drv__se__key__management__t.html#ab5bfb924e670c3aa65093a27ede91780">psa_drv_se_key_management_t::p_destroy</a> on the slot number that was allocated (or validated) instead of calling a key creation function.</li>
</ul>
<p>Errors and system resets also have an impact on the driver's persistent data. If a reset happens before the overall key creation process is completed (before or after the second step above), it is unspecified whether the persistent data after the reset is identical to what it was before or after the call to <code>p_allocate</code> (or <code>p_validate_slot_number</code>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">drv_context</td><td>The driver context structure. </td></tr>
    <tr><td class="paramname">persistent_data</td><td>A pointer to the persistent data that allows writing. </td></tr>
    <tr><td class="paramname">attributes</td><td>Attributes of the key. </td></tr>
    <tr><td class="paramname">method</td><td>The way in which the key is being created. </td></tr>
    <tr><td class="paramname">key_slot</td><td>Slot where the key will be stored. This must be a valid slot for a key of the chosen type. It must be unoccupied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="psa__crypto_2psa_2error_8h.html#a4cc859e2c66ca381c7418db3527a65e1">PSA_SUCCESS</a> Success. The core will record <code>*key_slot</code> as the key slot where the key is stored and will update the persistent data in storage. <a class="el" href="psa__crypto_2psa_2error_8h.html#a1dcc6d130633ed5db8942257581b55dd">PSA_ERROR_NOT_SUPPORTED</a> <a class="el" href="psa__crypto_2psa_2error_8h.html#a897a45eb206a6f6b7be7ffbe36f0d766">PSA_ERROR_INSUFFICIENT_STORAGE</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="psa__crypto__se__driver_8h_source.html#l00897">897</a> of file <a class="el" href="psa__crypto__se__driver_8h_source.html">psa_crypto_se_driver.h</a>.</p>

</div>
</div>
<a id="gaaf8c22c4a5b87035fcb594858d68e1ba" name="gaaf8c22c4a5b87035fcb594858d68e1ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf8c22c4a5b87035fcb594858d68e1ba">&#9670;&#160;</a></span>psa_drv_se_destroy_key_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="psa__crypto_2psa_2error_8h.html#a05676e70ba5c6a7565aff3c36677c1f9">psa_status_t</a>(* psa_drv_se_destroy_key_t) (<a class="el" href="structpsa__drv__se__context__t.html">psa_drv_se_context_t</a> *drv_context, void *persistent_data, <a class="el" href="group__se__init.html#ga90828ba6e282dd39260c81af68532e1d">psa_key_slot_number_t</a> key_slot)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function that destroys a secure element key and restore the slot to its default state. </p>
<p>This function destroys the content of the key from a secure element. Implementations shall make a best effort to ensure that any previous content of the slot is unrecoverable.</p>
<p>This function returns the specified slot to its default state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">drv_context</td><td>The driver context structure. </td></tr>
    <tr><td class="paramname">persistent_data</td><td>A pointer to the persistent data that allows writing. </td></tr>
    <tr><td class="paramname">key_slot</td><td>The key slot to erase.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="psa__crypto_2psa_2error_8h.html#a4cc859e2c66ca381c7418db3527a65e1">PSA_SUCCESS</a> The slot's content, if any, has been erased. </dd></dl>

<p class="definition">Definition at line <a class="el" href="psa__crypto__se__driver_8h_source.html#l00997">997</a> of file <a class="el" href="psa__crypto__se__driver_8h_source.html">psa_crypto_se_driver.h</a>.</p>

</div>
</div>
<a id="gab9779816d17fa8ab42345b7c297dc843" name="gab9779816d17fa8ab42345b7c297dc843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9779816d17fa8ab42345b7c297dc843">&#9670;&#160;</a></span>psa_drv_se_export_key_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="psa__crypto_2psa_2error_8h.html#a05676e70ba5c6a7565aff3c36677c1f9">psa_status_t</a>(* psa_drv_se_export_key_t) (<a class="el" href="structpsa__drv__se__context__t.html">psa_drv_se_context_t</a> *drv_context, <a class="el" href="group__se__init.html#ga90828ba6e282dd39260c81af68532e1d">psa_key_slot_number_t</a> key_slot, uint8_t *p_data, size_t data_size, size_t *p_data_length)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function that exports a secure element key in binary format. </p>
<p>The output of this function can be passed to <a class="el" href="crypto_8h.html#ad088d8ebc854d2f7a5b5c1769bc9ed40">psa_import_key()</a> to create an equivalent object.</p>
<p>If a key is created with <a class="el" href="crypto_8h.html#ad088d8ebc854d2f7a5b5c1769bc9ed40">psa_import_key()</a> and then exported with this function, it is not guaranteed that the resulting data is identical: the implementation may choose a different representation of the same key if the format permits it.</p>
<p>This function should generate output in the same format that <a class="el" href="crypto_8h.html#a5f2f7c851186c5d1d928be0b6020225c">psa_export_key()</a> does. Refer to the documentation of <a class="el" href="crypto_8h.html#a5f2f7c851186c5d1d928be0b6020225c">psa_export_key()</a> for the format for each key type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">drv_context</td><td>The driver context structure. </td></tr>
    <tr><td class="paramname">key_slot</td><td>Slot whose content is to be exported. This must be an occupied key slot. </td></tr>
    <tr><td class="paramname">p_data</td><td>Buffer where the key data is to be written. </td></tr>
    <tr><td class="paramname">data_size</td><td>Size of the <code>p_data</code> buffer in bytes. </td></tr>
    <tr><td class="paramname">p_data_length</td><td>On success, the number of bytes that make up the key data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="psa__crypto_2psa_2error_8h.html#a4cc859e2c66ca381c7418db3527a65e1">PSA_SUCCESS</a> <a class="el" href="psa__crypto_2psa_2error_8h.html#a18646babb2ae6cbde02ea3828bbd9141">PSA_ERROR_DOES_NOT_EXIST</a> <a class="el" href="psa__crypto_2psa_2error_8h.html#a4d1b8dd8526177a15a210b7afc1accb1">PSA_ERROR_NOT_PERMITTED</a> <a class="el" href="psa__crypto_2psa_2error_8h.html#a1dcc6d130633ed5db8942257581b55dd">PSA_ERROR_NOT_SUPPORTED</a> <a class="el" href="psa__crypto_2psa_2error_8h.html#a5cdb6948371d49e916106249020ea3f7">PSA_ERROR_COMMUNICATION_FAILURE</a> <a class="el" href="psa__crypto_2psa_2error_8h.html#a08b10e70fa5ff0b05c631d9f8f6b2c6b">PSA_ERROR_HARDWARE_FAILURE</a> <a class="el" href="psa__crypto_2psa_2error_8h.html#a116f4d4c6a9d9db3397991a8472d8950">PSA_ERROR_CORRUPTION_DETECTED</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="psa__crypto__se__driver_8h_source.html#l01030">1030</a> of file <a class="el" href="psa__crypto__se__driver_8h_source.html">psa_crypto_se_driver.h</a>.</p>

</div>
</div>
<a id="ga62df4bbc6b63ab5ef8183012b12a6cf8" name="ga62df4bbc6b63ab5ef8183012b12a6cf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga62df4bbc6b63ab5ef8183012b12a6cf8">&#9670;&#160;</a></span>psa_drv_se_generate_key_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="psa__crypto_2psa_2error_8h.html#a05676e70ba5c6a7565aff3c36677c1f9">psa_status_t</a>(* psa_drv_se_generate_key_t) (<a class="el" href="structpsa__drv__se__context__t.html">psa_drv_se_context_t</a> *drv_context, <a class="el" href="group__se__init.html#ga90828ba6e282dd39260c81af68532e1d">psa_key_slot_number_t</a> key_slot, const <a class="el" href="crypto__types_8h.html#a0ec645e1fdafe59d591104451ebf5680">psa_key_attributes_t</a> *attributes, uint8_t *pubkey, size_t pubkey_size, size_t *pubkey_length)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function that generates a symmetric or asymmetric key on a secure element. </p>
<p>If the key type <code>type</code> recorded in <code>attributes</code> is asymmetric (<a class="el" href="crypto__values_8h.html#ab138ae2ebf2905dfbaf4154db2620939">PSA_KEY_TYPE_IS_ASYMMETRIC</a>(<code>type</code>) = 1), the driver may export the public key at the time of generation, in the format documented for <a class="el" href="crypto_8h.html#a76970efac4f9418a03bf59dc345eaf88">psa_export_public_key()</a> by writing it to the <code>pubkey</code> buffer. This is optional, intended for secure elements that output the public key at generation time and that cannot export the public key later. Drivers that do not need this feature should leave <code>*pubkey_length</code> set to 0 and should implement the <code>p_export_public</code> function. Some implementations do not support this feature, in which case <code>pubkey</code> is <code>NULL</code> and <code>pubkey_size</code> is 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">drv_context</td><td>The driver context structure. </td></tr>
    <tr><td class="paramname">key_slot</td><td>Slot where the key will be stored. This must be a valid slot for a key of the chosen type. It must be unoccupied. </td></tr>
    <tr><td class="paramname">attributes</td><td>The key attributes, including the lifetime, the key type and size, and the usage policy. Drivers can call <a class="el" href="crypto_8h.html#a9ea8eae1b81e480cc56dec858859aff9">psa_get_key_lifetime()</a>, <a class="el" href="crypto_8h.html#ae4fb812af4f57aa1ad85e335a865b918">psa_get_key_type()</a>, <a class="el" href="crypto_8h.html#a5bee85c2164ad3d4c0d42501241eeb06">psa_get_key_bits()</a>, <a class="el" href="crypto_8h.html#aa1af20f142ca722222c6d98678a0c448">psa_get_key_usage_flags()</a> and <a class="el" href="crypto_8h.html#ac255da850a00bbed925390044f016b34">psa_get_key_algorithm()</a> to access this information. </td></tr>
    <tr><td class="paramname">pubkey</td><td>A buffer where the driver can write the public key, when generating an asymmetric key pair. This is <code>NULL</code> when generating a symmetric key or if the core does not support exporting the public key at generation time. </td></tr>
    <tr><td class="paramname">pubkey_size</td><td>The size of the <code>pubkey</code> buffer in bytes. This is 0 when generating a symmetric key or if the core does not support exporting the public key at generation time. </td></tr>
    <tr><td class="paramname">pubkey_length</td><td>On entry, this is always 0. On success, the number of bytes written to <code>pubkey</code>. If this is 0 or unchanged on return, the core will not read the <code>pubkey</code> buffer, and will instead call the driver's <code>p_export_public</code> function to export the public key when needed. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="psa__crypto__se__driver_8h_source.html#l01070">1070</a> of file <a class="el" href="psa__crypto__se__driver_8h_source.html">psa_crypto_se_driver.h</a>.</p>

</div>
</div>
<a id="ga9e04e71aff4837259e54598708edcf7d" name="ga9e04e71aff4837259e54598708edcf7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e04e71aff4837259e54598708edcf7d">&#9670;&#160;</a></span>psa_drv_se_import_key_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="psa__crypto_2psa_2error_8h.html#a05676e70ba5c6a7565aff3c36677c1f9">psa_status_t</a>(* psa_drv_se_import_key_t) (<a class="el" href="structpsa__drv__se__context__t.html">psa_drv_se_context_t</a> *drv_context, <a class="el" href="group__se__init.html#ga90828ba6e282dd39260c81af68532e1d">psa_key_slot_number_t</a> key_slot, const <a class="el" href="crypto__types_8h.html#a0ec645e1fdafe59d591104451ebf5680">psa_key_attributes_t</a> *attributes, const uint8_t *data, size_t data_length, size_t *bits)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function that imports a key into a secure element in binary format. </p>
<p>This function can support any output from <a class="el" href="crypto_8h.html#a5f2f7c851186c5d1d928be0b6020225c">psa_export_key()</a>. Refer to the documentation of <a class="el" href="crypto_8h.html#a5f2f7c851186c5d1d928be0b6020225c">psa_export_key()</a> for the format for each key type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">drv_context</td><td>The driver context structure. </td></tr>
    <tr><td class="paramname">key_slot</td><td>Slot where the key will be stored. This must be a valid slot for a key of the chosen type. It must be unoccupied. </td></tr>
    <tr><td class="paramname">attributes</td><td>The key attributes, including the lifetime, the key type and the usage policy. Drivers should not access the key size stored in the attributes: it may not match the data passed in <code>data</code>. Drivers can call <a class="el" href="crypto_8h.html#a9ea8eae1b81e480cc56dec858859aff9">psa_get_key_lifetime()</a>, <a class="el" href="crypto_8h.html#ae4fb812af4f57aa1ad85e335a865b918">psa_get_key_type()</a>, <a class="el" href="crypto_8h.html#aa1af20f142ca722222c6d98678a0c448">psa_get_key_usage_flags()</a> and <a class="el" href="crypto_8h.html#ac255da850a00bbed925390044f016b34">psa_get_key_algorithm()</a> to access this information. </td></tr>
    <tr><td class="paramname">data</td><td>Buffer containing the key data. </td></tr>
    <tr><td class="paramname">data_length</td><td>Size of the <code>data</code> buffer in bytes. </td></tr>
    <tr><td class="paramname">bits</td><td>On success, the key size in bits. The driver must determine this value after parsing the key according to the key type. This value is not used if the function fails.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="psa__crypto_2psa_2error_8h.html#a4cc859e2c66ca381c7418db3527a65e1">PSA_SUCCESS</a> Success. </dd></dl>

<p class="definition">Definition at line <a class="el" href="psa__crypto__se__driver_8h_source.html#l00973">973</a> of file <a class="el" href="psa__crypto__se__driver_8h_source.html">psa_crypto_se_driver.h</a>.</p>

</div>
</div>
<a id="ga26c4b96c6d68dbd74b0512475d29f934" name="ga26c4b96c6d68dbd74b0512475d29f934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26c4b96c6d68dbd74b0512475d29f934">&#9670;&#160;</a></span>psa_drv_se_validate_slot_number_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="psa__crypto_2psa_2error_8h.html#a05676e70ba5c6a7565aff3c36677c1f9">psa_status_t</a>(* psa_drv_se_validate_slot_number_t) (<a class="el" href="structpsa__drv__se__context__t.html">psa_drv_se_context_t</a> *drv_context, void *persistent_data, const <a class="el" href="crypto__types_8h.html#a0ec645e1fdafe59d591104451ebf5680">psa_key_attributes_t</a> *attributes, <a class="el" href="#ga984d5535962320e0c4692bb4ede486ef">psa_key_creation_method_t</a> method, <a class="el" href="group__se__init.html#ga90828ba6e282dd39260c81af68532e1d">psa_key_slot_number_t</a> key_slot)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function that determines whether a slot number is valid for a key. </p>
<p>To create a key in a specific slot in a secure element, the core first calls this function to validate the choice of slot number, then calls a function to create the key material in that slot. See the documentation of <a class="el" href="#gaab9a5d39285c68ac29264017e0119d98">psa_drv_se_allocate_key_t</a> for more details.</p>
<p>As of the PSA Cryptography API specification version 1.0, there is no way for applications to trigger a call to this function. However some implementations offer the capability to create or declare a key in a specific slot via implementation-specific means, generally for the sake of initial device provisioning or onboarding. Such a mechanism may be added to a future version of the PSA Cryptography API specification.</p>
<p>This function may update the driver's persistent data through <code>persistent_data</code>. The core will save the updated persistent data at the end of the key creation process. See the description of <a class="el" href="#gaab9a5d39285c68ac29264017e0119d98">psa_drv_se_allocate_key_t</a> for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">drv_context</td><td>The driver context structure. </td></tr>
    <tr><td class="paramname">persistent_data</td><td>A pointer to the persistent data that allows writing. </td></tr>
    <tr><td class="paramname">attributes</td><td>Attributes of the key. </td></tr>
    <tr><td class="paramname">method</td><td>The way in which the key is being created. </td></tr>
    <tr><td class="paramname">key_slot</td><td>Slot where the key is to be stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="psa__crypto_2psa_2error_8h.html#a4cc859e2c66ca381c7418db3527a65e1">PSA_SUCCESS</a> The given slot number is valid for a key with the given attributes. <a class="el" href="psa__crypto_2psa_2error_8h.html#a798df25a505ebf931f7bec1f80f1f85f">PSA_ERROR_INVALID_ARGUMENT</a> The given slot number is not valid for a key with the given attributes. This includes the case where the slot number is not valid at all. <a class="el" href="psa__crypto_2psa_2error_8h.html#af2b34cc87edc72f3ba90071a08210d20">PSA_ERROR_ALREADY_EXISTS</a> There is already a key with the specified slot number. Drivers may choose to return this error from the key creation function instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="psa__crypto__se__driver_8h_source.html#l00939">939</a> of file <a class="el" href="psa__crypto__se__driver_8h_source.html">psa_crypto_se_driver.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga984d5535962320e0c4692bb4ede486ef" name="ga984d5535962320e0c4692bb4ede486ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga984d5535962320e0c4692bb4ede486ef">&#9670;&#160;</a></span>psa_key_creation_method_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ga984d5535962320e0c4692bb4ede486ef">psa_key_creation_method_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An enumeration indicating how a key is created. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga984d5535962320e0c4692bb4ede486efa9d61c409158f958b864b759662adbbed" name="gga984d5535962320e0c4692bb4ede486efa9d61c409158f958b864b759662adbbed"></a>PSA_KEY_CREATION_IMPORT&#160;</td><td class="fielddoc"><p>During <a class="el" href="crypto_8h.html#ad088d8ebc854d2f7a5b5c1769bc9ed40">psa_import_key()</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="gga984d5535962320e0c4692bb4ede486efab197db75a74e331a570562ba3b3e04a9" name="gga984d5535962320e0c4692bb4ede486efab197db75a74e331a570562ba3b3e04a9"></a>PSA_KEY_CREATION_GENERATE&#160;</td><td class="fielddoc"><p>During <a class="el" href="crypto_8h.html#a950b4199ae7a0164006bd3d6927d1efe">psa_generate_key()</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="gga984d5535962320e0c4692bb4ede486efaae615ce8bde386039d1ee1b348f6552c" name="gga984d5535962320e0c4692bb4ede486efaae615ce8bde386039d1ee1b348f6552c"></a>PSA_KEY_CREATION_DERIVE&#160;</td><td class="fielddoc"><p>During <a class="el" href="crypto_8h.html#ad286b675f3f8b46fa6cab620de6bead3">psa_key_derivation_output_key()</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="gga984d5535962320e0c4692bb4ede486efa61d76b2af65ab3fb904b5eedd8f46363" name="gga984d5535962320e0c4692bb4ede486efa61d76b2af65ab3fb904b5eedd8f46363"></a>PSA_KEY_CREATION_COPY&#160;</td><td class="fielddoc"><p>During <a class="el" href="crypto_8h.html#a78da90274bd8f8680017a4bb513803a1">psa_copy_key()</a> </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="psa__crypto__se__driver_8h_source.html#l00831">831</a> of file <a class="el" href="psa__crypto__se__driver_8h_source.html">psa_crypto_se_driver.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->

    </div>
  </body>
</html>
