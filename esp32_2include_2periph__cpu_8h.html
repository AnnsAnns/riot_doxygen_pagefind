<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RIOT OS: cpu/esp32/include/periph_cpu.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<!-- <script type="text/javascript" src="jquery.js"></script> -->
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<!-- <link href="/pagefind/pagefind-ui.css" rel="stylesheet"> -->
<script src="/pagefind/pagefind-ui.js"></script>
<script>
  // Check whether the PagefindUI class is available
  if (typeof PagefindUI === 'undefined') {
    console.error('PagefindUI class is not available | Dev Build');
  } else {
    // // Remove the "searchstub" element and initialize the PagefindUI class
    // document.getElementById("#searchstub").remove();
    // Initialize the PagefindUI class with the element id "search"
    window.addEventListener('DOMContentLoaded', (event) => {
        new PagefindUI({ element: "#search", showSubResults: true });
    });
  }
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="global.css" rel="stylesheet" type="text/css" />
</head>
<body>
  <script>
    // Print the data within the NAVTREE variable from the navtreedata.js file
    var navtree = NAVTREE;
    console.log(navtree);
  </script>
<div class="flex flex-row gap-4 w-screen font-sans text-lg max-h-screen overscroll-contain justify-items-stretch bg-neutral-900">
  <!--Sidebar-->
  <div data-pagefind-ignore="all" class="w-1/3 max-w-md flex-auto h-screen bg-neutral-800 ring-2 ring-neutral-700 shadow-neutral-800 shadow-2xl rounded-xl p-3 ml-1 my-2 mr-3 flex flex-col justify-around">
    <div id="top" class="justify-self-center content-center items-center place-content-center">
      <img alt="Logo" src="riot-logo.svg"/>
      <div id="projectbrief">
        The friendly Operating System for the Internet of Things
      </div>
    </div>
    <div id="search" class="place-content-center" class="overflow-y-scroll max-h-64 bg-slate-400 ring-2 ring-white text-white" >
      <h1>Searchbar via Pagefind</h1>
      <!-- <div id="searchstub" class="flex items-center border border-gray-300 rounded-lg p-2 shadow-sm">
        <input type="text" placeholder="Search is only available in Production Build ..." class="flex-grow p-2 outline-none">
      </div> -->
    </div>
    <div id="navtree">
      <script>
        // The navtree variable is always a pair of two elements (key, value)
        // The key is the name we should display and the value is the link to the page
        // Generate the navtree from the navtreedata.js file and put it under the navtree div
        var navtree = NAVTREE[0][2];
        var navtreeHTML = "<h1>Navigation based on Doxygen</h1> <ul>";
        for (var i = 0; i < navtree.length; i++) {
          navtreeHTML += "<li><a href='" + navtree[i][1] + "'>" + navtree[i][0] + "</a></li>";
          if (i == 5) {
            navtreeHTML += '<li><h3 class="ring-2 ring-white"> Random Insert for Demonstration </h3></li>';
          }
        }
        navtreeHTML += "</ul>";
        document.getElementById("navtree").innerHTML = navtreeHTML;
      </script>
    </div>
    <ul>
      <li class="footer">
        Generated on Tue Sep 24 2024 11:16:25 by 
          <a href="http://www.doxygen.org/index.html">
            Doxygen
          </a> 
        1.12.0
      </li>
    </ul>
  </div>
  <!--Main Content-->
  <div class="hidden">
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',true);
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('esp32_2include_2periph__cpu_8h.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a>  </div>
  <div class="headertitle"><div class="title">periph_cpu.h File Reference<div class="ingroups"><a class="el" href="group__cpu.html">CPU</a> &raquo; <a class="el" href="group__cpu__esp32.html">ESP32 SoC Series</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Peripheral configuration that is common for all ESP32x SoCs.  
<a href="#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Peripheral configuration that is common for all ESP32x SoCs. </p>
<dl class="section author"><dt>Author</dt><dd>Gunar Schorcht <a href="#" onclick="location.href='mai'+'lto:'+'gun'+'ar'+'@sc'+'ho'+'rch'+'t.'+'net'; return false;">gunar<span class="obfuscator">.nosp@m.</span>@sch<span class="obfuscator">.nosp@m.</span>orcht<span class="obfuscator">.nosp@m.</span>.net</a> </dd></dl>

<p class="definition">Definition in file <a class="el" href="esp32_2include_2periph__cpu_8h_source.html">periph_cpu.h</a>.</p>
</div><div class="textblock"><code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &quot;<a class="el" href="cpu_2esp32_2include_2sdkconfig_8h_source.html">sdkconfig.h</a>&quot;</code><br />
<code>#include &quot;hal/ledc_types.h&quot;</code><br />
<code>#include &quot;hal/spi_types.h&quot;</code><br />
<code>#include &quot;soc/ledc_struct.h&quot;</code><br />
<code>#include &quot;soc/periph_defs.h&quot;</code><br />
<code>#include &quot;soc/soc_caps.h&quot;</code><br />
<code>#include &quot;<a class="el" href="usbdev__synopsys__dwc2_8h_source.html">usbdev_synopsys_dwc2.h</a>&quot;</code><br />
</div><div class="textblock"><div id="dynsection-0" onclick="return dynsection.toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Include dependency graph for periph_cpu.h:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="esp32_2include_2periph__cpu_8h__incl.svg" width="1168" height="207"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
<p><a href="esp32_2include_2periph__cpu_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="uniongpio__conf__esp32.html">gpio_conf_esp32</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPIO pin configuration for ESP32/ESP32Cx/ESP32Sx MCUs.  <a href="uniongpio__conf__esp32.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structi2c__conf__t.html">i2c_conf_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C configuration structure.  <a href="structi2c__conf__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpwm__config__t.html">pwm_config_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">PWM configuration structure type.  <a href="structpwm__config__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrmt__channel__config__t.html">rmt_channel_config_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">RMT channel configuration.  <a href="structrmt__channel__config__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsdmmc__conf__t.html">sdmmc_conf_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SDMMC slot configuration.  <a href="structsdmmc__conf__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspi__conf__t.html">spi_conf_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI device configuration.  <a href="structspi__conf__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structuart__conf__t.html">uart_conf_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART device configuration.  <a href="structuart__conf__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a1943715eaeaa63e28b7b4e207f655fca" id="r_a1943715eaeaa63e28b7b4e207f655fca"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1943715eaeaa63e28b7b4e207f655fca">CPUID_LEN</a>&#160;&#160;&#160;(6U)</td></tr>
<tr class="memdesc:a1943715eaeaa63e28b7b4e207f655fca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Length of the CPU_ID in octets.  <br /></td></tr>
<tr class="separator:a1943715eaeaa63e28b7b4e207f655fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd04a76b55e9fef358e904400cde4db7" id="r_afd04a76b55e9fef358e904400cde4db7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd04a76b55e9fef358e904400cde4db7">PERIPH_TIMER_PROVIDES_SET</a></td></tr>
<tr class="memdesc:afd04a76b55e9fef358e904400cde4db7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prevent shared timer functions from being used.  <br /></td></tr>
<tr class="separator:afd04a76b55e9fef358e904400cde4db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81935d479349dc2ce0a416bcb0e6beda" id="r_a81935d479349dc2ce0a416bcb0e6beda"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a81935d479349dc2ce0a416bcb0e6beda">STDIO_UART_DEV</a>&#160;&#160;&#160;CONFIG_ESP_CONSOLE_UART_NUM</td></tr>
<tr class="memdesc:a81935d479349dc2ce0a416bcb0e6beda"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART device used for STDIO.  <br /></td></tr>
<tr class="separator:a81935d479349dc2ce0a416bcb0e6beda"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Power management configuration</h2></td></tr>
<tr class="memitem:a04211208eb7863ce1c522440a91c745c" id="r_a04211208eb7863ce1c522440a91c745c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a04211208eb7863ce1c522440a91c745c">PROVIDES_PM_SET_LOWEST</a></td></tr>
<tr class="separator:a04211208eb7863ce1c522440a91c745c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb8775ffe47b6ea299c337d2de369e13" id="r_abb8775ffe47b6ea299c337d2de369e13"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb8775ffe47b6ea299c337d2de369e13">PROVIDES_PM_RESTART</a></td></tr>
<tr class="separator:abb8775ffe47b6ea299c337d2de369e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19d28a07b2898cf543c068c890ab7da0" id="r_a19d28a07b2898cf543c068c890ab7da0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19d28a07b2898cf543c068c890ab7da0">PROVIDES_PM_OFF</a></td></tr>
<tr class="separator:a19d28a07b2898cf543c068c890ab7da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c0ac9ba49fa45f1faab835edc15d5ed" id="r_a0c0ac9ba49fa45f1faab835edc15d5ed"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c0ac9ba49fa45f1faab835edc15d5ed">PROVIDES_PM_LAYERED_OFF</a></td></tr>
<tr class="separator:a0c0ac9ba49fa45f1faab835edc15d5ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d1931627629f3c43bd898da0be6075b" id="r_a3d1931627629f3c43bd898da0be6075b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d1931627629f3c43bd898da0be6075b">PM_NUM_MODES</a>&#160;&#160;&#160;(3U)</td></tr>
<tr class="memdesc:a3d1931627629f3c43bd898da0be6075b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of usable low power modes.  <br /></td></tr>
<tr class="separator:a3d1931627629f3c43bd898da0be6075b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Power modes</h2></td></tr>
<tr class="memitem:aa46086d6003b622e23e6123974d8dffc" id="r_aa46086d6003b622e23e6123974d8dffc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa46086d6003b622e23e6123974d8dffc">ESP_PM_MODEM_SLEEP</a>&#160;&#160;&#160;(2U)</td></tr>
<tr class="separator:aa46086d6003b622e23e6123974d8dffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2376d94f6767ae6e7602687fcff12c4" id="r_ae2376d94f6767ae6e7602687fcff12c4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2376d94f6767ae6e7602687fcff12c4">ESP_PM_LIGHT_SLEEP</a>&#160;&#160;&#160;(1U)</td></tr>
<tr class="separator:ae2376d94f6767ae6e7602687fcff12c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3553a08e62f0817da0df1c1683295a0" id="r_ae3553a08e62f0817da0df1c1683295a0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3553a08e62f0817da0df1c1683295a0">ESP_PM_DEEP_SLEEP</a>&#160;&#160;&#160;(0U)</td></tr>
<tr class="separator:ae3553a08e62f0817da0df1c1683295a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">GPIO configuration</h2></td></tr>
<tr class="memitem:a759f553fbddd2915b49e50c967661fb1" id="r_a759f553fbddd2915b49e50c967661fb1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a759f553fbddd2915b49e50c967661fb1">HAVE_GPIO_T</a></td></tr>
<tr class="memdesc:a759f553fbddd2915b49e50c967661fb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override the default gpio_t type definition.  <br /></td></tr>
<tr class="separator:a759f553fbddd2915b49e50c967661fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadacfc0deb08affff1e88f9549c8e2823" id="r_gadacfc0deb08affff1e88f9549c8e2823"><td class="memItemLeft" align="right" valign="top">typedef unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drivers__periph__gpio.html#gadacfc0deb08affff1e88f9549c8e2823">gpio_t</a></td></tr>
<tr class="memdesc:gadacfc0deb08affff1e88f9549c8e2823"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPIO type identifier.  <br /></td></tr>
<tr class="separator:gadacfc0deb08affff1e88f9549c8e2823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3969ce1e494a72d3c2925b10ddeb4604" id="r_a3969ce1e494a72d3c2925b10ddeb4604"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3969ce1e494a72d3c2925b10ddeb4604">GPIO_UNDEF</a>&#160;&#160;&#160;(0xffffffff)</td></tr>
<tr class="memdesc:a3969ce1e494a72d3c2925b10ddeb4604"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of a fitting UNDEF value.  <br /></td></tr>
<tr class="separator:a3969ce1e494a72d3c2925b10ddeb4604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae29846b3ecd19a0b7c44ff80a37ae7c1" id="r_ae29846b3ecd19a0b7c44ff80a37ae7c1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae29846b3ecd19a0b7c44ff80a37ae7c1">GPIO_PIN</a>(x,  y)</td></tr>
<tr class="memdesc:ae29846b3ecd19a0b7c44ff80a37ae7c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a CPU specific GPIO pin generator macro.  <br /></td></tr>
<tr class="separator:ae29846b3ecd19a0b7c44ff80a37ae7c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77546a5cc91deda999da3cb862fc3f98" id="r_a77546a5cc91deda999da3cb862fc3f98"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77546a5cc91deda999da3cb862fc3f98">PORT_GPIO</a>&#160;&#160;&#160;(0)</td></tr>
<tr class="memdesc:a77546a5cc91deda999da3cb862fc3f98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Available GPIO ports on ESP32.  <br /></td></tr>
<tr class="separator:a77546a5cc91deda999da3cb862fc3f98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a868f2d79bdced071714fb44a357c0018" id="r_a868f2d79bdced071714fb44a357c0018"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a868f2d79bdced071714fb44a357c0018">GPIO_PIN_NUMOF</a>&#160;&#160;&#160;(SOC_GPIO_PIN_COUNT)</td></tr>
<tr class="memdesc:a868f2d79bdced071714fb44a357c0018"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define CPU specific number of GPIO pins.  <br /></td></tr>
<tr class="separator:a868f2d79bdced071714fb44a357c0018"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">ADC configuration</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>ESP32x SoCs integrate two SAR ADCs (ADC1 and ADC2).</p>
<p>The bit width of the ADC devices, the number of channels per device and the GPIOs that can be used as ADC channels depend on the respective ESP32x SoC family. For details, see:</p>
<ul>
<li><a class="el" href="group__cpu__esp32__esp32.html#esp32_adc_channels_esp32">ESP32</a></li>
<li><a class="el" href="group__cpu__esp32__esp32c3.html#esp32_adc_channels_esp32c3">ESP32-C3</a></li>
<li><a class="el" href="group__cpu__esp32__esp32s3.html#esp32_adc_channels_esp32s3">ESP32-S3</a></li>
</ul>
<p><a class="el" href="esp32x_2include_2periph__conf__common_8h.html#ac93ef90877386721589730c2219fde48" title="Declaration of GPIOs that can be used as ADC channels.">ADC_GPIOS</a> in the board-specific peripheral configuration defines the list of GPIOs that can be used as ADC channels on the board, for example: </p><div class="fragment"><div class="line"><span class="preprocessor">#define ADC_GPIOS   { GPIO0, GPIO2, GPIO4 }</span></div>
</div><!-- fragment --><p>Thereby the order of the listed GPIOs determines the mapping between the ADC lines of the RIOT and the GPIOs. The maximum number of GPIOs in the list is <a class="el" href="#aea6c293fdfb3bbb0f41e759577366d6f" title="Number of ADC channels that could be used at maximum.">ADC_NUMOF_MAX</a>. The board specific configuration of <a class="el" href="esp32x_2include_2periph__conf__common_8h.html#ac93ef90877386721589730c2219fde48" title="Declaration of GPIOs that can be used as ADC channels.">ADC_GPIOS</a> can be overridden by [Application specific configurations] (#esp32_application_specific_configurations).</p>
<p>The number of defined ADC channels <a class="el" href="nrf52_2include_2periph__cpu_8h.html#a2f0c741db24aa2ccded869ba53f6a302" title="The nRF52 family of CPUs provides a fixed number of 9 ADC lines.">ADC_NUMOF</a> is determined automatically from the <a class="el" href="esp32x_2include_2periph__conf__common_8h.html#ac93ef90877386721589730c2219fde48" title="Declaration of GPIOs that can be used as ADC channels.">ADC_GPIOS</a> definition.</p>
<dl class="section note"><dt>Note</dt><dd>As long as the GPIOs listed in <a class="el" href="esp32x_2include_2periph__conf__common_8h.html#ac93ef90877386721589730c2219fde48" title="Declaration of GPIOs that can be used as ADC channels.">ADC_GPIOS</a> are not initialized as ADC channels with the <a class="el" href="group__drivers__periph__adc.html#ga259a7b0176a8a6f5a5e61aabce3574f0" title="Initialize the given ADC line.">adc_init</a> function, they can be used for other purposes.</dd></dl>
<p>With the function <a class="el" href="adc__arch_8h.html#a99ad2f6a0bdea91f7ca3102e5f67fb85" title="Set the attenuation for the ADC line.">adc_set_attenuation</a> an attenuation of the input signal can be defined separately for each ADC channel. </p><div class="fragment"><div class="line"><span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code hl_function" href="adc__arch_8h.html#a99ad2f6a0bdea91f7ca3102e5f67fb85">adc_set_attenuation</a>(<a class="code hl_typedef" href="group__drivers__periph__adc.html#ga77e0c958e3549fef6e4067b2ca678a0b">adc_t</a> line, <a class="code hl_enumeration" href="adc__arch_8h.html#aa71353583a04674cb8a03f8117e8ecd3">adc_attenuation_t</a> atten);</div>
<div class="ttc" id="aadc__arch_8h_html_a99ad2f6a0bdea91f7ca3102e5f67fb85"><div class="ttname"><a href="adc__arch_8h.html#a99ad2f6a0bdea91f7ca3102e5f67fb85">adc_set_attenuation</a></div><div class="ttdeci">int adc_set_attenuation(adc_t line, adc_atten_t atten)</div><div class="ttdoc">Set the attenuation for the ADC line.</div></div>
<div class="ttc" id="aadc__arch_8h_html_aa71353583a04674cb8a03f8117e8ecd3"><div class="ttname"><a href="adc__arch_8h.html#aa71353583a04674cb8a03f8117e8ecd3">adc_attenuation_t</a></div><div class="ttdeci">adc_attenuation_t</div><div class="ttdoc">Attenuations that can be set for ADC lines.</div><div class="ttdef"><b>Definition</b> <a href="adc__arch_8h_source.html#l00047">adc_arch.h:47</a></div></div>
<div class="ttc" id="agroup__drivers__periph__adc_html_ga77e0c958e3549fef6e4067b2ca678a0b"><div class="ttname"><a href="group__drivers__periph__adc.html#ga77e0c958e3549fef6e4067b2ca678a0b">adc_t</a></div><div class="ttdeci">uint_fast8_t adc_t</div><div class="ttdoc">Define default ADC type identifier.</div><div class="ttdef"><b>Definition</b> <a href="adc_8h_source.html#l00072">adc.h:72</a></div></div>
</div><!-- fragment --><p>This leads to different measurable maximum values for the voltage at the input. The higher the attenuation is, the higher the voltage measured at the input can be.</p>
<p>The attenuation can be set to 4 fixed values 0 dB, 2.5/3 dB, 6 dB and 11/12 dB, where 11 dB respectively 12 dB is the default attenuation.</p>
<center></center><center><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">Attenuation   </th><th class="markdownTableHeadNone">Voltage Range   </th><th class="markdownTableHeadNone">Symbol    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">0 dB   </td><td class="markdownTableBodyNone">0 ... 1.1V (Vref)   </td><td class="markdownTableBodyNone"><code>ADC_ATTEN_DB_0</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">2.5 / 3 dB   </td><td class="markdownTableBodyNone">0 ... 1.5V   </td><td class="markdownTableBodyNone"><code>ADC_ATTEN_DB_2_5</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">6 dB   </td><td class="markdownTableBodyNone">0 ... 2.2V   </td><td class="markdownTableBodyNone"><code>ADC_ATTEN_DB_6</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">11 / 12 dB   </td><td class="markdownTableBodyNone">0 ... 3.3V   </td><td class="markdownTableBodyNone"><code>ADC_ATTEN_DB_11</code> (default)   </td></tr>
</table>
</center><center> </center><p><br  />
</p>
<dl class="section note"><dt>Note</dt><dd>The reference voltage Vref can vary from device to device in the range of 1.0V and 1.2V.</dd></dl>
<p>The Vref of a device can be read at a predefined GPIO with the function <a class="el" href="adc__arch_8h.html#a1ebca9a3af2ed9a9416949f539ba56b4" title="Output reference voltage of a ADC line to GPIO n.">adc_line_vref_to_gpio</a>. The results of the ADC input can then be adjusted accordingly. </p><div class="fragment"><div class="line"><span class="keyword">extern</span> <span class="keywordtype">int</span> <a class="code hl_function" href="adc__arch_8h.html#a1ebca9a3af2ed9a9416949f539ba56b4">adc_line_vref_to_gpio</a>(<a class="code hl_typedef" href="group__drivers__periph__adc.html#ga77e0c958e3549fef6e4067b2ca678a0b">adc_t</a> line, <a class="code hl_typedef" href="group__drivers__periph__gpio.html#gadacfc0deb08affff1e88f9549c8e2823">gpio_t</a> gpio);</div>
<div class="ttc" id="aadc__arch_8h_html_a1ebca9a3af2ed9a9416949f539ba56b4"><div class="ttname"><a href="adc__arch_8h.html#a1ebca9a3af2ed9a9416949f539ba56b4">adc_line_vref_to_gpio</a></div><div class="ttdeci">int adc_line_vref_to_gpio(adc_t line, gpio_t gpio)</div><div class="ttdoc">Output reference voltage of a ADC line to GPIO n.</div></div>
<div class="ttc" id="agroup__drivers__periph__gpio_html_gadacfc0deb08affff1e88f9549c8e2823"><div class="ttname"><a href="group__drivers__periph__gpio.html#gadacfc0deb08affff1e88f9549c8e2823">gpio_t</a></div><div class="ttdeci">uint16_t gpio_t</div><div class="ttdoc">GPIO type identifier.</div><div class="ttdef"><b>Definition</b> <a href="atxmega_2include_2periph__cpu_8h_source.html#l00117">periph_cpu.h:117</a></div></div>
</div><!-- fragment --><p> For the GPIO that can be used with this function, see:</p>
<ul>
<li><a class="el" href="group__cpu__esp32__esp32.html#esp32_adc_channels_esp32">ESP32</a></li>
<li><a class="el" href="group__cpu__esp32__esp32c3.html#esp32_adc_channels_esp32c3">ESP32-C3</a></li>
<li><a class="el" href="group__cpu__esp32__esp32s3.html#esp32_adc_channels_esp32s3">ESP32-S3</a> </li>
</ul>
</td></tr>
<tr class="memitem:aea6c293fdfb3bbb0f41e759577366d6f" id="r_aea6c293fdfb3bbb0f41e759577366d6f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aea6c293fdfb3bbb0f41e759577366d6f">ADC_NUMOF_MAX</a>&#160;&#160;&#160;(SOC_ADC_CHANNEL_NUM(0) + SOC_ADC_CHANNEL_NUM(1))</td></tr>
<tr class="memdesc:aea6c293fdfb3bbb0f41e759577366d6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of ADC channels that could be used at maximum.  <br /></td></tr>
<tr class="separator:aea6c293fdfb3bbb0f41e759577366d6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">DAC configuration</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Some ESP32x SoCs support 2 DAC lines at predefined GPIOs, depending on the respective ESP32x SoC family.</p>
<p>These DACs have a width of 8 bits and produce voltages in the range from 0 V to 3.3 V (VDD_A). The 16 bit DAC values given as parameter of function <a class="el" href="group__drivers__periph__dac.html#ga179ae55de04d356cd6fbb63e9e3f51f6" title="Write a value onto DAC Device on a given Channel.">dac_set</a> are down-scaled to 8 bit.</p>
<p>The GPIOs that can be used as DAC channels for a given board are defined by the <code>#DAC_GPIOS</code> macro in the board-specific peripheral configuration. The specified GPIOs in the list must match the predefined GPIOs that can be used as DAC channels on the respective ESP32x SoC.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define DAC_GPIOS   { GPIO25, GPIO26 }</span></div>
</div><!-- fragment --><p>This configuration can be changed by [application-specific configurations] (#esp32_application_specific_configurations).</p>
<p>The order of the listed GPIOs determines the mapping between the RIOT's DAC lines and the GPIOs. The maximum number of GPIOs in the list is <a class="el" href="#afe6215885cf4c6bc1cbbbefdf19ccc80" title="Number of DAC channels that could be used at maximum.">DAC_NUMOF_MAX</a>.</p>
<p><a class="el" href="lpc23xx_2include_2periph__cpu_8h.html#a2d6ae6694d0a51952fb26d994de93d12" title="DAC configuration, valid for all boards using this CPU.">DAC_NUMOF</a> is determined automatically from the <a class="el" href="esp32x_2include_2periph__conf__common_8h.html#a377e83c8834eecbb7aa5f355da2ae9da" title="Declaration of GPIOs that can be used as DAC channels.">DAC_GPIOS</a> definition.</p>
<dl class="section note"><dt>Note</dt><dd>As long as the GPIOs listed in <a class="el" href="esp32x_2include_2periph__conf__common_8h.html#a377e83c8834eecbb7aa5f355da2ae9da" title="Declaration of GPIOs that can be used as DAC channels.">DAC_GPIOS</a> are not initialized as DAC channels with the <a class="el" href="group__drivers__periph__dac.html#gabc514d1757c59929f653c64085d3fd5d" title="Initialize the given DAC line.">dac_init</a> function, they can be used for other purposes.</dd></dl>
<p>DACs are currently only supported for the <a class="el" href="group__cpu__esp32__esp32.html#esp32_dac_channels_esp32">ESP32 SoC</a> variant. </p>
</td></tr>
<tr class="memitem:afe6215885cf4c6bc1cbbbefdf19ccc80" id="r_afe6215885cf4c6bc1cbbbefdf19ccc80"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe6215885cf4c6bc1cbbbefdf19ccc80">DAC_NUMOF_MAX</a>&#160;&#160;&#160;(SOC_DAC_PERIPH_NUM)</td></tr>
<tr class="memdesc:afe6215885cf4c6bc1cbbbefdf19ccc80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of DAC channels that could be used at maximum.  <br /></td></tr>
<tr class="separator:afe6215885cf4c6bc1cbbbefdf19ccc80"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">I2C configuration</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>ESP32x SoCs integrate up to two I2C hardware interfaces.</p>
<p>The board-specific configuration of the I2C interface <a class="el" href="group__drivers__periph__i2c.html#ga9f14916eda80b19ff41d08e25eee56fb" title="Default I2C device access macro.">I2C_DEV(n)</a> requires the definition of</p>
<p><code>I2Cn_SPEED</code>, the bus speed for <a class="el" href="group__drivers__periph__i2c.html#ga9f14916eda80b19ff41d08e25eee56fb" title="Default I2C device access macro.">I2C_DEV(n)</a>, <code>I2Cn_SCL</code>, the GPIO used as SCL signal for <a class="el" href="group__drivers__periph__i2c.html#ga9f14916eda80b19ff41d08e25eee56fb" title="Default I2C device access macro.">I2C_DEV(n)</a>, and <code>I2Cn_SDA</code>, the GPIO used as SDA signal for <a class="el" href="group__drivers__periph__i2c.html#ga9f14916eda80b19ff41d08e25eee56fb" title="Default I2C device access macro.">I2C_DEV(n)</a>,</p>
<p>where <code>n</code> can be 0 or 1. If they are not defined, the I2C interface <a class="el" href="group__drivers__periph__i2c.html#ga9f14916eda80b19ff41d08e25eee56fb" title="Default I2C device access macro.">I2C_DEV(n)</a> is not used, for example: </p><div class="fragment"><div class="line"><span class="preprocessor">#define I2C0_SPEED  I2C_SPEED_FAST</span></div>
<div class="line"><span class="preprocessor">#define I2C0_SCL    GPIO22</span></div>
<div class="line"><span class="preprocessor">#define I2C0_SDA    GPIO21</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define I2C1_SPEED  I2C_SPEED_NORMAL</span></div>
<div class="line"><span class="preprocessor">#define I2C1_SCL    GPIO13</span></div>
<div class="line"><span class="preprocessor">#define I2C1_SDA    GPIO16</span></div>
</div><!-- fragment --><p>The board-specific pin configuration of I2C interfaces can be changed by <a class="el" href="group__cpu__esp32.html#esp32_application_specific_configurations">application specific configurations</a> by overriding the according <code>I2Cn_*</code> symbols.</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>To ensure that the <code>I2Cn_*</code> symbols define the configuration for <a class="el" href="group__drivers__periph__i2c.html#ga9f14916eda80b19ff41d08e25eee56fb" title="Default I2C device access macro.">I2C_DEV(n)</a>, the definition of the configuration of I2C interfaces <a class="el" href="group__drivers__periph__i2c.html#ga9f14916eda80b19ff41d08e25eee56fb" title="Default I2C device access macro.">I2C_DEV(n)</a> must be in continuous ascending order of <code>n</code>. That is, if <a class="el" href="group__drivers__periph__i2c.html#ga9f14916eda80b19ff41d08e25eee56fb" title="Default I2C device access macro.">I2C_DEV(1)</a> is used by defining the <code>I2C1_*</code> symbols, <a class="el" href="group__drivers__periph__i2c.html#ga9f14916eda80b19ff41d08e25eee56fb" title="Default I2C device access macro.">I2C_DEV(0)</a> must also be used by defining the <code>I2C0_*</code> symbols.</li>
<li>The GPIOs listed in the configuration are only initialized as I2C signals when the <code>periph_i2c</code> module is used. Otherwise they are not allocated and can be used for other purposes.</li>
<li>The same configuration is used when the I2C bit-banging software implementation is used by enabling module <code>esp_i2c_sw</code> (default).</li>
</ul>
</dd></dl>
<p>The number of used I2C interfaces I2C_NUMOF is determined automatically from board-specific peripheral definitions of <a class="el" href="group__drivers__periph__i2c.html#ga9f14916eda80b19ff41d08e25eee56fb" title="Default I2C device access macro.">I2C_DEV(n)</a>. </p>
</td></tr>
<tr class="memitem:aadb90ea077587669088351156a157867" id="r_aadb90ea077587669088351156a157867"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aadb90ea077587669088351156a157867">I2C_NUMOF_MAX</a>&#160;&#160;&#160;(SOC_I2C_NUM)</td></tr>
<tr class="memdesc:aadb90ea077587669088351156a157867"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of I2C interfaces that can be used by board definitions.  <br /></td></tr>
<tr class="separator:aadb90ea077587669088351156a157867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ee5980de0aba9d9d03729b400287755" id="r_a5ee5980de0aba9d9d03729b400287755"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ee5980de0aba9d9d03729b400287755">PERIPH_I2C_NEED_READ_REG</a></td></tr>
<tr class="memdesc:a5ee5980de0aba9d9d03729b400287755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation requires <a class="el" href="group__drivers__periph__i2c.html#gac4ab6e73e05b22c2da0c2f178da06d7b" title="Convenience function for reading one byte from a given register address.">i2c_read_reg</a>.  <br /></td></tr>
<tr class="separator:a5ee5980de0aba9d9d03729b400287755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df7b75f47f1d07ab97efc582ab242c6" id="r_a9df7b75f47f1d07ab97efc582ab242c6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9df7b75f47f1d07ab97efc582ab242c6">PERIPH_I2C_NEED_READ_REGS</a></td></tr>
<tr class="memdesc:a9df7b75f47f1d07ab97efc582ab242c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation requires <a class="el" href="group__drivers__periph__i2c.html#ga5e65efc34a8bd77223795faadc29d304" title="Convenience function for reading several bytes from a given register address.">i2c_read_regs</a>.  <br /></td></tr>
<tr class="separator:a9df7b75f47f1d07ab97efc582ab242c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a826c22d1182510f6ff3129f831b1107b" id="r_a826c22d1182510f6ff3129f831b1107b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a826c22d1182510f6ff3129f831b1107b">PERIPH_I2C_NEED_WRITE_REG</a></td></tr>
<tr class="memdesc:a826c22d1182510f6ff3129f831b1107b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation requires <a class="el" href="group__drivers__periph__i2c.html#ga02b8328d5e823d972e1e1234965daab1" title="Convenience function for writing one byte to a given register address.">i2c_write_reg</a>.  <br /></td></tr>
<tr class="separator:a826c22d1182510f6ff3129f831b1107b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d5896b5b60b2972fe3bc25ee53fa823" id="r_a2d5896b5b60b2972fe3bc25ee53fa823"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d5896b5b60b2972fe3bc25ee53fa823">PERIPH_I2C_NEED_WRITE_REGS</a></td></tr>
<tr class="memdesc:a2d5896b5b60b2972fe3bc25ee53fa823"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation requires <a class="el" href="group__drivers__periph__i2c.html#gac7e12c6df3bc117d5e46d1e98a5a7f08" title="Convenience function for writing data to a given register address.">i2c_write_regs</a>.  <br /></td></tr>
<tr class="separator:a2d5896b5b60b2972fe3bc25ee53fa823"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">PWM configuration</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>The PWM peripheral driver for ESP32x SoCs uses the LED PWM Controller (LEDC) module for implementation.</p>
<p>The LEDC module has either 1 or 2 channel groups with 6 or 8 channels each, where the first channel group comprises the low-speed channels and the second channel group comprises the high-speed channels. The difference is that changes in the configuration of the high-speed channels take effect with the next PWM cycle, while the changes in the configuration of the low-speed channels must be explicitly updated by a trigger.</p>
<p>The low-speed channel group always exists while the existence of the high-speed channel group depends on respective ESP32x SoC family.</p>
<p>Each channel group has 4 timers which can be used as clock source by the channels of the respective channel group. Thus it would be possible to define a maximum of 4 virtual PWM devices in RIOT per channel group with different frequencies and resolutions. However, regardless of whether the LEDC module of the ESP32x SoC has one or two channel groups, the PWM driver implementation only allows the available channels to be organized into up to 4 virtual PWM devices.</p>
<p>The assignment of the available channels to the virtual PWM devices is done in the board-specific peripheral configuration by defining the macros <code>PWM0_GPIOS</code>, <code>PWM1_GPIOS</code>, <code>PWM2_GPIOS</code> and <code>PWM3_GPIOS</code> These macros specify the GPIOs that are used as channels for the 4 possible virtual PWM devices <a class="el" href="group__drivers__periph__pwm.html#gad7999c048ca3b0783f3fb62b93b056db" title="Default PWM access macro.">PWM_DEV(0)</a> ... <a class="el" href="group__drivers__periph__pwm.html#gad7999c048ca3b0783f3fb62b93b056db" title="Default PWM access macro.">PWM_DEV(3)</a> in RIOT, for example: </p><div class="fragment"><div class="line"><span class="preprocessor">#define PWM0_GPIOS  { GPIO0, GPIO2, GPIO4, GPIO16, GPIO17 }</span></div>
<div class="line"><span class="preprocessor">#define PWM1_GPIOS  { GPIO27, GPIO32, GPIO33 }</span></div>
</div><!-- fragment --><p>This configuration can be changed by [application-specific configurations] (#esp32_application_specific_configurations).</p>
<p>The mapping of the GPIOs as channels of the available channel groups and channel group timers is organized by the driver automatically as follows:</p>
<center></center><center><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Macro   </th><th class="markdownTableHeadNone">1 Channel Group   </th><th class="markdownTableHeadNone">2 Channel Groups   </th><th class="markdownTableHeadNone"><a class="el" href="structTimer.html" title="struct to get time references within mqtt paho">Timer</a>    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>PWM0_GPIOS</code>   </td><td class="markdownTableBodyNone"><code>LEDC_LOW_SPEED_MODE</code>   </td><td class="markdownTableBodyNone"><code>LEDC_LOW_SPEED_MODE</code>   </td><td class="markdownTableBodyNone"><code>LEDC_TIMER_0</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>PWM1_GPIOS</code>   </td><td class="markdownTableBodyNone"><code>LEDC_LOW_SPEED_MODE</code>   </td><td class="markdownTableBodyNone"><code>LEDC_HIGH_SPEED_MODE</code>   </td><td class="markdownTableBodyNone"><code>LEDC_TIMER_1</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>PWM2_GPIOS</code>   </td><td class="markdownTableBodyNone"><code>LEDC_LOW_SPEED_MODE</code>   </td><td class="markdownTableBodyNone"><code>LEDC_LOW_SPEED_MODE</code>   </td><td class="markdownTableBodyNone"><code>LEDC_TIMER_2</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>PWM3_GPIOS</code>   </td><td class="markdownTableBodyNone"><code>LEDC_LOW_SPEED_MODE</code>   </td><td class="markdownTableBodyNone"><code>LEDC_HIGH_SPEED_MODE</code>   </td><td class="markdownTableBodyNone"><code>LEDC_TIMER_3</code>   </td></tr>
</table>
</center><center> </center><p>For example, if the LEDC module of the ESP32x SoC has two channel groups, two virtual PWM devices with 2 x 6 (or 8) channels could be used by defining 'PWM0_GPIOS' and 'PWM1_GPIOS' with 6 (or 8) GPIOs each.</p>
<p>The number of used PWM devices PWM_NUMOF is determined automatically from the definition of <code>PWM0_GPIOS</code>, <code>PWM1_GPIOS</code>, <code>PWM2_GPIOS</code> and <code>PWM3_GPIOS</code>.</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>The total number of channels defined for a channel group must not exceed <a class="el" href="#a4c22b512958daca72c8cacd3e12372bd" title="Maximum number of channels per PWM device.">PWM_CH_NUMOF_MAX</a></li>
<li>The definition of <code>PWM0_GPIOS</code>, <code>PWM1_GPIOS</code>, <code>PWM2_GPIOS</code> and <code>PWM3_GPIOS</code> can be omitted. However, to ensure that <code>PWMn_GPIOS</code> defines the configuration for <a class="el" href="group__drivers__periph__pwm.html#gad7999c048ca3b0783f3fb62b93b056db" title="Default PWM access macro.">PWM_DEV(n)</a>, the PWM channels must be defined in continuous ascending order from <code>n</code>. That means, if <code>PWM1_GPIOS</code> is defined, <code>PWM0_GPIOS</code> must be defined before, and so on. So a minimal configuration would define all channels by <code>PWM0_GPIOS</code> as <a class="el" href="group__drivers__periph__pwm.html#gad7999c048ca3b0783f3fb62b93b056db" title="Default PWM access macro.">PWM_DEV(0)</a>.</li>
<li>The order of the GPIOs in these macros determines the mapping between RIOT's PWM channels and the GPIOs.</li>
<li>As long as the GPIOs listed in <code>PWM0_GPIOS</code>, <code>PWM1_GPIOS</code>, <code>PWM2_GPIOS</code> and <code>PWM3_GPIOS</code> are not initialized as PWM channels with the <a class="el" href="group__drivers__periph__pwm.html#ga205eedf5331e5646b330d986f2b691f9" title="Initialize a PWM device.">pwm_init</a> function, they can be used for other purposes. </li>
</ul>
</dd></dl>
</td></tr>
<tr class="memitem:a384d72c648cf3953b0d71fd122c57a29" id="r_a384d72c648cf3953b0d71fd122c57a29"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a384d72c648cf3953b0d71fd122c57a29">PWM_NUMOF_MAX</a>&#160;&#160;&#160;(4)</td></tr>
<tr class="memdesc:a384d72c648cf3953b0d71fd122c57a29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of PWM devices.  <br /></td></tr>
<tr class="separator:a384d72c648cf3953b0d71fd122c57a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c22b512958daca72c8cacd3e12372bd" id="r_a4c22b512958daca72c8cacd3e12372bd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c22b512958daca72c8cacd3e12372bd">PWM_CH_NUMOF_MAX</a>&#160;&#160;&#160;(SOC_LEDC_CHANNEL_NUM)</td></tr>
<tr class="memdesc:a4c22b512958daca72c8cacd3e12372bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of channels per PWM device.  <br /></td></tr>
<tr class="separator:a4c22b512958daca72c8cacd3e12372bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">RMT configuration</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>ESP32x SoCs have a Remote Control Peripheral (RMT) that can be used to generate digital waveforms, such as NEC remote control signals or WS2812B RGB LED signals.</p>
<p>Each RMT peripheral has either 4 or 8 channels. Some ESP32x SoCs support configuring the clock sources used for each channel separately, while other ESP32x SoCs can only use a single clock source for all channels. </p>
</td></tr>
<tr class="memitem:a20377730a568815e8437e099d689e578" id="r_a20377730a568815e8437e099d689e578"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a20377730a568815e8437e099d689e578">RMT_CH_NUMOF_MAX</a>&#160;&#160;&#160;(SOC_RMT_CHANNELS_PER_GROUP)</td></tr>
<tr class="memdesc:a20377730a568815e8437e099d689e578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of RMT channels.  <br /></td></tr>
<tr class="separator:a20377730a568815e8437e099d689e578"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">RNG configuration</h2></td></tr>
<tr class="memitem:a1c8140ba01d43a1872af952c3e61d9b2" id="r_a1c8140ba01d43a1872af952c3e61d9b2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c8140ba01d43a1872af952c3e61d9b2">RNG_DATA_REG_ADDR</a>&#160;&#160;&#160;(WDEV_RND_REG)</td></tr>
<tr class="memdesc:a1c8140ba01d43a1872af952c3e61d9b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The address of the register for accessing the hardware RNG.  <br /></td></tr>
<tr class="separator:a1c8140ba01d43a1872af952c3e61d9b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">RTT and RTC configuration</h2></td></tr>
<tr class="memitem:afec7c948b8c70db3c9394fc3dc145a99" id="r_afec7c948b8c70db3c9394fc3dc145a99"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afec7c948b8c70db3c9394fc3dc145a99">RTT_FREQUENCY</a>&#160;&#160;&#160;(32768UL)</td></tr>
<tr class="memdesc:afec7c948b8c70db3c9394fc3dc145a99"><td class="mdescLeft">&#160;</td><td class="mdescRight">RTT frequency definition.  <br /></td></tr>
<tr class="separator:afec7c948b8c70db3c9394fc3dc145a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f384110fe2e8f4b3c4b9ba246517c6" id="r_a57f384110fe2e8f4b3c4b9ba246517c6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a57f384110fe2e8f4b3c4b9ba246517c6">RTT_MAX_VALUE</a>&#160;&#160;&#160;(0xFFFFFFFFUL)</td></tr>
<tr class="memdesc:a57f384110fe2e8f4b3c4b9ba246517c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">RTT is a 32-bit counter.  <br /></td></tr>
<tr class="separator:a57f384110fe2e8f4b3c4b9ba246517c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">SDMMC configuration</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>ESP32x SoC with SDMMC peripheral provide two SDMMC interfaces called slots.</p>
<p>How many slots can be used depends on the ESP32x SoC, see <a class="el" href="#a1003cd6605561c65d1776afc38c0da23">sdmmc_slot_t</a>. </p>
</td></tr>
<tr class="memitem:a59763349a78797e79ed4e3a847f63430" id="r_a59763349a78797e79ed4e3a847f63430"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59763349a78797e79ed4e3a847f63430">SDMMC_CPU_DMA_REQUIREMENTS</a>&#160;&#160;&#160;__attribute__((aligned(<a class="el" href="#af0cbbd12324a55dc975cd3a7bbcdcc24">SDMMC_CPU_DMA_ALIGNMENT</a>)))</td></tr>
<tr class="memdesc:a59763349a78797e79ed4e3a847f63430"><td class="mdescLeft">&#160;</td><td class="mdescRight">SDIO/SDMMC buffer instantiation requirement for SDHC.  <br /></td></tr>
<tr class="separator:a59763349a78797e79ed4e3a847f63430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0cbbd12324a55dc975cd3a7bbcdcc24" id="r_af0cbbd12324a55dc975cd3a7bbcdcc24"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af0cbbd12324a55dc975cd3a7bbcdcc24">SDMMC_CPU_DMA_ALIGNMENT</a>&#160;&#160;&#160;4</td></tr>
<tr class="memdesc:af0cbbd12324a55dc975cd3a7bbcdcc24"><td class="mdescLeft">&#160;</td><td class="mdescRight">SDIO/SDMMC buffer alignment for SDHC because of DMA/FIFO buffer restrictions.  <br /></td></tr>
<tr class="separator:af0cbbd12324a55dc975cd3a7bbcdcc24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1003cd6605561c65d1776afc38c0da23" id="r_a1003cd6605561c65d1776afc38c0da23"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1003cd6605561c65d1776afc38c0da23">sdmmc_slot_t</a> { <a class="el" href="#a1003cd6605561c65d1776afc38c0da23ac79f8c9b6bd07f92a08fcd5d2f115591">SDMMC_SLOT_0</a> = 0
, <a class="el" href="#a1003cd6605561c65d1776afc38c0da23a3ecdc8f14bd264b09cfaa7ead0ff2796">SDMMC_SLOT_1</a> = 1
 }</td></tr>
<tr class="memdesc:a1003cd6605561c65d1776afc38c0da23"><td class="mdescLeft">&#160;</td><td class="mdescRight">SDIO/SDMMC slots.  <a href="#a1003cd6605561c65d1776afc38c0da23">More...</a><br /></td></tr>
<tr class="separator:a1003cd6605561c65d1776afc38c0da23"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">SPI configuration</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>ESP32x SoCs have up to four SPI controllers dependent on the specific ESP32x SoC variant (family):</p>
<ul>
<li>Controller SPI0 is reserved for caching external memory like Flash</li>
<li>Controller SPI1 is reserved for external memories like PSRAM</li>
<li>Controller SPI2 can be used as general purpose SPI (GPSPI)</li>
<li>Controller SPI3 can be used as general purpose SPI (GPSPI)</li>
</ul>
<p>The controllers SPI0 and SPI1 share the same bus signals and can only operate in memory mode on most ESP32x SoC variants. Therefore, depending on the specific ESP32x SoC family, a maximum of two SPI controllers can be used as peripheral interfaces:</p>
<ul>
<li>Controller SPI2 is identified by <code>SPI2_HOST</code> (also called FSPI or HSPI)</li>
<li>Controller SPI3 is identified by <code>SPI3_HOST</code> (also called VSPI)</li>
</ul>
<p>In former ESP-IDF versions, SPI interfaces were identified by the alias names <code>FSPI</code>, <code>HSPI</code> and <code>VSPI</code>, which are sometimes also used in data sheets. These alias names have been declared obsolete in ESP-IDF. For source code compatibility reasons these alias names are defined here.</p>
<p>SPI interfaces could be used in quad SPI mode, but RIOT's low level device driver doesn't support it.</p>
<p>The board-specific configuration of the SPI interface <a class="el" href="group__drivers__periph__spi.html#gafb9420809bc7722e41488a090b53eaf9" title="Default SPI device access macro.">SPI_DEV(n)</a> requires the definition of</p>
<ul>
<li><code>SPIn_CTRL</code>, the SPI controller (<code>SPI_HOST2</code>/<code>SPI_HOST3</code>) used for <a class="el" href="group__drivers__periph__spi.html#gafb9420809bc7722e41488a090b53eaf9" title="Default SPI device access macro.">SPI_DEV(n)</a>,</li>
<li><code>SPIn_SCK</code>, the GPIO used as clock signal used for <a class="el" href="group__drivers__periph__spi.html#gafb9420809bc7722e41488a090b53eaf9" title="Default SPI device access macro.">SPI_DEV(n)</a></li>
<li><code>SPIn_MISO</code>, the GPIO used as MISO signal used for <a class="el" href="group__drivers__periph__spi.html#gafb9420809bc7722e41488a090b53eaf9" title="Default SPI device access macro.">SPI_DEV(n)</a></li>
<li><code>SPIn_MOSI</code>, the GPIO used as MOSI signal used for <a class="el" href="group__drivers__periph__spi.html#gafb9420809bc7722e41488a090b53eaf9" title="Default SPI device access macro.">SPI_DEV(n)</a>, and</li>
<li><code>SPIn_CS0</code>, the GPIO used as CS signal for <a class="el" href="group__drivers__periph__spi.html#gafb9420809bc7722e41488a090b53eaf9" title="Default SPI device access macro.">SPI_DEV(n)</a> when the <code>cs</code> parameter in <a class="el" href="group__drivers__periph__spi.html#ga31d89f231c0d6b18a71f2c8f3804e042" title="Start a new SPI transaction.">spi_acquire</a> is <a class="el" href="atmega__common_2include_2periph__cpu__common_8h.html#a3969ce1e494a72d3c2925b10ddeb4604" title="Definition of a fitting UNDEF value.">GPIO_UNDEF</a>,</li>
</ul>
<p>where <code>n</code> can be 0 and 1. If they are not defined, the according SPI interface <a class="el" href="group__drivers__periph__spi.html#gafb9420809bc7722e41488a090b53eaf9" title="Default SPI device access macro.">SPI_DEV(n)</a> is not used, for example: </p><div class="fragment"><div class="line"><span class="preprocessor">#define SPI0_CTRL   SPI3_HOST   </span><span class="comment">// VSPI could also be used on ESP32 variant</span></div>
<div class="line"><span class="preprocessor">#define SPI0_SCK    GPIO18      </span><span class="comment">// SCK  signal</span></div>
<div class="line"><span class="preprocessor">#define SPI0_MISO   GPIO19      </span><span class="comment">// MISO signal</span></div>
<div class="line"><span class="preprocessor">#define SPI0_MOSI   GPIO23      </span><span class="comment">// MOSI signal</span></div>
<div class="line"><span class="preprocessor">#define SPI0_CS0    GPIO5       </span><span class="comment">// CS0  signal</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define SPI1_CTRL   SPI2_HOST   </span><span class="comment">// HSPI could also be used here on ESP32 variant</span></div>
<div class="line"><span class="preprocessor">#define SPI1_SCK    GPIO14      </span><span class="comment">// SCK  Camera</span></div>
<div class="line"><span class="preprocessor">#define SPI1_MISO   GPIO12      </span><span class="comment">// MISO Camera</span></div>
<div class="line"><span class="preprocessor">#define SPI1_MOSI   GPIO13      </span><span class="comment">// MOSI Camera</span></div>
<div class="line"><span class="preprocessor">#define SPI1_CS0    GPIO15      </span><span class="comment">// CS0  Camera</span></div>
</div><!-- fragment --><p>The pin configuration of SPI interfaces can be changed by <a class="el" href="group__cpu__esp32.html#esp32_application_specific_configurations">application specific configurations</a> by overriding the according <code>SPIn_*</code> symbols.</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>To ensure that the <code>SPIn_*</code> symbols define the configuration for <a class="el" href="group__drivers__periph__spi.html#gafb9420809bc7722e41488a090b53eaf9" title="Default SPI device access macro.">SPI_DEV(n)</a>, the definition of the configuration of SPI interfaces <a class="el" href="group__drivers__periph__spi.html#gafb9420809bc7722e41488a090b53eaf9" title="Default SPI device access macro.">SPI_DEV(n)</a> must be in continuous ascending order of <code>n</code>. That is, if <a class="el" href="group__drivers__periph__spi.html#gafb9420809bc7722e41488a090b53eaf9" title="Default SPI device access macro.">SPI_DEV(1)</a> is used by defining the <code>SPI1_*</code> symbols, <a class="el" href="group__drivers__periph__spi.html#gafb9420809bc7722e41488a090b53eaf9" title="Default SPI device access macro.">SPI_DEV(0)</a> must also be used by defining the <code>SPI0_*</code> symbols.</li>
<li>The order in which the available interfaces <code>SPI2_HOST</code> (alias <code>HSPI</code> or <code>FSPI</code>) and <code>SPI3_HOST</code> (alias <code>VPSI</code> or <code>HSPI</code>) are assigned doesn't matter.</li>
<li>The GPIOs listed in the configuration are only initialized as SPI signals when the <code>periph_spi</code> module is used. Otherwise they are not allocated and can be used for other purposes.</li>
</ul>
</dd></dl>
<p><a class="el" href="cpu_2native_2include_2periph__conf_8h.html#ab35a2b79568128efef74adf1ba1910a8" title="Amount of SPI devices.">SPI_NUMOF</a> is determined automatically from the board-specific peripheral configuration for <a class="el" href="group__drivers__periph__spi.html#gafb9420809bc7722e41488a090b53eaf9" title="Default SPI device access macro.">SPI_DEV(n)</a>. </p>
</td></tr>
<tr class="memitem:a90e84d581aabaf4e2ed1683e60c8bb15" id="r_a90e84d581aabaf4e2ed1683e60c8bb15"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90e84d581aabaf4e2ed1683e60c8bb15">FSPI</a>&#160;&#160;&#160;SPI2_HOST</td></tr>
<tr class="memdesc:a90e84d581aabaf4e2ed1683e60c8bb15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias name for SPI2_HOST as used in former ESP-IDF versions.  <br /></td></tr>
<tr class="separator:a90e84d581aabaf4e2ed1683e60c8bb15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca218aaab0f949219155ba184ee0ecf" id="r_a4ca218aaab0f949219155ba184ee0ecf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ca218aaab0f949219155ba184ee0ecf">SPI_NUMOF_MAX</a>&#160;&#160;&#160;(SOC_SPI_PERIPH_NUM - 1)</td></tr>
<tr class="memdesc:a4ca218aaab0f949219155ba184ee0ecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of SPI interfaces that can be used by board definitions.  <br /></td></tr>
<tr class="separator:a4ca218aaab0f949219155ba184ee0ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3d9c2b9cf24ed0b13807d63f5e9b11f" id="r_af3d9c2b9cf24ed0b13807d63f5e9b11f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af3d9c2b9cf24ed0b13807d63f5e9b11f">PERIPH_SPI_NEEDS_TRANSFER_BYTE</a></td></tr>
<tr class="memdesc:af3d9c2b9cf24ed0b13807d63f5e9b11f"><td class="mdescLeft">&#160;</td><td class="mdescRight">requires function spi_transfer_byte  <br /></td></tr>
<tr class="separator:af3d9c2b9cf24ed0b13807d63f5e9b11f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac68c30cec18f4abf11cc4bb09c13df17" id="r_ac68c30cec18f4abf11cc4bb09c13df17"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac68c30cec18f4abf11cc4bb09c13df17">PERIPH_SPI_NEEDS_TRANSFER_REG</a></td></tr>
<tr class="memdesc:ac68c30cec18f4abf11cc4bb09c13df17"><td class="mdescLeft">&#160;</td><td class="mdescRight">requires function spi_transfer_reg  <br /></td></tr>
<tr class="separator:ac68c30cec18f4abf11cc4bb09c13df17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeb6291046cbd0102e8c87af75e4200d" id="r_afeb6291046cbd0102e8c87af75e4200d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afeb6291046cbd0102e8c87af75e4200d">PERIPH_SPI_NEEDS_TRANSFER_REGS</a></td></tr>
<tr class="memdesc:afeb6291046cbd0102e8c87af75e4200d"><td class="mdescLeft">&#160;</td><td class="mdescRight">requires function spi_transfer_regs  <br /></td></tr>
<tr class="separator:afeb6291046cbd0102e8c87af75e4200d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb62d376a114a58aff9d2177bdb2c3af" id="r_abb62d376a114a58aff9d2177bdb2c3af"><td class="memItemLeft" align="right" valign="top">typedef spi_host_device_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb62d376a114a58aff9d2177bdb2c3af">spi_ctrl_t</a></td></tr>
<tr class="memdesc:abb62d376a114a58aff9d2177bdb2c3af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mapping of SPI controller type for source code compatibility.  <br /></td></tr>
<tr class="separator:abb62d376a114a58aff9d2177bdb2c3af"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Timer configuration depending on which implementation is used</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>There are two different implementations for hardware timers.</p>
<ul>
<li><b><a class="el" href="structTimer.html" title="struct to get time references within mqtt paho">Timer</a> Module implementation</b> Depending on the ESP32x SoC variant (family) it provides up to 4 high speed timers, where 1 timer is used for system time. The remaining timer devices with <b>1 channel</b> each can be used as RIOT timer devices with a clock rate of 1 MHz.</li>
<li><b>Counter implementation</b> Dependent on the ESP32x SoC variant (family), the MCU has up to 3 CCOMPARE (cycle compare) registers. Two of them can be used to implement up to <b>2 timer devices</b> with <b>1 channel</b> each and a clock rate of 1 MHz. This is a feature of Xtensa-based ESP32x SoC variants.</li>
</ul>
<p>By default, the timer module is used. To use the counter implementation, add </p><div class="fragment"><div class="line">USEMODULE += esp_hw_counter</div>
</div><!-- fragment --><p> to application's makefile.</p>
<p>Timers are MCU built-in features and not board-specific. There is nothing to be configured. </p>
</td></tr>
<tr class="memitem:a6e2f66f5b6f5c835dd11f9766c4ed897" id="r_a6e2f66f5b6f5c835dd11f9766c4ed897"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e2f66f5b6f5c835dd11f9766c4ed897">TIMER_NUMOF</a>&#160;&#160;&#160;(SOC_TIMER_GROUP_TOTAL_TIMERS - 1)</td></tr>
<tr class="memdesc:a6e2f66f5b6f5c835dd11f9766c4ed897"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hardware timer modules are used for timer implementation (default)  <br /></td></tr>
<tr class="separator:a6e2f66f5b6f5c835dd11f9766c4ed897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b87241cfc8f0eb706ef97888f30ed0d" id="r_a4b87241cfc8f0eb706ef97888f30ed0d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b87241cfc8f0eb706ef97888f30ed0d">TIMER_CHANNEL_NUMOF</a>&#160;&#160;&#160;(1)</td></tr>
<tr class="separator:a4b87241cfc8f0eb706ef97888f30ed0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af358407f5bd779fefcae45a13654ad34" id="r_af358407f5bd779fefcae45a13654ad34"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af358407f5bd779fefcae45a13654ad34">TIMER_SYSTEM_GROUP</a>&#160;&#160;&#160;TIMER_GROUP_0</td></tr>
<tr class="memdesc:af358407f5bd779fefcae45a13654ad34"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structTimer.html" title="struct to get time references within mqtt paho">Timer</a> group used for system time.  <br /></td></tr>
<tr class="separator:af358407f5bd779fefcae45a13654ad34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d974d23c4edaf8358df025174b010ff" id="r_a2d974d23c4edaf8358df025174b010ff"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d974d23c4edaf8358df025174b010ff">TIMER_SYSTEM_INDEX</a>&#160;&#160;&#160;TIMER_0</td></tr>
<tr class="memdesc:a2d974d23c4edaf8358df025174b010ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of the timer in the timer timer group used for system time.  <br /></td></tr>
<tr class="separator:a2d974d23c4edaf8358df025174b010ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd27eb6fae4c08ffde8ac7c3e4a0de3b" id="r_afd27eb6fae4c08ffde8ac7c3e4a0de3b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd27eb6fae4c08ffde8ac7c3e4a0de3b">TIMER_SYSTEM_INT_SRC</a>&#160;&#160;&#160;ETS_TG0_T0_LEVEL_INTR_SOURCE</td></tr>
<tr class="memdesc:afd27eb6fae4c08ffde8ac7c3e4a0de3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">System time interrupt source.  <br /></td></tr>
<tr class="separator:afd27eb6fae4c08ffde8ac7c3e4a0de3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">UART configuration</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>ESP32x SoCs integrate up to three UART devices, depending on the specific ESP32x SoC variant (family).</p>
<p>The pin configuration of the UART device <a class="el" href="group__drivers__periph__uart.html#gafc5afd63560d27731d2517b3005f3294" title="Default UART device access macro.">UART_DEV(n)</a> is defined in the board-specific peripheral configuration by</p>
<ul>
<li><code>UARTn_TXD</code>, the GPIO used as TxD signal for <a class="el" href="group__drivers__periph__uart.html#gafc5afd63560d27731d2517b3005f3294" title="Default UART device access macro.">UART_DEV(n)</a>, and</li>
<li><code>UARTn_RXD</code>, the GPIO used as RxD signal for <a class="el" href="group__drivers__periph__uart.html#gafc5afd63560d27731d2517b3005f3294" title="Default UART device access macro.">UART_DEV(n)</a>,</li>
</ul>
<p>where <code>n</code> can be in range of 0 and UART_NUMOF_MAX-1. If they are not defined, the according UART interface <a class="el" href="group__drivers__periph__uart.html#gafc5afd63560d27731d2517b3005f3294" title="Default UART device access macro.">UART_DEV(n)</a> is not used, for example: </p><div class="fragment"><div class="line"><span class="preprocessor">#define UART1_TX    GPIO10  </span><span class="comment">// TxD signal of UART_DEV(1)</span></div>
<div class="line"><span class="preprocessor">#define UART1_RX    GPIO9   </span><span class="comment">// RxD signal of UART_DEV(1)</span></div>
</div><!-- fragment --><p>The pin configuration of UART interfaces can be changed by <a class="el" href="group__cpu__esp32.html#esp32_application_specific_configurations">application specific configurations</a> by overriding the according <code>UARTn_*</code> symbols.</p>
<dl class="section note"><dt>Note</dt><dd>To ensure that the <code>UARTn_*</code> symbols define the configuration for <a class="el" href="group__drivers__periph__uart.html#gafc5afd63560d27731d2517b3005f3294" title="Default UART device access macro.">UART_DEV(n)</a>, the configuration of the UART interfaces <a class="el" href="group__drivers__periph__uart.html#gafc5afd63560d27731d2517b3005f3294" title="Default UART device access macro.">UART_DEV(n)</a> must be in continuous ascending order of <code>n</code>. That is, if <a class="el" href="group__drivers__periph__uart.html#gafc5afd63560d27731d2517b3005f3294" title="Default UART device access macro.">UART_DEV(1)</a> is to be used by defining the <code>UART1_*</code> symbols, <a class="el" href="group__drivers__periph__uart.html#gafc5afd63560d27731d2517b3005f3294" title="Default UART device access macro.">UART_DEV(0)</a> must also be used by defining the <code>UART0_*</code> symbols, and if <a class="el" href="group__drivers__periph__uart.html#gafc5afd63560d27731d2517b3005f3294" title="Default UART device access macro.">UART_DEV(2)</a> is to be used by defining the <code>UART2_*</code> symbols, <a class="el" href="group__drivers__periph__uart.html#gafc5afd63560d27731d2517b3005f3294" title="Default UART device access macro.">UART_DEV(0)</a> and <a class="el" href="group__drivers__periph__uart.html#gafc5afd63560d27731d2517b3005f3294" title="Default UART device access macro.">UART_DEV(1)</a> must also be used by defining the <code>UART0_*</code> and <code>UART1_*</code> symbols</dd></dl>
<p>UART_NUMOF is determined automatically from the board-specific peripheral configuration for <a class="el" href="group__drivers__periph__uart.html#gafc5afd63560d27731d2517b3005f3294" title="Default UART device access macro.">UART_DEV(n)</a>.</p>
<p><a class="el" href="group__drivers__periph__uart.html#gafc5afd63560d27731d2517b3005f3294" title="Default UART device access macro.">UART_DEV(0)</a> has usually a fixed pin configuration that is used by all ESP32x boards as standard configuration for the console. The GPIOs used for <a class="el" href="group__drivers__periph__uart.html#gafc5afd63560d27731d2517b3005f3294" title="Default UART device access macro.">UART_DEV(0)</a> depend on the ESP32x SoC family. </p>
</td></tr>
<tr class="memitem:a1045548f8795e9aa17f4cda6f630576a" id="r_a1045548f8795e9aa17f4cda6f630576a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1045548f8795e9aa17f4cda6f630576a">UART_NUMOF_MAX</a>&#160;&#160;&#160;(SOC_UART_NUM)</td></tr>
<tr class="memdesc:a1045548f8795e9aa17f4cda6f630576a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of UART interfaces.  <br /></td></tr>
<tr class="separator:a1045548f8795e9aa17f4cda6f630576a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">USB device configuration</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>ESP32x SoCs integrate depending on the specific ESP32x SoC variant (family) an USB OTG FS controller based on the Synopsys DWC2 IP core. </p>
</td></tr>
<tr class="memitem:af582e2ad4760b1efafd8548d683351b3" id="r_af582e2ad4760b1efafd8548d683351b3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af582e2ad4760b1efafd8548d683351b3">USBDEV_NUMOF_MAX</a>&#160;&#160;&#160;(SOC_USB_PERIPH_NUM)</td></tr>
<tr class="memdesc:af582e2ad4760b1efafd8548d683351b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of USB OTG FS interfaces.  <br /></td></tr>
<tr class="separator:af582e2ad4760b1efafd8548d683351b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="aea6c293fdfb3bbb0f41e759577366d6f" name="aea6c293fdfb3bbb0f41e759577366d6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea6c293fdfb3bbb0f41e759577366d6f">&#9670;&#160;</a></span>ADC_NUMOF_MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADC_NUMOF_MAX&#160;&#160;&#160;(SOC_ADC_CHANNEL_NUM(0) + SOC_ADC_CHANNEL_NUM(1))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of ADC channels that could be used at maximum. </p>

<p class="definition">Definition at line <a class="el" href="esp32_2include_2periph__cpu_8h_source.html#l00351">351</a> of file <a class="el" href="esp32_2include_2periph__cpu_8h_source.html">periph_cpu.h</a>.</p>

</div>
</div>
<a id="a1943715eaeaa63e28b7b4e207f655fca" name="a1943715eaeaa63e28b7b4e207f655fca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1943715eaeaa63e28b7b4e207f655fca">&#9670;&#160;</a></span>CPUID_LEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CPUID_LEN&#160;&#160;&#160;(6U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Length of the CPU_ID in octets. </p>

<p class="definition">Definition at line <a class="el" href="esp32_2include_2periph__cpu_8h_source.html#l00068">68</a> of file <a class="el" href="esp32_2include_2periph__cpu_8h_source.html">periph_cpu.h</a>.</p>

</div>
</div>
<a id="afe6215885cf4c6bc1cbbbefdf19ccc80" name="afe6215885cf4c6bc1cbbbefdf19ccc80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe6215885cf4c6bc1cbbbefdf19ccc80">&#9670;&#160;</a></span>DAC_NUMOF_MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DAC_NUMOF_MAX&#160;&#160;&#160;(SOC_DAC_PERIPH_NUM)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of DAC channels that could be used at maximum. </p>

<p class="definition">Definition at line <a class="el" href="esp32_2include_2periph__cpu_8h_source.html#l00395">395</a> of file <a class="el" href="esp32_2include_2periph__cpu_8h_source.html">periph_cpu.h</a>.</p>

</div>
</div>
<a id="ae3553a08e62f0817da0df1c1683295a0" name="ae3553a08e62f0817da0df1c1683295a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3553a08e62f0817da0df1c1683295a0">&#9670;&#160;</a></span>ESP_PM_DEEP_SLEEP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ESP_PM_DEEP_SLEEP&#160;&#160;&#160;(0U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="esp32_2include_2periph__cpu_8h_source.html#l00060">60</a> of file <a class="el" href="esp32_2include_2periph__cpu_8h_source.html">periph_cpu.h</a>.</p>

</div>
</div>
<a id="ae2376d94f6767ae6e7602687fcff12c4" name="ae2376d94f6767ae6e7602687fcff12c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2376d94f6767ae6e7602687fcff12c4">&#9670;&#160;</a></span>ESP_PM_LIGHT_SLEEP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ESP_PM_LIGHT_SLEEP&#160;&#160;&#160;(1U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="esp32_2include_2periph__cpu_8h_source.html#l00059">59</a> of file <a class="el" href="esp32_2include_2periph__cpu_8h_source.html">periph_cpu.h</a>.</p>

</div>
</div>
<a id="aa46086d6003b622e23e6123974d8dffc" name="aa46086d6003b622e23e6123974d8dffc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa46086d6003b622e23e6123974d8dffc">&#9670;&#160;</a></span>ESP_PM_MODEM_SLEEP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ESP_PM_MODEM_SLEEP&#160;&#160;&#160;(2U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="esp32_2include_2periph__cpu_8h_source.html#l00058">58</a> of file <a class="el" href="esp32_2include_2periph__cpu_8h_source.html">periph_cpu.h</a>.</p>

</div>
</div>
<a id="a90e84d581aabaf4e2ed1683e60c8bb15" name="a90e84d581aabaf4e2ed1683e60c8bb15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90e84d581aabaf4e2ed1683e60c8bb15">&#9670;&#160;</a></span>FSPI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FSPI&#160;&#160;&#160;SPI2_HOST</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias name for SPI2_HOST as used in former ESP-IDF versions. </p>

<p class="definition">Definition at line <a class="el" href="esp32_2include_2periph__cpu_8h_source.html#l00857">857</a> of file <a class="el" href="esp32_2include_2periph__cpu_8h_source.html">periph_cpu.h</a>.</p>

</div>
</div>
<a id="ae29846b3ecd19a0b7c44ff80a37ae7c1" name="ae29846b3ecd19a0b7c44ff80a37ae7c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae29846b3ecd19a0b7c44ff80a37ae7c1">&#9670;&#160;</a></span>GPIO_PIN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GPIO_PIN</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((x &lt;&lt; 5) | y)</div>
</div><!-- fragment -->
<p>Define a CPU specific GPIO pin generator macro. </p>

<p class="definition">Definition at line <a class="el" href="esp32_2include_2periph__cpu_8h_source.html#l00096">96</a> of file <a class="el" href="esp32_2include_2periph__cpu_8h_source.html">periph_cpu.h</a>.</p>

</div>
</div>
<a id="a868f2d79bdced071714fb44a357c0018" name="a868f2d79bdced071714fb44a357c0018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a868f2d79bdced071714fb44a357c0018">&#9670;&#160;</a></span>GPIO_PIN_NUMOF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GPIO_PIN_NUMOF&#160;&#160;&#160;(SOC_GPIO_PIN_COUNT)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define CPU specific number of GPIO pins. </p>

<p class="definition">Definition at line <a class="el" href="esp32_2include_2periph__cpu_8h_source.html#l00110">110</a> of file <a class="el" href="esp32_2include_2periph__cpu_8h_source.html">periph_cpu.h</a>.</p>

</div>
</div>
<a id="a3969ce1e494a72d3c2925b10ddeb4604" name="a3969ce1e494a72d3c2925b10ddeb4604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3969ce1e494a72d3c2925b10ddeb4604">&#9670;&#160;</a></span>GPIO_UNDEF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GPIO_UNDEF&#160;&#160;&#160;(0xffffffff)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition of a fitting UNDEF value. </p>

<p class="definition">Definition at line <a class="el" href="esp32_2include_2periph__cpu_8h_source.html#l00089">89</a> of file <a class="el" href="esp32_2include_2periph__cpu_8h_source.html">periph_cpu.h</a>.</p>

</div>
</div>
<a id="a759f553fbddd2915b49e50c967661fb1" name="a759f553fbddd2915b49e50c967661fb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a759f553fbddd2915b49e50c967661fb1">&#9670;&#160;</a></span>HAVE_GPIO_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HAVE_GPIO_T</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Override the default gpio_t type definition. </p>
<p>This is required here to have gpio_t defined in this file. </p>

<p class="definition">Definition at line <a class="el" href="esp32_2include_2periph__cpu_8h_source.html#l00081">81</a> of file <a class="el" href="esp32_2include_2periph__cpu_8h_source.html">periph_cpu.h</a>.</p>

</div>
</div>
<a id="aadb90ea077587669088351156a157867" name="aadb90ea077587669088351156a157867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadb90ea077587669088351156a157867">&#9670;&#160;</a></span>I2C_NUMOF_MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_NUMOF_MAX&#160;&#160;&#160;(SOC_I2C_NUM)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum number of I2C interfaces that can be used by board definitions. </p>

<p class="definition">Definition at line <a class="el" href="esp32_2include_2periph__cpu_8h_source.html#l00479">479</a> of file <a class="el" href="esp32_2include_2periph__cpu_8h_source.html">periph_cpu.h</a>.</p>

</div>
</div>
<a id="a5ee5980de0aba9d9d03729b400287755" name="a5ee5980de0aba9d9d03729b400287755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ee5980de0aba9d9d03729b400287755">&#9670;&#160;</a></span>PERIPH_I2C_NEED_READ_REG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PERIPH_I2C_NEED_READ_REG</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation requires <a class="el" href="group__drivers__periph__i2c.html#gac4ab6e73e05b22c2da0c2f178da06d7b" title="Convenience function for reading one byte from a given register address.">i2c_read_reg</a>. </p>

<p class="definition">Definition at line <a class="el" href="esp32_2include_2periph__cpu_8h_source.html#l00481">481</a> of file <a class="el" href="esp32_2include_2periph__cpu_8h_source.html">periph_cpu.h</a>.</p>

</div>
</div>
<a id="a9df7b75f47f1d07ab97efc582ab242c6" name="a9df7b75f47f1d07ab97efc582ab242c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9df7b75f47f1d07ab97efc582ab242c6">&#9670;&#160;</a></span>PERIPH_I2C_NEED_READ_REGS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PERIPH_I2C_NEED_READ_REGS</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation requires <a class="el" href="group__drivers__periph__i2c.html#ga5e65efc34a8bd77223795faadc29d304" title="Convenience function for reading several bytes from a given register address.">i2c_read_regs</a>. </p>

<p class="definition">Definition at line <a class="el" href="esp32_2include_2periph__cpu_8h_source.html#l00482">482</a> of file <a class="el" href="esp32_2include_2periph__cpu_8h_source.html">periph_cpu.h</a>.</p>

</div>
</div>
<a id="a826c22d1182510f6ff3129f831b1107b" name="a826c22d1182510f6ff3129f831b1107b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a826c22d1182510f6ff3129f831b1107b">&#9670;&#160;</a></span>PERIPH_I2C_NEED_WRITE_REG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PERIPH_I2C_NEED_WRITE_REG</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation requires <a class="el" href="group__drivers__periph__i2c.html#ga02b8328d5e823d972e1e1234965daab1" title="Convenience function for writing one byte to a given register address.">i2c_write_reg</a>. </p>

<p class="definition">Definition at line <a class="el" href="esp32_2include_2periph__cpu_8h_source.html#l00483">483</a> of file <a class="el" href="esp32_2include_2periph__cpu_8h_source.html">periph_cpu.h</a>.</p>

</div>
</div>
<a id="a2d5896b5b60b2972fe3bc25ee53fa823" name="a2d5896b5b60b2972fe3bc25ee53fa823"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d5896b5b60b2972fe3bc25ee53fa823">&#9670;&#160;</a></span>PERIPH_I2C_NEED_WRITE_REGS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PERIPH_I2C_NEED_WRITE_REGS</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation requires <a class="el" href="group__drivers__periph__i2c.html#gac7e12c6df3bc117d5e46d1e98a5a7f08" title="Convenience function for writing data to a given register address.">i2c_write_regs</a>. </p>

<p class="definition">Definition at line <a class="el" href="esp32_2include_2periph__cpu_8h_source.html#l00484">484</a> of file <a class="el" href="esp32_2include_2periph__cpu_8h_source.html">periph_cpu.h</a>.</p>

</div>
</div>
<a id="af3d9c2b9cf24ed0b13807d63f5e9b11f" name="af3d9c2b9cf24ed0b13807d63f5e9b11f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3d9c2b9cf24ed0b13807d63f5e9b11f">&#9670;&#160;</a></span>PERIPH_SPI_NEEDS_TRANSFER_BYTE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PERIPH_SPI_NEEDS_TRANSFER_BYTE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>requires function spi_transfer_byte </p>

<p class="definition">Definition at line <a class="el" href="esp32_2include_2periph__cpu_8h_source.html#l00876">876</a> of file <a class="el" href="esp32_2include_2periph__cpu_8h_source.html">periph_cpu.h</a>.</p>

</div>
</div>
<a id="ac68c30cec18f4abf11cc4bb09c13df17" name="ac68c30cec18f4abf11cc4bb09c13df17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac68c30cec18f4abf11cc4bb09c13df17">&#9670;&#160;</a></span>PERIPH_SPI_NEEDS_TRANSFER_REG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PERIPH_SPI_NEEDS_TRANSFER_REG</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>requires function spi_transfer_reg </p>

<p class="definition">Definition at line <a class="el" href="esp32_2include_2periph__cpu_8h_source.html#l00877">877</a> of file <a class="el" href="esp32_2include_2periph__cpu_8h_source.html">periph_cpu.h</a>.</p>

</div>
</div>
<a id="afeb6291046cbd0102e8c87af75e4200d" name="afeb6291046cbd0102e8c87af75e4200d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeb6291046cbd0102e8c87af75e4200d">&#9670;&#160;</a></span>PERIPH_SPI_NEEDS_TRANSFER_REGS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PERIPH_SPI_NEEDS_TRANSFER_REGS</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>requires function spi_transfer_regs </p>

<p class="definition">Definition at line <a class="el" href="esp32_2include_2periph__cpu_8h_source.html#l00878">878</a> of file <a class="el" href="esp32_2include_2periph__cpu_8h_source.html">periph_cpu.h</a>.</p>

</div>
</div>
<a id="afd04a76b55e9fef358e904400cde4db7" name="afd04a76b55e9fef358e904400cde4db7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd04a76b55e9fef358e904400cde4db7">&#9670;&#160;</a></span>PERIPH_TIMER_PROVIDES_SET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PERIPH_TIMER_PROVIDES_SET</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prevent shared timer functions from being used. </p>

<p class="definition">Definition at line <a class="el" href="esp32_2include_2periph__cpu_8h_source.html#l00929">929</a> of file <a class="el" href="esp32_2include_2periph__cpu_8h_source.html">periph_cpu.h</a>.</p>

</div>
</div>
<a id="a3d1931627629f3c43bd898da0be6075b" name="a3d1931627629f3c43bd898da0be6075b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d1931627629f3c43bd898da0be6075b">&#9670;&#160;</a></span>PM_NUM_MODES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PM_NUM_MODES&#160;&#160;&#160;(3U)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of usable low power modes. </p>

<p class="definition">Definition at line <a class="el" href="esp32_2include_2periph__cpu_8h_source.html#l00052">52</a> of file <a class="el" href="esp32_2include_2periph__cpu_8h_source.html">periph_cpu.h</a>.</p>

</div>
</div>
<a id="a77546a5cc91deda999da3cb862fc3f98" name="a77546a5cc91deda999da3cb862fc3f98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77546a5cc91deda999da3cb862fc3f98">&#9670;&#160;</a></span>PORT_GPIO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PORT_GPIO&#160;&#160;&#160;(0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Available GPIO ports on ESP32. </p>

<p class="definition">Definition at line <a class="el" href="esp32_2include_2periph__cpu_8h_source.html#l00103">103</a> of file <a class="el" href="esp32_2include_2periph__cpu_8h_source.html">periph_cpu.h</a>.</p>

</div>
</div>
<a id="a0c0ac9ba49fa45f1faab835edc15d5ed" name="a0c0ac9ba49fa45f1faab835edc15d5ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c0ac9ba49fa45f1faab835edc15d5ed">&#9670;&#160;</a></span>PROVIDES_PM_LAYERED_OFF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PROVIDES_PM_LAYERED_OFF</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="esp32_2include_2periph__cpu_8h_source.html#l00047">47</a> of file <a class="el" href="esp32_2include_2periph__cpu_8h_source.html">periph_cpu.h</a>.</p>

</div>
</div>
<a id="a19d28a07b2898cf543c068c890ab7da0" name="a19d28a07b2898cf543c068c890ab7da0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19d28a07b2898cf543c068c890ab7da0">&#9670;&#160;</a></span>PROVIDES_PM_OFF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PROVIDES_PM_OFF</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="esp32_2include_2periph__cpu_8h_source.html#l00046">46</a> of file <a class="el" href="esp32_2include_2periph__cpu_8h_source.html">periph_cpu.h</a>.</p>

</div>
</div>
<a id="abb8775ffe47b6ea299c337d2de369e13" name="abb8775ffe47b6ea299c337d2de369e13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb8775ffe47b6ea299c337d2de369e13">&#9670;&#160;</a></span>PROVIDES_PM_RESTART</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PROVIDES_PM_RESTART</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="esp32_2include_2periph__cpu_8h_source.html#l00045">45</a> of file <a class="el" href="esp32_2include_2periph__cpu_8h_source.html">periph_cpu.h</a>.</p>

</div>
</div>
<a id="a04211208eb7863ce1c522440a91c745c" name="a04211208eb7863ce1c522440a91c745c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04211208eb7863ce1c522440a91c745c">&#9670;&#160;</a></span>PROVIDES_PM_SET_LOWEST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PROVIDES_PM_SET_LOWEST</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="esp32_2include_2periph__cpu_8h_source.html#l00044">44</a> of file <a class="el" href="esp32_2include_2periph__cpu_8h_source.html">periph_cpu.h</a>.</p>

</div>
</div>
<a id="a4c22b512958daca72c8cacd3e12372bd" name="a4c22b512958daca72c8cacd3e12372bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c22b512958daca72c8cacd3e12372bd">&#9670;&#160;</a></span>PWM_CH_NUMOF_MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PWM_CH_NUMOF_MAX&#160;&#160;&#160;(SOC_LEDC_CHANNEL_NUM)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum number of channels per PWM device. </p>

<p class="definition">Definition at line <a class="el" href="esp32_2include_2periph__cpu_8h_source.html#l00592">592</a> of file <a class="el" href="esp32_2include_2periph__cpu_8h_source.html">periph_cpu.h</a>.</p>

</div>
</div>
<a id="a384d72c648cf3953b0d71fd122c57a29" name="a384d72c648cf3953b0d71fd122c57a29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a384d72c648cf3953b0d71fd122c57a29">&#9670;&#160;</a></span>PWM_NUMOF_MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PWM_NUMOF_MAX&#160;&#160;&#160;(4)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum number of PWM devices. </p>

<p class="definition">Definition at line <a class="el" href="esp32_2include_2periph__cpu_8h_source.html#l00587">587</a> of file <a class="el" href="esp32_2include_2periph__cpu_8h_source.html">periph_cpu.h</a>.</p>

</div>
</div>
<a id="a20377730a568815e8437e099d689e578" name="a20377730a568815e8437e099d689e578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20377730a568815e8437e099d689e578">&#9670;&#160;</a></span>RMT_CH_NUMOF_MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RMT_CH_NUMOF_MAX&#160;&#160;&#160;(SOC_RMT_CHANNELS_PER_GROUP)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum number of RMT channels. </p>
<p>The number of configured channels must be less or equal. </p>

<p class="definition">Definition at line <a class="el" href="esp32_2include_2periph__cpu_8h_source.html#l00626">626</a> of file <a class="el" href="esp32_2include_2periph__cpu_8h_source.html">periph_cpu.h</a>.</p>

</div>
</div>
<a id="a1c8140ba01d43a1872af952c3e61d9b2" name="a1c8140ba01d43a1872af952c3e61d9b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c8140ba01d43a1872af952c3e61d9b2">&#9670;&#160;</a></span>RNG_DATA_REG_ADDR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RNG_DATA_REG_ADDR&#160;&#160;&#160;(WDEV_RND_REG)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The address of the register for accessing the hardware RNG. </p>

<p class="definition">Definition at line <a class="el" href="esp32_2include_2periph__cpu_8h_source.html#l00638">638</a> of file <a class="el" href="esp32_2include_2periph__cpu_8h_source.html">periph_cpu.h</a>.</p>

</div>
</div>
<a id="afec7c948b8c70db3c9394fc3dc145a99" name="afec7c948b8c70db3c9394fc3dc145a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afec7c948b8c70db3c9394fc3dc145a99">&#9670;&#160;</a></span>RTT_FREQUENCY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTT_FREQUENCY&#160;&#160;&#160;(32768UL)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>RTT frequency definition. </p>
<p>The RTT frequency is always 32.768 kHz even if no external crystal is connected. In this case the RTT value counted with the internal 150 kHz RC oscillator is converted to a value for an RTT with 32.768 kHz. </p>

<p class="definition">Definition at line <a class="el" href="esp32_2include_2periph__cpu_8h_source.html#l00653">653</a> of file <a class="el" href="esp32_2include_2periph__cpu_8h_source.html">periph_cpu.h</a>.</p>

</div>
</div>
<a id="a57f384110fe2e8f4b3c4b9ba246517c6" name="a57f384110fe2e8f4b3c4b9ba246517c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57f384110fe2e8f4b3c4b9ba246517c6">&#9670;&#160;</a></span>RTT_MAX_VALUE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTT_MAX_VALUE&#160;&#160;&#160;(0xFFFFFFFFUL)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>RTT is a 32-bit counter. </p>

<p class="definition">Definition at line <a class="el" href="esp32_2include_2periph__cpu_8h_source.html#l00658">658</a> of file <a class="el" href="esp32_2include_2periph__cpu_8h_source.html">periph_cpu.h</a>.</p>

</div>
</div>
<a id="af0cbbd12324a55dc975cd3a7bbcdcc24" name="af0cbbd12324a55dc975cd3a7bbcdcc24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0cbbd12324a55dc975cd3a7bbcdcc24">&#9670;&#160;</a></span>SDMMC_CPU_DMA_ALIGNMENT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SDMMC_CPU_DMA_ALIGNMENT&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SDIO/SDMMC buffer alignment for SDHC because of DMA/FIFO buffer restrictions. </p>

<p class="definition">Definition at line <a class="el" href="esp32_2include_2periph__cpu_8h_source.html#l00734">734</a> of file <a class="el" href="esp32_2include_2periph__cpu_8h_source.html">periph_cpu.h</a>.</p>

</div>
</div>
<a id="a59763349a78797e79ed4e3a847f63430" name="a59763349a78797e79ed4e3a847f63430"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59763349a78797e79ed4e3a847f63430">&#9670;&#160;</a></span>SDMMC_CPU_DMA_REQUIREMENTS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SDMMC_CPU_DMA_REQUIREMENTS&#160;&#160;&#160;__attribute__((aligned(<a class="el" href="#af0cbbd12324a55dc975cd3a7bbcdcc24">SDMMC_CPU_DMA_ALIGNMENT</a>)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SDIO/SDMMC buffer instantiation requirement for SDHC. </p>

<p class="definition">Definition at line <a class="el" href="esp32_2include_2periph__cpu_8h_source.html#l00729">729</a> of file <a class="el" href="esp32_2include_2periph__cpu_8h_source.html">periph_cpu.h</a>.</p>

</div>
</div>
<a id="a4ca218aaab0f949219155ba184ee0ecf" name="a4ca218aaab0f949219155ba184ee0ecf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ca218aaab0f949219155ba184ee0ecf">&#9670;&#160;</a></span>SPI_NUMOF_MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPI_NUMOF_MAX&#160;&#160;&#160;(SOC_SPI_PERIPH_NUM - 1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum number of SPI interfaces that can be used by board definitions. </p>

<p class="definition">Definition at line <a class="el" href="esp32_2include_2periph__cpu_8h_source.html#l00874">874</a> of file <a class="el" href="esp32_2include_2periph__cpu_8h_source.html">periph_cpu.h</a>.</p>

</div>
</div>
<a id="a81935d479349dc2ce0a416bcb0e6beda" name="a81935d479349dc2ce0a416bcb0e6beda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81935d479349dc2ce0a416bcb0e6beda">&#9670;&#160;</a></span>STDIO_UART_DEV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STDIO_UART_DEV&#160;&#160;&#160;CONFIG_ESP_CONSOLE_UART_NUM</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART device used for STDIO. </p>

<p class="definition">Definition at line <a class="el" href="esp32_2include_2periph__cpu_8h_source.html#l00038">38</a> of file <a class="el" href="esp32_2include_2periph__cpu_8h_source.html">periph_cpu.h</a>.</p>

</div>
</div>
<a id="a4b87241cfc8f0eb706ef97888f30ed0d" name="a4b87241cfc8f0eb706ef97888f30ed0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b87241cfc8f0eb706ef97888f30ed0d">&#9670;&#160;</a></span>TIMER_CHANNEL_NUMOF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TIMER_CHANNEL_NUMOF&#160;&#160;&#160;(1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="esp32_2include_2periph__cpu_8h_source.html#l00914">914</a> of file <a class="el" href="esp32_2include_2periph__cpu_8h_source.html">periph_cpu.h</a>.</p>

</div>
</div>
<a id="a6e2f66f5b6f5c835dd11f9766c4ed897" name="a6e2f66f5b6f5c835dd11f9766c4ed897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e2f66f5b6f5c835dd11f9766c4ed897">&#9670;&#160;</a></span>TIMER_NUMOF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TIMER_NUMOF&#160;&#160;&#160;(SOC_TIMER_GROUP_TOTAL_TIMERS - 1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hardware timer modules are used for timer implementation (default) </p>
<p>Since one timer is used for the system time, there is one timer less than the total number of timers. </p>

<p class="definition">Definition at line <a class="el" href="esp32_2include_2periph__cpu_8h_source.html#l00913">913</a> of file <a class="el" href="esp32_2include_2periph__cpu_8h_source.html">periph_cpu.h</a>.</p>

</div>
</div>
<a id="af358407f5bd779fefcae45a13654ad34" name="af358407f5bd779fefcae45a13654ad34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af358407f5bd779fefcae45a13654ad34">&#9670;&#160;</a></span>TIMER_SYSTEM_GROUP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TIMER_SYSTEM_GROUP&#160;&#160;&#160;TIMER_GROUP_0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structTimer.html" title="struct to get time references within mqtt paho">Timer</a> group used for system time. </p>

<p class="definition">Definition at line <a class="el" href="esp32_2include_2periph__cpu_8h_source.html#l00918">918</a> of file <a class="el" href="esp32_2include_2periph__cpu_8h_source.html">periph_cpu.h</a>.</p>

</div>
</div>
<a id="a2d974d23c4edaf8358df025174b010ff" name="a2d974d23c4edaf8358df025174b010ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d974d23c4edaf8358df025174b010ff">&#9670;&#160;</a></span>TIMER_SYSTEM_INDEX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TIMER_SYSTEM_INDEX&#160;&#160;&#160;TIMER_0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Index of the timer in the timer timer group used for system time. </p>

<p class="definition">Definition at line <a class="el" href="esp32_2include_2periph__cpu_8h_source.html#l00920">920</a> of file <a class="el" href="esp32_2include_2periph__cpu_8h_source.html">periph_cpu.h</a>.</p>

</div>
</div>
<a id="afd27eb6fae4c08ffde8ac7c3e4a0de3b" name="afd27eb6fae4c08ffde8ac7c3e4a0de3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd27eb6fae4c08ffde8ac7c3e4a0de3b">&#9670;&#160;</a></span>TIMER_SYSTEM_INT_SRC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TIMER_SYSTEM_INT_SRC&#160;&#160;&#160;ETS_TG0_T0_LEVEL_INTR_SOURCE</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>System time interrupt source. </p>

<p class="definition">Definition at line <a class="el" href="esp32_2include_2periph__cpu_8h_source.html#l00922">922</a> of file <a class="el" href="esp32_2include_2periph__cpu_8h_source.html">periph_cpu.h</a>.</p>

</div>
</div>
<a id="a1045548f8795e9aa17f4cda6f630576a" name="a1045548f8795e9aa17f4cda6f630576a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1045548f8795e9aa17f4cda6f630576a">&#9670;&#160;</a></span>UART_NUMOF_MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UART_NUMOF_MAX&#160;&#160;&#160;(SOC_UART_NUM)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum number of UART interfaces. </p>

<p class="definition">Definition at line <a class="el" href="esp32_2include_2periph__cpu_8h_source.html#l00984">984</a> of file <a class="el" href="esp32_2include_2periph__cpu_8h_source.html">periph_cpu.h</a>.</p>

</div>
</div>
<a id="af582e2ad4760b1efafd8548d683351b3" name="af582e2ad4760b1efafd8548d683351b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af582e2ad4760b1efafd8548d683351b3">&#9670;&#160;</a></span>USBDEV_NUMOF_MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBDEV_NUMOF_MAX&#160;&#160;&#160;(SOC_USB_PERIPH_NUM)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum number of USB OTG FS interfaces. </p>

<p class="definition">Definition at line <a class="el" href="esp32_2include_2periph__cpu_8h_source.html#l00999">999</a> of file <a class="el" href="esp32_2include_2periph__cpu_8h_source.html">periph_cpu.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="abb62d376a114a58aff9d2177bdb2c3af" name="abb62d376a114a58aff9d2177bdb2c3af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb62d376a114a58aff9d2177bdb2c3af">&#9670;&#160;</a></span>spi_ctrl_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef spi_host_device_t <a class="el" href="esp8266_2include_2periph__cpu_8h.html#ad268301d3b918e279269ec49f803488d">spi_ctrl_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mapping of SPI controller type for source code compatibility. </p>

<p class="definition">Definition at line <a class="el" href="esp32_2include_2periph__cpu_8h_source.html#l00842">842</a> of file <a class="el" href="esp32_2include_2periph__cpu_8h_source.html">periph_cpu.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a1003cd6605561c65d1776afc38c0da23" name="a1003cd6605561c65d1776afc38c0da23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1003cd6605561c65d1776afc38c0da23">&#9670;&#160;</a></span>sdmmc_slot_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a1003cd6605561c65d1776afc38c0da23">sdmmc_slot_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SDIO/SDMMC slots. </p>
<p>ESP32x SoCs that have a SDMMC peripheral provide two SDMMC interfaces called slots.</p>
<dl class="section note"><dt>Note</dt><dd>If the ESP32x variant uses direct I/O functions for the SDMMC signals (i.e. <code>SOC_SDMMC_USE_IOMUX</code> is defined in SoC capabilities), the GPIOs used for the SDMMC slots are fixed. In this case, slot 0 can't be used because the GPIOs are defined for Slot 0 are the same as those used for the Flash. If the ESP32x variant uses the GPIO matrix to route the SDMMC signals to arbitrary pins (i.e. <code>SOC_SDMMC_USE_GPIO_MATRIX</code> is defined in SoC capabilities), slot 0 can be used but the GPIOs used for the slot have to be different from those used for the Flash. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1003cd6605561c65d1776afc38c0da23ac79f8c9b6bd07f92a08fcd5d2f115591" name="a1003cd6605561c65d1776afc38c0da23ac79f8c9b6bd07f92a08fcd5d2f115591"></a>SDMMC_SLOT_0&#160;</td><td class="fielddoc"><p>SD/MMC host controller slot 0 (not usable on ESP32 variant) </p>
</td></tr>
<tr><td class="fieldname"><a id="a1003cd6605561c65d1776afc38c0da23a3ecdc8f14bd264b09cfaa7ead0ff2796" name="a1003cd6605561c65d1776afc38c0da23a3ecdc8f14bd264b09cfaa7ead0ff2796"></a>SDMMC_SLOT_1&#160;</td><td class="fielddoc"><p>SD/MMC host controller slot 1. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="esp32_2include_2periph__cpu_8h_source.html#l00686">686</a> of file <a class="el" href="esp32_2include_2periph__cpu_8h_source.html">periph_cpu.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->

    </div>
  </body>
</html>
