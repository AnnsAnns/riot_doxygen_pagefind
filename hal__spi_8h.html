<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RIOT OS: pkg/mynewt-core/include/hal/hal_spi.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<!-- <script type="text/javascript" src="jquery.js"></script> -->
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<!-- <link href="/pagefind/pagefind-ui.css" rel="stylesheet"> -->
<script src="/pagefind/pagefind-ui.js"></script>
<script>
  // Check whether the PagefindUI class is available
  if (typeof PagefindUI === 'undefined') {
    console.error('PagefindUI class is not available | Dev Build');
  } else {
    // // Remove the "searchstub" element and initialize the PagefindUI class
    // document.getElementById("#searchstub").remove();
    // Initialize the PagefindUI class with the element id "search"
    window.addEventListener('DOMContentLoaded', (event) => {
        new PagefindUI({ element: "#search", showSubResults: true });
    });
  }
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="global.css" rel="stylesheet" type="text/css" />
</head>
<body>
  <script>
    // Print the data within the NAVTREE variable from the navtreedata.js file
    var navtree = NAVTREE;
    console.log(navtree);
  </script>
<div class="flex flex-row gap-4 w-screen font-sans text-lg max-h-screen overscroll-contain justify-items-stretch bg-neutral-900">
  <!--Sidebar-->
  <div data-pagefind-ignore="all" class="w-1/3 max-w-md flex-auto h-screen bg-neutral-800 ring-2 ring-neutral-700 shadow-neutral-800 shadow-2xl rounded-xl p-3 ml-1 my-2 mr-3 flex flex-col justify-around">
    <div id="top" class="justify-self-center content-center items-center place-content-center">
      <img alt="Logo" src="riot-logo.svg"/>
      <div id="projectbrief">
        The friendly Operating System for the Internet of Things
      </div>
    </div>
    <div id="search" class="place-content-center" class="overflow-y-scroll max-h-64 bg-slate-400 ring-2 ring-white text-white" >
      <h1>Searchbar via Pagefind</h1>
      <!-- <div id="searchstub" class="flex items-center border border-gray-300 rounded-lg p-2 shadow-sm">
        <input type="text" placeholder="Search is only available in Production Build ..." class="flex-grow p-2 outline-none">
      </div> -->
    </div>
    <div id="navtree">
      <script>
        // The navtree variable is always a pair of two elements (key, value)
        // The key is the name we should display and the value is the link to the page
        // Generate the navtree from the navtreedata.js file and put it under the navtree div
        var navtree = NAVTREE[0][2];
        var navtreeHTML = "<h1>Navigation based on Doxygen</h1> <ul>";
        for (var i = 0; i < navtree.length; i++) {
          navtreeHTML += "<li><a href='" + navtree[i][1] + "'>" + navtree[i][0] + "</a></li>";
          if (i == 5) {
            navtreeHTML += '<li><h3 class="ring-2 ring-white"> Random Insert for Demonstration </h3></li>';
          }
        }
        navtreeHTML += "</ul>";
        document.getElementById("navtree").innerHTML = navtreeHTML;
      </script>
    </div>
    <ul>
      <li class="footer">
        Generated on Tue Sep 24 2024 11:16:25 by 
          <a href="http://www.doxygen.org/index.html">
            Doxygen
          </a> 
        1.12.0
      </li>
    </ul>
  </div>
  <!--Main Content-->
  <div class="hidden">
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',true);
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('hal__spi_8h.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">hal_spi.h File Reference<div class="ingroups"><a class="el" href="group__pkg.html">Packages</a> &raquo; <a class="el" href="group__pkg__uwb__dw1000.html">Driver implementation for the uwb-core driver for Decawave DW1000 transceiver</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>SPI abstraction layer RIOT adaption.  
<a href="#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>SPI abstraction layer RIOT adaption. </p>
<dl class="section author"><dt>Author</dt><dd>Francisco Molina <a href="#" onclick="location.href='mai'+'lto:'+'fra'+'nc'+'ois'+'-x'+'avi'+'er'+'.mo'+'li'+'na@'+'in'+'ria'+'.f'+'r'; return false;">franc<span class="obfuscator">.nosp@m.</span>ois-<span class="obfuscator">.nosp@m.</span>xavie<span class="obfuscator">.nosp@m.</span>r.mo<span class="obfuscator">.nosp@m.</span>lina@<span class="obfuscator">.nosp@m.</span>inri<span class="obfuscator">.nosp@m.</span>a.fr</a> </dd></dl>

<p class="definition">Definition in file <a class="el" href="hal__spi_8h_source.html">hal_spi.h</a>.</p>
</div><div class="textblock"><code>#include &quot;<a class="el" href="spi_8h_source.html">periph/spi.h</a>&quot;</code><br />
</div><div class="textblock"><div id="dynsection-0" onclick="return dynsection.toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Include dependency graph for hal_spi.h:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="hal__spi_8h__incl.svg" width="730" height="283"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
<p><a href="hal__spi_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhal__spi__settings.html">hal_spi_settings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">since one spi device can control multiple devices, some configuration can be changed on the fly from the hal  <a href="structhal__spi__settings.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:af269bbeaf787deae7de03b7e1c8ede4f" id="r_af269bbeaf787deae7de03b7e1c8ede4f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af269bbeaf787deae7de03b7e1c8ede4f">HAL_SPI_MODE0</a>&#160;&#160;&#160;(<a class="el" href="msp430_2include_2f2xx__g2xx_2periph__cpu_8h.html#ac4b206a51636d91c5cffcbcee458c3cba152359b11fb4b43ed0c5485eb0ab0673">SPI_MODE_0</a>)</td></tr>
<tr class="memdesc:af269bbeaf787deae7de03b7e1c8ede4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI mode 0.  <br /></td></tr>
<tr class="separator:af269bbeaf787deae7de03b7e1c8ede4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4fae1c5b56c54e8bb905d4774b6c21e" id="r_aa4fae1c5b56c54e8bb905d4774b6c21e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4fae1c5b56c54e8bb905d4774b6c21e">HAL_SPI_MODE1</a>&#160;&#160;&#160;(<a class="el" href="msp430_2include_2f2xx__g2xx_2periph__cpu_8h.html#ac4b206a51636d91c5cffcbcee458c3cba7c1990cc15e9d69621be8e0e757e634c">SPI_MODE_1</a>)</td></tr>
<tr class="memdesc:aa4fae1c5b56c54e8bb905d4774b6c21e"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI mode 1.  <br /></td></tr>
<tr class="separator:aa4fae1c5b56c54e8bb905d4774b6c21e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a4f7a6b535bf91c6d9eadc94876b3ab" id="r_a9a4f7a6b535bf91c6d9eadc94876b3ab"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a4f7a6b535bf91c6d9eadc94876b3ab">HAL_SPI_MODE2</a>&#160;&#160;&#160;(<a class="el" href="msp430_2include_2f2xx__g2xx_2periph__cpu_8h.html#ac4b206a51636d91c5cffcbcee458c3cba4d350945d895a4acdc45ae96b0b82fc3">SPI_MODE_2</a>)</td></tr>
<tr class="memdesc:a9a4f7a6b535bf91c6d9eadc94876b3ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI mode 2.  <br /></td></tr>
<tr class="separator:a9a4f7a6b535bf91c6d9eadc94876b3ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3d553cb6ad796c81cf8da03fd162410" id="r_ab3d553cb6ad796c81cf8da03fd162410"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3d553cb6ad796c81cf8da03fd162410">HAL_SPI_MODE3</a>&#160;&#160;&#160;(<a class="el" href="msp430_2include_2f2xx__g2xx_2periph__cpu_8h.html#ac4b206a51636d91c5cffcbcee458c3cbaf06ec36087996d6f328df39866ff5de6">SPI_MODE_3</a>)</td></tr>
<tr class="memdesc:ab3d553cb6ad796c81cf8da03fd162410"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI mode 3.  <br /></td></tr>
<tr class="separator:ab3d553cb6ad796c81cf8da03fd162410"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a2eaa9ef4b5bdf3048b6a942462ad1ec1" id="r_a2eaa9ef4b5bdf3048b6a942462ad1ec1"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2eaa9ef4b5bdf3048b6a942462ad1ec1">hal_spi_txrx_cb</a>) (void *arg, int len)</td></tr>
<tr class="memdesc:a2eaa9ef4b5bdf3048b6a942462ad1ec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prototype for tx/rx callback.  <br /></td></tr>
<tr class="separator:a2eaa9ef4b5bdf3048b6a942462ad1ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8546bc1ec3e14eabc80bb56319d6628e" id="r_a8546bc1ec3e14eabc80bb56319d6628e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8546bc1ec3e14eabc80bb56319d6628e">hal_spi_config</a> (int spi_num, struct <a class="el" href="structhal__spi__settings.html">hal_spi_settings</a> *psettings)</td></tr>
<tr class="memdesc:a8546bc1ec3e14eabc80bb56319d6628e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the spi.  <br /></td></tr>
<tr class="separator:a8546bc1ec3e14eabc80bb56319d6628e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa87db99ce986ed1b1385590cea1f32a8" id="r_aa87db99ce986ed1b1385590cea1f32a8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa87db99ce986ed1b1385590cea1f32a8">hal_spi_set_txrx_cb</a> (int spi_num, <a class="el" href="#a2eaa9ef4b5bdf3048b6a942462ad1ec1">hal_spi_txrx_cb</a> txrx_cb, void *arg)</td></tr>
<tr class="memdesc:aa87db99ce986ed1b1385590cea1f32a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the txrx callback (executed at interrupt context) when the buffer is transferred by the master or the slave using the non-blocking API.  <br /></td></tr>
<tr class="separator:aa87db99ce986ed1b1385590cea1f32a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac20b051b9e98152804dd0801a57f1360" id="r_ac20b051b9e98152804dd0801a57f1360"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac20b051b9e98152804dd0801a57f1360">hal_spi_enable</a> (int spi_num)</td></tr>
<tr class="memdesc:ac20b051b9e98152804dd0801a57f1360"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the SPI.  <br /></td></tr>
<tr class="separator:ac20b051b9e98152804dd0801a57f1360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2fca841a1ac4dd055e6247449bf45ab" id="r_ae2fca841a1ac4dd055e6247449bf45ab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2fca841a1ac4dd055e6247449bf45ab">hal_spi_disable</a> (int spi_num)</td></tr>
<tr class="memdesc:ae2fca841a1ac4dd055e6247449bf45ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the SPI.  <br /></td></tr>
<tr class="separator:ae2fca841a1ac4dd055e6247449bf45ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a553da06a116ddadf0df93343f51f1432" id="r_a553da06a116ddadf0df93343f51f1432"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a553da06a116ddadf0df93343f51f1432">hal_spi_txrx</a> (int spi_num, void *txbuf, void *rxbuf, int cnt)</td></tr>
<tr class="memdesc:a553da06a116ddadf0df93343f51f1432"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking interface to send a buffer and store the received values from the slave.  <br /></td></tr>
<tr class="separator:a553da06a116ddadf0df93343f51f1432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af63f67ca8a93d7c93061565e9be1385b" id="r_af63f67ca8a93d7c93061565e9be1385b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af63f67ca8a93d7c93061565e9be1385b">hal_spi_txrx_noblock</a> (int spi_num, void *txbuf, void *rxbuf, int cnt)</td></tr>
<tr class="memdesc:af63f67ca8a93d7c93061565e9be1385b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking interface to send a buffer and store received values.  <br /></td></tr>
<tr class="separator:af63f67ca8a93d7c93061565e9be1385b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="af269bbeaf787deae7de03b7e1c8ede4f" name="af269bbeaf787deae7de03b7e1c8ede4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af269bbeaf787deae7de03b7e1c8ede4f">&#9670;&#160;</a></span>HAL_SPI_MODE0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HAL_SPI_MODE0&#160;&#160;&#160;(<a class="el" href="msp430_2include_2f2xx__g2xx_2periph__cpu_8h.html#ac4b206a51636d91c5cffcbcee458c3cba152359b11fb4b43ed0c5485eb0ab0673">SPI_MODE_0</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SPI mode 0. </p>

<p class="definition">Definition at line <a class="el" href="hal__spi_8h_source.html#l00030">30</a> of file <a class="el" href="hal__spi_8h_source.html">hal_spi.h</a>.</p>

</div>
</div>
<a id="aa4fae1c5b56c54e8bb905d4774b6c21e" name="aa4fae1c5b56c54e8bb905d4774b6c21e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4fae1c5b56c54e8bb905d4774b6c21e">&#9670;&#160;</a></span>HAL_SPI_MODE1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HAL_SPI_MODE1&#160;&#160;&#160;(<a class="el" href="msp430_2include_2f2xx__g2xx_2periph__cpu_8h.html#ac4b206a51636d91c5cffcbcee458c3cba7c1990cc15e9d69621be8e0e757e634c">SPI_MODE_1</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SPI mode 1. </p>

<p class="definition">Definition at line <a class="el" href="hal__spi_8h_source.html#l00032">32</a> of file <a class="el" href="hal__spi_8h_source.html">hal_spi.h</a>.</p>

</div>
</div>
<a id="a9a4f7a6b535bf91c6d9eadc94876b3ab" name="a9a4f7a6b535bf91c6d9eadc94876b3ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a4f7a6b535bf91c6d9eadc94876b3ab">&#9670;&#160;</a></span>HAL_SPI_MODE2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HAL_SPI_MODE2&#160;&#160;&#160;(<a class="el" href="msp430_2include_2f2xx__g2xx_2periph__cpu_8h.html#ac4b206a51636d91c5cffcbcee458c3cba4d350945d895a4acdc45ae96b0b82fc3">SPI_MODE_2</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SPI mode 2. </p>

<p class="definition">Definition at line <a class="el" href="hal__spi_8h_source.html#l00034">34</a> of file <a class="el" href="hal__spi_8h_source.html">hal_spi.h</a>.</p>

</div>
</div>
<a id="ab3d553cb6ad796c81cf8da03fd162410" name="ab3d553cb6ad796c81cf8da03fd162410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3d553cb6ad796c81cf8da03fd162410">&#9670;&#160;</a></span>HAL_SPI_MODE3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HAL_SPI_MODE3&#160;&#160;&#160;(<a class="el" href="msp430_2include_2f2xx__g2xx_2periph__cpu_8h.html#ac4b206a51636d91c5cffcbcee458c3cbaf06ec36087996d6f328df39866ff5de6">SPI_MODE_3</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SPI mode 3. </p>

<p class="definition">Definition at line <a class="el" href="hal__spi_8h_source.html#l00036">36</a> of file <a class="el" href="hal__spi_8h_source.html">hal_spi.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a2eaa9ef4b5bdf3048b6a942462ad1ec1" name="a2eaa9ef4b5bdf3048b6a942462ad1ec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eaa9ef4b5bdf3048b6a942462ad1ec1">&#9670;&#160;</a></span>hal_spi_txrx_cb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* hal_spi_txrx_cb) (void *arg, int len)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prototype for tx/rx callback. </p>

<p class="definition">Definition at line <a class="el" href="hal__spi_8h_source.html#l00041">41</a> of file <a class="el" href="hal__spi_8h_source.html">hal_spi.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a8546bc1ec3e14eabc80bb56319d6628e" name="a8546bc1ec3e14eabc80bb56319d6628e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8546bc1ec3e14eabc80bb56319d6628e">&#9670;&#160;</a></span>hal_spi_config()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hal_spi_config </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>spi_num</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structhal__spi__settings.html">hal_spi_settings</a> *</td>          <td class="paramname"><span class="paramname"><em>psettings</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the spi. </p>
<p>Must be called after the spi is initialized (after hal_spi_init is called) and when the spi is disabled (user must call hal_spi_disable if the spi has been enabled through hal_spi_enable prior to calling this function). Can also be used to reconfigure an initialized SPI (assuming it is disabled as described previously).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spi_num</td><td>The number of the SPI to configure. </td></tr>
    <tr><td class="paramname">psettings</td><td>The settings to configure this SPI with</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0 on success, non-zero error code on failure. </dd></dl>

</div>
</div>
<a id="ae2fca841a1ac4dd055e6247449bf45ab" name="ae2fca841a1ac4dd055e6247449bf45ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2fca841a1ac4dd055e6247449bf45ab">&#9670;&#160;</a></span>hal_spi_disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hal_spi_disable </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>spi_num</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables the SPI. </p>
<p>Used for power mgmt. It will halt any current SPI transfers in progress.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spi_num</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0 on success, non-zero error code on failure. </dd></dl>

</div>
</div>
<a id="ac20b051b9e98152804dd0801a57f1360" name="ac20b051b9e98152804dd0801a57f1360"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac20b051b9e98152804dd0801a57f1360">&#9670;&#160;</a></span>hal_spi_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hal_spi_enable </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>spi_num</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the SPI. </p>
<p>This does not start a transmit or receive operation; it is used for power mgmt. Cannot be called when a SPI transfer is in progress.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spi_num</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0 on success, non-zero error code on failure. </dd></dl>

</div>
</div>
<a id="aa87db99ce986ed1b1385590cea1f32a8" name="aa87db99ce986ed1b1385590cea1f32a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa87db99ce986ed1b1385590cea1f32a8">&#9670;&#160;</a></span>hal_spi_set_txrx_cb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hal_spi_set_txrx_cb </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>spi_num</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a2eaa9ef4b5bdf3048b6a942462ad1ec1">hal_spi_txrx_cb</a></td>          <td class="paramname"><span class="paramname"><em>txrx_cb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the txrx callback (executed at interrupt context) when the buffer is transferred by the master or the slave using the non-blocking API. </p>
<p>Cannot be called when the spi is enabled. This callback will also be called when chip select is de-asserted on the slave.</p>
<p>NOTE: This callback is only used for the non-blocking interface and must be called prior to using the non-blocking API.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spi_num</td><td>SPI interface on which to set callback </td></tr>
    <tr><td class="paramname">txrx_cb</td><td>Callback function </td></tr>
    <tr><td class="paramname">arg</td><td>Argument to be passed to callback function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0 on success, non-zero error code on failure. </dd></dl>

</div>
</div>
<a id="a553da06a116ddadf0df93343f51f1432" name="a553da06a116ddadf0df93343f51f1432"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a553da06a116ddadf0df93343f51f1432">&#9670;&#160;</a></span>hal_spi_txrx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hal_spi_txrx </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>spi_num</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>txbuf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>rxbuf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>cnt</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocking interface to send a buffer and store the received values from the slave. </p>
<p>The transmit and receive buffers are either arrays of 8-bit (uint8_t) values or 16-bit values depending on whether the spi is configured for 8 bit data or more than 8 bits per value. The 'cnt' parameter is the number of 8-bit or 16-bit values. Thus, if 'cnt' is 10, txbuf/rxbuf would point to an array of size 10 (in bytes) if the SPI is using 8-bit data; otherwise txbuf/rxbuf would point to an array of size 20 bytes (ten, uint16_t values).</p>
<p>NOTE: these buffers are in the native endian-ness of the platform. </p><pre class="fragment">MASTER: master sends all the values in the buffer and stores the
        stores the values in the receive buffer if rxbuf is not NULL.
        The txbuf parameter cannot be NULL.
SLAVE: cannot be called for a slave; returns -1
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spi_num</td><td>SPI interface to use </td></tr>
    <tr><td class="paramname">txbuf</td><td>Pointer to buffer where values to transmit are stored. </td></tr>
    <tr><td class="paramname">rxbuf</td><td>Pointer to buffer to store values received from peer. </td></tr>
    <tr><td class="paramname">cnt</td><td>Number of 8-bit or 16-bit values to be transferred.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0 on success, non-zero error code on failure. </dd></dl>

</div>
</div>
<a id="af63f67ca8a93d7c93061565e9be1385b" name="af63f67ca8a93d7c93061565e9be1385b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af63f67ca8a93d7c93061565e9be1385b">&#9670;&#160;</a></span>hal_spi_txrx_noblock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hal_spi_txrx_noblock </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>spi_num</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>txbuf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>rxbuf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>cnt</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Non-blocking interface to send a buffer and store received values. </p>
<p>Can be used for both master and slave SPI types. The user must configure the callback (using hal_spi_set_txrx_cb); the txrx callback is executed at interrupt context when the buffer is sent.</p>
<p>The transmit and receive buffers are either arrays of 8-bit (uint8_t) values or 16-bit values depending on whether the spi is configured for 8 bit data or more than 8 bits per value. The 'cnt' parameter is the number of 8-bit or 16-bit values. Thus, if 'cnt' is 10, txbuf/rxbuf would point to an array of size 10 (in bytes) if the SPI is using 8-bit data; otherwise txbuf/rxbuf would point to an array of size 20 bytes (ten, uint16_t values).</p>
<p>NOTE: these buffers are in the native endian-ness of the platform. </p><pre class="fragment">MASTER: master sends all the values in the buffer and stores the
        stores the values in the receive buffer if rxbuf is not NULL.
        The txbuf parameter cannot be NULL
SLAVE: Slave "preloads" the data to be sent to the master (values
       stored in txbuf) and places received data from master in rxbuf
       (if not NULL). The txrx callback occurs when len values are
       transferred or master de-asserts chip select. If txbuf is NULL,
       the slave transfers its default byte. Both rxbuf and txbuf cannot
       be NULL.
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spi_num</td><td>SPI interface to use </td></tr>
    <tr><td class="paramname">txbuf</td><td>Pointer to buffer where values to transmit are stored. </td></tr>
    <tr><td class="paramname">rxbuf</td><td>Pointer to buffer to store values received from peer. </td></tr>
    <tr><td class="paramname">cnt</td><td>Number of 8-bit or 16-bit values to be transferred.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0 on success, non-zero error code on failure. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->

    </div>
  </body>
</html>
