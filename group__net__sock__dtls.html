<!DOCTYPE html>
<html lang="en">
  <head>
    <link rel="icon" type="image/png" href="favicon.png">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <title>DTLS sock API</title>
    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="jquery.min.js"></script>
    <script src="jquery.powertip.min.js"></script>
    <script src="jquery-ui.min.js"></script>
    <script src="jquery.scrollTo.min.js"></script>
    <script src="doxy-jquery.js"></script>
    <script src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <!-- Bootstrap -->
    <link href="doxygen.css" rel="stylesheet">
    <link href="fonts.css" rel="stylesheet">
    <link href="bootstrap.min.css" rel="stylesheet">
    <link href="jquery.smartmenus.bootstrap.css" rel="stylesheet">
    <link href="riot.css" rel="stylesheet">
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
        <script>
            function displaySR(){
            searchBox.Search();
            var rhtml=(document.getElementById('MSearchResults').contentWindow.document.body.innerHTML).replace(/href=\"\.\.\//g,'href="');
            document.getElementById('MSearchResultsWindow').style.display='none';
            document.getElementById('top').append(document.getElementById('MSearchSelectWindow'));
            document.getElementById('top').append(document.getElementById('MSearchResultsWindow'));
            document.getElementById('doc-content').innerHTML=rhtml;
            }
            function modSearch(){
            if(!searchBox.doxySearch){
                searchBox.doxySearch=searchBox.Search
                searchBox.Search= function(){this.doxySearch();
                var r=document.getElementById('MSearchResultsWindow');console.log(r.style);
                if(parseInt(r.style.left)<0)r.style.left=0;
                var x=document.getElementById('MSearchResults');
                if(x.scrollWidth>window.screen.width)x.style.width=window.screen.width-2+'px';
                var f=document.getElementById('riot-searchform');
                if(parseInt( r.style.top) < f.offsetTop+f.scrollHeight) r.style.top = f.offsetTop+f.scrollHeight+'px';}
            }
            }
        </script>
  </head>
  <body>
      <div id="top">
        <nav class="navbar navbar-inverse">
          <div class="container-fluid">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header">
              <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse" aria-expanded="false">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              <a class="navbar-brand" id="brand-logo" href="http://riot-os.org"><img height="40px" src="riot-logo.svg" /></a>
              <p class="navbar-text text-center visible-xs">Documentation</p>
            </div>
            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="" id="navbar-collapse">
              <p class="navbar-text navbar-left"><span id="projectbrief">The friendly Operating System for the Internet of Things</span></p>
              <ul id="riot-navlist" class="nav navbar-nav"></ul>
                <div class="navbar-form navbar-right" style="background-color: white;"></div>
              <link href="/pagefind/pagefind-ui.css" rel="stylesheet">
              <script src="/pagefind/pagefind-ui.js"></script>
              <div id="search">
              </div>
                <script>
                  window.addEventListener('DOMContentLoaded', (event) => {
                      new PagefindUI({ element: "#search", showSubResults: true });
                  });
              </script>
              </div>
              </div>
            </div><!-- /.navbar-collapse -->
          </div><!-- /.container-fluid -->
        </nav>
      </div>
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('group__net__sock__dtls.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Topics</a> &#124;
<a href="#files">Files</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">DTLS sock API<div class="ingroups"><a class="el" href="group__net.html">Networking</a> &raquo; <a class="el" href="group__net__sock.html">Sock API</a> &#124; <a class="el" href="group__net.html">Networking</a> &raquo; <a class="el" href="group__net__dtls.html">DTLS</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Sock submodule for DTLS  
<a href="#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Sock submodule for DTLS </p>
<p>DTLS sock acts as a wrapper for the underlying DTLS module to provide encryption for applications using the UDP sock API.</p>
<h2><a class="anchor" id="autotoc_md2072"></a>
How To Use</h2>
<h3><a class="anchor" id="autotoc_md2073"></a>
Summary</h3>
<ul>
<li>Include module implementing the DTLS sock API in the Makefile</li>
<li>Add credentials<ol type="1">
<li>Fill <a class="el" href="structcredman__credential__t.html" title="Credential information.">credman_credential_t</a> with the credential information</li>
<li>Add the credential using <a class="el" href="group__net__credman.html#ga541badb0086366236a741db3f50eb3dc">credman_add()</a></li>
</ol>
</li>
<li>Server operation<ol type="1">
<li>Create UDP sock <a class="el" href="group__net__sock__udp.html#ga20fa4b890dff1c97a63075090e6f9d7d">sock_udp_create()</a></li>
<li>Create DTLS sock sock_dtls_create() using role <a class="el" href="#ggacef31600358009411b6fcea11ebe07f6af8548d1d8748a66e59667582bed23a17">SOCK_DTLS_SERVER</a>.</li>
<li>Optionally:<ul>
<li>when using PSK ciphersuites, set a hint <a class="el" href="group__net__sock__dtls__creds.html#ga0023a4097d185cd6ee21e5097f51a49a">sock_dtls_set_server_psk_id_hint()</a></li>
<li>add extra credentials <a class="el" href="group__net__sock__dtls__creds.html#gae9388932dba7c8ade1245ff296e810f7">sock_dtls_add_credential()</a></li>
<li>when using ECC ciphersuites, set a callback for credential selection <a class="el" href="group__net__sock__dtls__creds.html#ga7524206606ab503113c5ffa83df1a2af">sock_dtls_set_rpk_cb()</a></li>
</ul>
</li>
<li>Start listening with <a class="el" href="#ga893395d4c18709210d66d979a2f9ea69">sock_dtls_recv()</a></li>
</ol>
</li>
<li>Client operation<ol type="1">
<li>Create UDP sock <a class="el" href="group__net__sock__udp.html#ga20fa4b890dff1c97a63075090e6f9d7d">sock_udp_create()</a></li>
<li>Create DTLS sock sock_dtls_create() using role <a class="el" href="#ggacef31600358009411b6fcea11ebe07f6a5d0ebcac70c848b4c09c9a35e40cfdaf">SOCK_DTLS_CLIENT</a></li>
<li>Optionally:<ul>
<li>add extra credentials <a class="el" href="group__net__sock__dtls__creds.html#gae9388932dba7c8ade1245ff296e810f7">sock_dtls_add_credential()</a></li>
<li>when using PSK ciphersuites, set a callback for hint reception and credential selection <a class="el" href="group__net__sock__dtls__creds.html#ga14d2d11e9dcf19049f330ad5c667580e">sock_dtls_set_client_psk_cb()</a></li>
<li>when using ECC ciphersuites, set a callback for credential selection <a class="el" href="group__net__sock__dtls__creds.html#ga7524206606ab503113c5ffa83df1a2af">sock_dtls_set_rpk_cb()</a></li>
</ul>
</li>
<li>Start handshake session to server <a class="el" href="#ga6ebde4fba6fd184710d1ec1c6285e7a2">sock_dtls_session_init()</a></li>
<li>Handle incoming handshake packets with <a class="el" href="#ga893395d4c18709210d66d979a2f9ea69">sock_dtls_recv()</a></li>
<li>Send packet to server <a class="el" href="#ga630360b12614e2b57fca0cd81cdf9e4e">sock_dtls_send()</a></li>
</ol>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md2074"></a>
Makefile Includes</h2>
<p>First, we need to <a class="el" href="creating-an-application.html#including-modules">include</a> a module that implements this API in our applications Makefile. For example the module that implements this API for <a class="el" href="group__pkg__tinydtls.html">tinydtls</a> is called &lsquo;tinydtls_sock_dtls&rsquo;.</p>
<p>The corresponding <a class="el" href="group__pkg.html">pkg</a> providing the DTLS implementation will be automatically included so there is no need to use <code>USEPKG</code> to add the pkg manually.</p>
<p>Each DTLS implementation may have its own configuration options and caveat. This can be found at <a class="el" href="group__net__dtls.html">DTLS</a>.</p>
<h3><a class="anchor" id="autotoc_md2075"></a>
Adding credentials</h3>
<p>Before using this API, either as a server or a client, we first need to add the credentials to be used for the encryption using <a class="el" href="group__net__credman.html">credman</a>. Note that credman does not copy the credentials given into the system, it only has information about the credentials and where it is located at. So it is your responsibility to make sure that the credential is valid during the lifetime of your application.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="stdio_8h.html">stdio.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="credman_8h.html">net/credman.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define SOCK_DTLS_SERVER_TAG (10)</span></div>
<div class="line"><span class="preprocessor">#define SOCK_DTLS_CLIENT_TAG (20)</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">char</span> *psk_key = <span class="stringliteral">&quot;secretPSK&quot;</span>;</div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">char</span> *psk_id = <span class="stringliteral">&quot;secretID&quot;</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> server_ecdsa_priv_key[] = {...};</div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> server_ecdsa_pub_key_x[] = {...};</div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> server_ecdsa_pub_key_y[] = {...};</div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> client_pubkey_x[] = {...};</div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> client_pubkey_y[] = {...};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <a class="code hl_struct" href="structecdsa__public__key__t.html">ecdsa_public_key_t</a> other_pubkeys[] = {</div>
<div class="line">    { .x = client_pubkey_x, .y = client_pubkey_y },</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_struct" href="structcredman__credential__t.html">credman_credential_t</a> psk_credential = {</div>
<div class="line">        .type = <a class="code hl_enumvalue" href="group__net__credman.html#gga9b3a1809012813b046937832b80a4ffdadec85d3ad6545265cb1cef0165a8aec3">CREDMAN_TYPE_PSK</a>,</div>
<div class="line">        .tag = SOCK_DTLS_SERVER_TAG,</div>
<div class="line">        .params = {</div>
<div class="line">            .psk = {</div>
<div class="line">                .key = { .s = psk_key, .len = <span class="keyword">sizeof</span>(psk_key), },</div>
<div class="line">                .id = { .s = psk_id, .len = <span class="keyword">sizeof</span>(psk_id), },</div>
<div class="line">            },</div>
<div class="line">        },</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code hl_function" href="group__net__credman.html#ga541badb0086366236a741db3f50eb3dc">credman_add</a>(&amp;psk_credential) &lt; 0) {</div>
<div class="line">        puts(<span class="stringliteral">&quot;Error cannot add credential&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_struct" href="structcredman__credential__t.html">credman_credential_t</a> ecc_credential = {</div>
<div class="line">        .type = <a class="code hl_enumvalue" href="group__net__credman.html#gga9b3a1809012813b046937832b80a4ffda79be505817e87b093027825c8cf6e2e7">CREDMAN_TYPE_ECDSA</a>,</div>
<div class="line">        .tag = SOCK_DTLS_SERVER_TAG,</div>
<div class="line">        .params = {</div>
<div class="line">            .ecdsa = {</div>
<div class="line">                .private_key = server_ecdsa_priv_key,</div>
<div class="line">                .public_key = {</div>
<div class="line">                    .x = server_ecdsa_pub_key_x,</div>
<div class="line">                    .y = server_ecdsa_pub_key_y,</div>
<div class="line">                },</div>
<div class="line">                .client_keys = other_pubkeys,</div>
<div class="line">                .client_keys_size = <a class="code hl_define" href="container_8h.html#a25f003de16c08a4888b69f619d70f427">ARRAY_SIZE</a>(other_pubkeys),</div>
<div class="line">            },</div>
<div class="line">        },</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code hl_function" href="group__net__credman.html#ga541badb0086366236a741db3f50eb3dc">credman_add</a>(&amp;ecc_credential) &lt; 0) {</div>
<div class="line">        puts(<span class="stringliteral">&quot;Error cannot add credential&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// start server/client</span></div>
<div class="line">    <span class="comment">// [...]</span></div>
<div class="line">}</div>
<div class="ttc" id="acontainer_8h_html_a25f003de16c08a4888b69f619d70f427"><div class="ttname"><a href="container_8h.html#a25f003de16c08a4888b69f619d70f427">ARRAY_SIZE</a></div><div class="ttdeci">#define ARRAY_SIZE(a)</div><div class="ttdoc">Calculate the number of elements in a static array.</div><div class="ttdef"><b>Definition</b> <a href="container_8h_source.html#l00083">container.h:83</a></div></div>
<div class="ttc" id="acredman_8h_html"><div class="ttname"><a href="credman_8h.html">credman.h</a></div><div class="ttdoc">(D)TLS credentials management module definitions</div></div>
<div class="ttc" id="agroup__net__credman_html_ga541badb0086366236a741db3f50eb3dc"><div class="ttname"><a href="group__net__credman.html#ga541badb0086366236a741db3f50eb3dc">credman_add</a></div><div class="ttdeci">int credman_add(const credman_credential_t *credential)</div><div class="ttdoc">Adds a credential to the credential pool.</div></div>
<div class="ttc" id="agroup__net__credman_html_gga9b3a1809012813b046937832b80a4ffda79be505817e87b093027825c8cf6e2e7"><div class="ttname"><a href="group__net__credman.html#gga9b3a1809012813b046937832b80a4ffda79be505817e87b093027825c8cf6e2e7">CREDMAN_TYPE_ECDSA</a></div><div class="ttdeci">@ CREDMAN_TYPE_ECDSA</div><div class="ttdoc">ECDSA credential type.</div><div class="ttdef"><b>Definition</b> <a href="credman_8h_source.html#l00114">credman.h:114</a></div></div>
<div class="ttc" id="agroup__net__credman_html_gga9b3a1809012813b046937832b80a4ffdadec85d3ad6545265cb1cef0165a8aec3"><div class="ttname"><a href="group__net__credman.html#gga9b3a1809012813b046937832b80a4ffdadec85d3ad6545265cb1cef0165a8aec3">CREDMAN_TYPE_PSK</a></div><div class="ttdeci">@ CREDMAN_TYPE_PSK</div><div class="ttdoc">PSK credential type.</div><div class="ttdef"><b>Definition</b> <a href="credman_8h_source.html#l00113">credman.h:113</a></div></div>
<div class="ttc" id="astdio_8h_html"><div class="ttname"><a href="stdio_8h.html">stdio.h</a></div><div class="ttdoc">stdio wrapper to extend the C libs stdio</div></div>
<div class="ttc" id="astructcredman__credential__t_html"><div class="ttname"><a href="structcredman__credential__t.html">credman_credential_t</a></div><div class="ttdoc">Credential information.</div><div class="ttdef"><b>Definition</b> <a href="credman_8h_source.html#l00120">credman.h:120</a></div></div>
<div class="ttc" id="astructecdsa__public__key__t_html"><div class="ttname"><a href="structecdsa__public__key__t.html">ecdsa_public_key_t</a></div><div class="ttdoc">ECDSA public keys.</div><div class="ttdef"><b>Definition</b> <a href="credman_8h_source.html#l00078">credman.h:78</a></div></div>
</div><!-- fragment --><p>Above we see an example of how to register a PSK and an ECC credential.</p>
<p>First, we need to include the header file for the API.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="credman_8h.html">net/credman.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_struct" href="structcredman__credential__t.html">credman_credential_t</a> psk_credential = {</div>
<div class="line">        .type = <a class="code hl_enumvalue" href="group__net__credman.html#gga9b3a1809012813b046937832b80a4ffdadec85d3ad6545265cb1cef0165a8aec3">CREDMAN_TYPE_PSK</a>,</div>
<div class="line">        .tag = SOCK_DTLS_SERVER_TAG,</div>
<div class="line">        .params = {</div>
<div class="line">            .psk = {</div>
<div class="line">                .key = { .s = psk_key, .len = <span class="keyword">sizeof</span>(psk_key), },</div>
<div class="line">                .id = { .s = psk_id, .len = <span class="keyword">sizeof</span>(psk_id), },</div>
<div class="line">            },</div>
<div class="line">        },</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    [...]</div>
<div class="line">}</div>
</div><!-- fragment --><p>We tell <a class="el" href="group__net__credman.html">credman</a> which credential to add by filling in the credentials information in a struct <a class="el" href="structcredman__credential__t.html">credman_credential_t</a>. For PSK credentials, we use enum <a class="el" href="group__net__credman.html#gga9b3a1809012813b046937832b80a4ffdadec85d3ad6545265cb1cef0165a8aec3">CREDMAN_TYPE_PSK</a> for the <a class="el" href="structcredman__credential__t.html#a528287ec61d5a9eb2dbae51470102701">type</a>.</p>
<p>Next, we must assign a <a class="el" href="group__net__credman.html#ga89fc115fe10d879da7faf1c0d0f901a7">tag</a> for the credential. Tags are unsigned integer values used to identify which DTLS sock has access to which credentials. Each DTLS sock will also be assigned a list of tags. As a result, a sock can only use credentials that have the same tag as the ones in the list.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="group__net__credman.html#ga541badb0086366236a741db3f50eb3dc">credman_add</a>(&amp;psk_credential) &lt; 0) {</div>
<div class="line">    puts(<span class="stringliteral">&quot;Error cannot add credential&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><p>After credential information is filled, we can add it to the credential pool using <a class="el" href="group__net__credman.html#ga541badb0086366236a741db3f50eb3dc">credman_add()</a>.</p>
<p>For adding credentials of other types, you can follow the steps above except <a class="el" href="structcredman__credential__t.html#a528287ec61d5a9eb2dbae51470102701" title="Type of the credential.">credman_credential_t::type</a> and <a class="el" href="structcredman__credential__t.html#a88361bff5ce2f9f08e2c09f8ec91cfa5" title="Credential parameters.">credman_credential_t::params</a> depend on the type of credential used.</p>
<h3><a class="anchor" id="autotoc_md2076"></a>
Server Operation</h3>
<p>After credentials are added, we can start the server.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="stdio_8h.html">stdio.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="sock_2dtls_8h.html">net/sock/dtls.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define SOCK_DTLS_SERVER_TAG (10)</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Add credentials</span></div>
<div class="line">    <span class="comment">// [...]</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// initialize server</span></div>
<div class="line">    <a class="code hl_struct" href="structsock__udp.html">sock_udp_t</a> udp_sock;</div>
<div class="line">    <a class="code hl_struct" href="struct__sock__tl__ep.html">sock_udp_ep_t</a> local = <a class="code hl_define" href="group__net__sock.html#ga3f10e5b714c03824d6dc4fff5d372b8f">SOCK_IPV6_EP_ANY</a>;</div>
<div class="line">    local.<a class="code hl_variable" href="struct__sock__tl__ep.html#a00b5dbff09ee8e87806fff6280966140">port</a> = 20220;</div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code hl_function" href="group__net__sock__udp.html#ga20fa4b890dff1c97a63075090e6f9d7d">sock_udp_create</a>(&amp;udp_sock, &amp;local, NULL, 0) &lt; 0) {</div>
<div class="line">        puts(<span class="stringliteral">&quot;Error creating UDP sock&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> -1;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_struct" href="structsock__dtls.html">sock_dtls_t</a> dtls_sock;</div>
<div class="line">    <span class="keywordflow">if</span> (sock_dtls_create(&amp;dtls_sock, &amp;udp_sock,</div>
<div class="line">                         SOCK_DTLS_SERVER_TAG,</div>
<div class="line">                         <a class="code hl_enumvalue" href="#gga0c6a8ceda748c82eca58fbab436ca300a3d86ab5555dcad0072067eeca3db9696">SOCK_DTLS_1_2</a>, <a class="code hl_enumvalue" href="#ggacef31600358009411b6fcea11ebe07f6af8548d1d8748a66e59667582bed23a17">SOCK_DTLS_SERVER</a>) &lt; 0) {</div>
<div class="line">        puts(<span class="stringliteral">&quot;Error creating DTLS sock&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> -1;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">while</span> (1) {</div>
<div class="line">        <span class="keywordtype">int</span> res;</div>
<div class="line">        <span class="keywordtype">char</span> buf[128];</div>
<div class="line">        <a class="code hl_struct" href="structsock__dtls__session.html">sock_dtls_session_t</a> session;</div>
<div class="line"> </div>
<div class="line">        res = <a class="code hl_function" href="#ga893395d4c18709210d66d979a2f9ea69">sock_dtls_recv</a>(&amp;dtls_sock, &amp;session, buf, <span class="keyword">sizeof</span>(buf),</div>
<div class="line">                             <a class="code hl_define" href="group__net__sock.html#gaf0c954b49c306f6c125d25ddba9f352e">SOCK_NO_TIMEOUT</a>);</div>
<div class="line">        <span class="keywordflow">if</span> (res &gt; 0) {</div>
<div class="line">            <a class="code hl_define" href="group__cpu__avr8__common__stdio__wrapper.html#gad2eb277496af160238e7306fff780ad2">printf</a>(<span class="stringliteral">&quot;Received %d bytes\n&quot;</span>, res);</div>
<div class="line">            <span class="keywordflow">if</span> (<a class="code hl_function" href="#ga630360b12614e2b57fca0cd81cdf9e4e">sock_dtls_send</a>(&amp;dtls_sock, &amp;session, buf, res) &lt; 0) {</div>
<div class="line">                puts(<span class="stringliteral">&quot;Error sending reply&quot;</span>);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__cpu__avr8__common__stdio__wrapper_html_gad2eb277496af160238e7306fff780ad2"><div class="ttname"><a href="group__cpu__avr8__common__stdio__wrapper.html#gad2eb277496af160238e7306fff780ad2">printf</a></div><div class="ttdeci">#define printf(...)</div><div class="ttdoc">A wrapper for the printf() function that passes arguments through unmodified, but fails to compile if...</div><div class="ttdef"><b>Definition</b> <a href="stdio_8h_source.html#l00060">stdio.h:60</a></div></div>
<div class="ttc" id="agroup__net__sock__dtls_html_ga630360b12614e2b57fca0cd81cdf9e4e"><div class="ttname"><a href="#ga630360b12614e2b57fca0cd81cdf9e4e">sock_dtls_send</a></div><div class="ttdeci">static ssize_t sock_dtls_send(sock_dtls_t *sock, sock_dtls_session_t *remote, const void *data, size_t len, uint32_t timeout)</div><div class="ttdoc">Encrypts and sends a message to a remote peer.</div><div class="ttdef"><b>Definition</b> <a href="sock_2dtls_8h_source.html#l01049">dtls.h:1049</a></div></div>
<div class="ttc" id="agroup__net__sock__dtls_html_ga893395d4c18709210d66d979a2f9ea69"><div class="ttname"><a href="#ga893395d4c18709210d66d979a2f9ea69">sock_dtls_recv</a></div><div class="ttdeci">static ssize_t sock_dtls_recv(sock_dtls_t *sock, sock_dtls_session_t *remote, void *data, size_t maxlen, uint32_t timeout)</div><div class="ttdoc">Receive handshake messages and application data from remote peer.</div><div class="ttdef"><b>Definition</b> <a href="sock_2dtls_8h_source.html#l00821">dtls.h:821</a></div></div>
<div class="ttc" id="agroup__net__sock__dtls_html_gga0c6a8ceda748c82eca58fbab436ca300a3d86ab5555dcad0072067eeca3db9696"><div class="ttname"><a href="#gga0c6a8ceda748c82eca58fbab436ca300a3d86ab5555dcad0072067eeca3db9696">SOCK_DTLS_1_2</a></div><div class="ttdeci">@ SOCK_DTLS_1_2</div><div class="ttdoc">DTLS version 1.2.</div><div class="ttdef"><b>Definition</b> <a href="sock_2dtls_8h_source.html#l00605">dtls.h:605</a></div></div>
<div class="ttc" id="agroup__net__sock__dtls_html_ggacef31600358009411b6fcea11ebe07f6af8548d1d8748a66e59667582bed23a17"><div class="ttname"><a href="#ggacef31600358009411b6fcea11ebe07f6af8548d1d8748a66e59667582bed23a17">SOCK_DTLS_SERVER</a></div><div class="ttdeci">@ SOCK_DTLS_SERVER</div><div class="ttdoc">Endpoint server role.</div><div class="ttdef"><b>Definition</b> <a href="sock_2dtls_8h_source.html#l00617">dtls.h:617</a></div></div>
<div class="ttc" id="agroup__net__sock__udp_html_ga20fa4b890dff1c97a63075090e6f9d7d"><div class="ttname"><a href="group__net__sock__udp.html#ga20fa4b890dff1c97a63075090e6f9d7d">sock_udp_create</a></div><div class="ttdeci">int sock_udp_create(sock_udp_t *sock, const sock_udp_ep_t *local, const sock_udp_ep_t *remote, uint16_t flags)</div><div class="ttdoc">Creates a new UDP sock object.</div></div>
<div class="ttc" id="agroup__net__sock_html_ga3f10e5b714c03824d6dc4fff5d372b8f"><div class="ttname"><a href="group__net__sock.html#ga3f10e5b714c03824d6dc4fff5d372b8f">SOCK_IPV6_EP_ANY</a></div><div class="ttdeci">#define SOCK_IPV6_EP_ANY</div><div class="ttdoc">Address to bind to any IPv6 address.</div><div class="ttdef"><b>Definition</b> <a href="sock_8h_source.html#l00166">sock.h:166</a></div></div>
<div class="ttc" id="agroup__net__sock_html_gaf0c954b49c306f6c125d25ddba9f352e"><div class="ttname"><a href="group__net__sock.html#gaf0c954b49c306f6c125d25ddba9f352e">SOCK_NO_TIMEOUT</a></div><div class="ttdeci">#define SOCK_NO_TIMEOUT</div><div class="ttdoc">Special value meaning &quot;wait forever&quot; (don't timeout)</div><div class="ttdef"><b>Definition</b> <a href="sock_8h_source.html#l00173">sock.h:173</a></div></div>
<div class="ttc" id="asock_2dtls_8h_html"><div class="ttname"><a href="sock_2dtls_8h.html">dtls.h</a></div><div class="ttdoc">DTLS sock definitions.</div></div>
<div class="ttc" id="astruct__sock__tl__ep_html"><div class="ttname"><a href="struct__sock__tl__ep.html">_sock_tl_ep</a></div><div class="ttdoc">Common IP-based transport layer end point.</div><div class="ttdef"><b>Definition</b> <a href="sock_8h_source.html#l00215">sock.h:215</a></div></div>
<div class="ttc" id="astruct__sock__tl__ep_html_a00b5dbff09ee8e87806fff6280966140"><div class="ttname"><a href="struct__sock__tl__ep.html#a00b5dbff09ee8e87806fff6280966140">_sock_tl_ep::port</a></div><div class="ttdeci">uint16_t port</div><div class="ttdoc">transport layer port (in host byte order)</div><div class="ttdef"><b>Definition</b> <a href="sock_8h_source.html#l00247">sock.h:247</a></div></div>
<div class="ttc" id="astructsock__dtls__session_html"><div class="ttname"><a href="structsock__dtls__session.html">sock_dtls_session</a></div><div class="ttdoc">Information about remote client connected to the server.</div><div class="ttdef"><b>Definition</b> <a href="sock__dtls__types_8h_source.html#l00089">sock_dtls_types.h:89</a></div></div>
<div class="ttc" id="astructsock__dtls_html"><div class="ttname"><a href="structsock__dtls.html">sock_dtls</a></div><div class="ttdoc">Information about DTLS sock.</div><div class="ttdef"><b>Definition</b> <a href="sock__dtls__types_8h_source.html#l00041">sock_dtls_types.h:41</a></div></div>
<div class="ttc" id="astructsock__udp_html"><div class="ttname"><a href="structsock__udp.html">sock_udp</a></div><div class="ttdoc">UDP sock type.</div><div class="ttdef"><b>Definition</b> <a href="pkg_2lwip_2include_2sock__types_8h_source.html#l00128">sock_types.h:128</a></div></div>
</div><!-- fragment --><p>This is an example of a DTLS echo server.</p>
<p>DTLS sock uses an initialized UDP sock to send and receive encrypted packets. Therefore, the listening port for the server also needs to be set here.</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structsock__udp.html">sock_udp_t</a> udp_sock;</div>
<div class="line"><a class="code hl_struct" href="struct__sock__tl__ep.html">sock_udp_ep_t</a> local = <a class="code hl_define" href="group__net__sock.html#ga3f10e5b714c03824d6dc4fff5d372b8f">SOCK_IPV6_EP_ANY</a>;</div>
<div class="line">local.<a class="code hl_variable" href="struct__sock__tl__ep.html#a00b5dbff09ee8e87806fff6280966140">port</a> = 20220;</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="group__net__sock__udp.html#ga20fa4b890dff1c97a63075090e6f9d7d">sock_udp_create</a>(&amp;udp_sock, &amp;local, NULL, 0) &lt; 0) {</div>
<div class="line">    puts(<span class="stringliteral">&quot;Error creating UDP sock&quot;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> -1;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Using the initialized UDP sock, we can then create our DTLS sock. We use SOCK_DTLS_SERVER_TAG, which is defined as <code>10</code> in our application code beforehand, as our tag. Using <a class="el" href="#gga0c6a8ceda748c82eca58fbab436ca300a3d86ab5555dcad0072067eeca3db9696">SOCK_DTLS_1_2</a> and <a class="el" href="#ggacef31600358009411b6fcea11ebe07f6af8548d1d8748a66e59667582bed23a17">SOCK_DTLS_SERVER</a>, we set our DTLS endpoint to use DTLS version 1.2 and act as a DTLS server.</p>
<p>Note that some DTLS implementation do not support earlier versions of DTLS. In this case, sock_dtls_create() will return an error. A list of supported DTLS version for each DTLS implementation can be found at this <a class="el" href="group__net__dtls.html">page</a>. In case of error, the program is stopped.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define SOCK_DTLS_SERVER_TAG (10)</span></div>
<div class="line"> </div>
<div class="line">[...]</div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="structsock__dtls.html">sock_dtls_t</a> dtls_sock;</div>
<div class="line"><span class="keywordflow">if</span> (sock_dtls_create(&amp;dtls_sock, &amp;udp_sock,</div>
<div class="line">                     SOCK_DTLS_SERVER_TAG,</div>
<div class="line">                     <a class="code hl_enumvalue" href="#gga0c6a8ceda748c82eca58fbab436ca300a3d86ab5555dcad0072067eeca3db9696">SOCK_DTLS_1_2</a>, <a class="code hl_enumvalue" href="#ggacef31600358009411b6fcea11ebe07f6af8548d1d8748a66e59667582bed23a17">SOCK_DTLS_SERVER</a>) &lt; 0) {</div>
<div class="line">    puts(<span class="stringliteral">&quot;Error creating DTLS sock&quot;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> -1;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Now we can listen to incoming packets using <a class="el" href="#ga893395d4c18709210d66d979a2f9ea69">sock_dtls_recv()</a>. The application waits indefinitely for new packets. If we want to timeout this wait period we could alternatively set the <code>timeout</code> parameter of the function to a value != <a class="el" href="group__net__sock.html#gaf0c954b49c306f6c125d25ddba9f352e">SOCK_NO_TIMEOUT</a>. If an error occurs we just ignore it and continue looping. We can reply to an incoming message using its <code>session</code>.</p>
<div class="fragment"><div class="line"><span class="keywordflow">while</span> (1) {</div>
<div class="line">    <span class="keywordtype">int</span> res;</div>
<div class="line">    <span class="keywordtype">char</span> buf[128];</div>
<div class="line">    <a class="code hl_struct" href="structsock__dtls__session.html">sock_dtls_session_t</a> session;</div>
<div class="line"> </div>
<div class="line">    res = <a class="code hl_function" href="#ga893395d4c18709210d66d979a2f9ea69">sock_dtls_recv</a>(&amp;dtls_sock, &amp;session, buf, <span class="keyword">sizeof</span>(buf),</div>
<div class="line">                         <a class="code hl_define" href="group__net__sock.html#gaf0c954b49c306f6c125d25ddba9f352e">SOCK_NO_TIMEOUT</a>);</div>
<div class="line">    <span class="keywordflow">if</span> (res &gt; 0) {</div>
<div class="line">        <a class="code hl_define" href="group__cpu__avr8__common__stdio__wrapper.html#gad2eb277496af160238e7306fff780ad2">printf</a>(<span class="stringliteral">&quot;Received %d bytes -- echo!\n&quot;</span>, res);</div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code hl_function" href="#ga630360b12614e2b57fca0cd81cdf9e4e">sock_dtls_send</a>(&amp;dtls_sock, &amp;session, buf, res) &lt; 0) {</div>
<div class="line">            puts(<span class="stringliteral">&quot;Error sending reply&quot;</span>);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">return</span> 0;</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md2077"></a>
Client Operation</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="sock_2udp_8h.html">net/sock/udp.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="sock_2dtls_8h.html">net/sock/dtls.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="ipv6_2addr_8h.html">net/ipv6/addr.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="credman_8h.html">net/credman.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define SOCK_DTLS_CLIENT_TAG (20)</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#ifndef SERVER_ADDR</span></div>
<div class="line"><span class="preprocessor">#define SERVER_ADDR &quot;fe80::aa:bb:cc:dd&quot; </span><span class="comment">// replace with the server address</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Add credentials</span></div>
<div class="line">    <span class="comment">// [...]</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// initialize client</span></div>
<div class="line">    <span class="keywordtype">char</span> rcv[128];</div>
<div class="line">    <a class="code hl_struct" href="structsock__udp.html">sock_udp_t</a> udp_sock;</div>
<div class="line">    <a class="code hl_struct" href="struct__sock__tl__ep.html">sock_udp_ep_t</a> local = <a class="code hl_define" href="group__net__sock.html#ga3f10e5b714c03824d6dc4fff5d372b8f">SOCK_IPV6_EP_ANY</a>;</div>
<div class="line">    local.<a class="code hl_variable" href="struct__sock__tl__ep.html#a00b5dbff09ee8e87806fff6280966140">port</a> = 12345;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_struct" href="struct__sock__tl__ep.html">sock_udp_ep_t</a> remote = <a class="code hl_define" href="group__net__sock.html#ga3f10e5b714c03824d6dc4fff5d372b8f">SOCK_IPV6_EP_ANY</a>;</div>
<div class="line">    remote.<a class="code hl_variable" href="struct__sock__tl__ep.html#a00b5dbff09ee8e87806fff6280966140">port</a> = DTLS_DEFAULT_PORT;</div>
<div class="line">    remote.<a class="code hl_variable" href="struct__sock__tl__ep.html#a4f667124619a9590a0471585f71b2213">netif</a> = <a class="code hl_function" href="group__net__gnrc__netif.html#ga54d0a1ce68aa7e555780b8ec48727a0a">gnrc_netif_iter</a>(NULL)-&gt;<a class="code hl_variable" href="structgnrc__netif__t.html#a48524d59f708cc987051ff1dafe51fe7">pid</a>;   <span class="comment">// only if gnrc_netif_highlander() returns true</span></div>
<div class="line"> </div>
<div class="line">    <a class="code hl_struct" href="structsock__dtls.html">sock_dtls_t</a> dtls_sock;</div>
<div class="line">    <a class="code hl_struct" href="structsock__dtls__session.html">sock_dtls_session_t</a> session;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (!<a class="code hl_function" href="group__net__ipv6__addr.html#gaa8ae58e1fe2c3faacf94d53d6ce814d5">ipv6_addr_from_str</a>((<a class="code hl_union" href="unionipv6__addr__t.html">ipv6_addr_t</a> *)remote.<a class="code hl_variable" href="struct__sock__tl__ep.html#a1c9ec7e621447123a22646bb39fc81a9">addr</a>.<a class="code hl_variable" href="struct__sock__tl__ep.html#ac57a885cc2ffcebc1759e3ac4c60cec9">ipv6</a>, SERVER_ADDR)) {</div>
<div class="line">        puts(<span class="stringliteral">&quot;Error parsing destination address&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> -1;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code hl_function" href="group__net__sock__udp.html#ga20fa4b890dff1c97a63075090e6f9d7d">sock_udp_create</a>(&amp;udp_sock, &amp;local, NULL, 0) &lt; 0) {</div>
<div class="line">        puts(<span class="stringliteral">&quot;Error creating UDP sock&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> -1;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (sock_dtls_create(&amp;dtls_sock, &amp;udp_sock,</div>
<div class="line">                         SOCK_DTLS_CLIENT_TAG,</div>
<div class="line">                         <a class="code hl_enumvalue" href="#gga0c6a8ceda748c82eca58fbab436ca300a3d86ab5555dcad0072067eeca3db9696">SOCK_DTLS_1_2</a>, <a class="code hl_enumvalue" href="#ggacef31600358009411b6fcea11ebe07f6a5d0ebcac70c848b4c09c9a35e40cfdaf">SOCK_DTLS_CLIENT</a>) &lt; 0) {</div>
<div class="line">        puts(<span class="stringliteral">&quot;Error creating DTLS sock&quot;</span>);</div>
<div class="line">        <a class="code hl_function" href="group__net__sock__udp.html#ga9bab7d0998b2c49e66bab0f03367298a">sock_udp_close</a>(&amp;udp_sock);</div>
<div class="line">        <span class="keywordflow">return</span> -1;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code hl_function" href="#ga6ebde4fba6fd184710d1ec1c6285e7a2">sock_dtls_session_init</a>(&amp;dtls_sock, &amp;remote, &amp;session) &lt; 0) {</div>
<div class="line">        puts(<span class="stringliteral">&quot;Error initiating session&quot;</span>);</div>
<div class="line">        sock_dtls_close(&amp;dtls_sock);</div>
<div class="line">        <a class="code hl_function" href="group__net__sock__udp.html#ga9bab7d0998b2c49e66bab0f03367298a">sock_udp_close</a>(&amp;udp_sock);</div>
<div class="line">        <span class="keywordflow">return</span> -1;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code hl_function" href="#ga893395d4c18709210d66d979a2f9ea69">sock_dtls_recv</a>(&amp;dtls_sock, &amp;session, rcv, <span class="keyword">sizeof</span>(rcv),</div>
<div class="line">                       <a class="code hl_define" href="group__net__sock.html#gaf0c954b49c306f6c125d25ddba9f352e">SOCK_NO_TIMEOUT</a>) != -<a class="code hl_define" href="#ga3f7ccb93f455150d01aad0295d398762">SOCK_DTLS_HANDSHAKE</a>) {</div>
<div class="line">        puts(<span class="stringliteral">&quot;Error completing handshake&quot;</span>);</div>
<div class="line">        sock_dtls_close(&amp;dtls_sock);</div>
<div class="line">        <a class="code hl_function" href="group__net__sock__udp.html#ga9bab7d0998b2c49e66bab0f03367298a">sock_udp_close</a>(&amp;udp_sock);</div>
<div class="line">        <span class="keywordflow">return</span> -1;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> data[] = <span class="stringliteral">&quot;HELLO&quot;</span>;</div>
<div class="line">    <span class="keywordtype">int</span> res = <a class="code hl_function" href="#ga630360b12614e2b57fca0cd81cdf9e4e">sock_dtls_send</a>(&amp;dtls_sock, &amp;session, data, <span class="keyword">sizeof</span>(data), 0);</div>
<div class="line">    <span class="keywordflow">if</span> (res &gt;= 0) {</div>
<div class="line">        <a class="code hl_define" href="group__cpu__avr8__common__stdio__wrapper.html#gad2eb277496af160238e7306fff780ad2">printf</a>(<span class="stringliteral">&quot;Sent %d bytes\n&quot;</span>, res);</div>
<div class="line">        res = <a class="code hl_function" href="#ga893395d4c18709210d66d979a2f9ea69">sock_dtls_recv</a>(&amp;dtls_sock, &amp;session, rcv, <span class="keyword">sizeof</span>(rcv),</div>
<div class="line">                             <a class="code hl_define" href="group__net__sock.html#gaf0c954b49c306f6c125d25ddba9f352e">SOCK_NO_TIMEOUT</a>);</div>
<div class="line">        <span class="keywordflow">if</span> (res &gt; 0) {</div>
<div class="line">            <a class="code hl_define" href="group__cpu__avr8__common__stdio__wrapper.html#gad2eb277496af160238e7306fff780ad2">printf</a>(<span class="stringliteral">&quot;Received %d bytes\n&quot;</span>, res);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> {</div>
<div class="line">        puts(<span class="stringliteral">&quot;Error sending data&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    sock_dtls_session_destroy(&amp;dtls_sock, &amp;session);</div>
<div class="line">    sock_dtls_close(&amp;dtls_sock);</div>
<div class="line">    <a class="code hl_function" href="group__net__sock__udp.html#ga9bab7d0998b2c49e66bab0f03367298a">sock_udp_close</a>(&amp;udp_sock);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__net__gnrc__netif_html_ga54d0a1ce68aa7e555780b8ec48727a0a"><div class="ttname"><a href="group__net__gnrc__netif.html#ga54d0a1ce68aa7e555780b8ec48727a0a">gnrc_netif_iter</a></div><div class="ttdeci">gnrc_netif_t * gnrc_netif_iter(const gnrc_netif_t *prev)</div><div class="ttdoc">Iterate over all network interfaces.</div></div>
<div class="ttc" id="agroup__net__ipv6__addr_html_gaa8ae58e1fe2c3faacf94d53d6ce814d5"><div class="ttname"><a href="group__net__ipv6__addr.html#gaa8ae58e1fe2c3faacf94d53d6ce814d5">ipv6_addr_from_str</a></div><div class="ttdeci">ipv6_addr_t * ipv6_addr_from_str(ipv6_addr_t *result, const char *addr)</div><div class="ttdoc">Converts an IPv6 address string representation to a byte-represented IPv6 address.</div></div>
<div class="ttc" id="agroup__net__sock__dtls_html_ga3f7ccb93f455150d01aad0295d398762"><div class="ttname"><a href="#ga3f7ccb93f455150d01aad0295d398762">SOCK_DTLS_HANDSHAKE</a></div><div class="ttdeci">#define SOCK_DTLS_HANDSHAKE</div><div class="ttdoc">Return value for a successful handshake.</div><div class="ttdef"><b>Definition</b> <a href="sock_2dtls_8h_source.html#l00582">dtls.h:582</a></div></div>
<div class="ttc" id="agroup__net__sock__dtls_html_ga6ebde4fba6fd184710d1ec1c6285e7a2"><div class="ttname"><a href="#ga6ebde4fba6fd184710d1ec1c6285e7a2">sock_dtls_session_init</a></div><div class="ttdeci">int sock_dtls_session_init(sock_dtls_t *sock, const sock_udp_ep_t *ep, sock_dtls_session_t *remote)</div><div class="ttdoc">Initialize session handshake.</div></div>
<div class="ttc" id="agroup__net__sock__dtls_html_ggacef31600358009411b6fcea11ebe07f6a5d0ebcac70c848b4c09c9a35e40cfdaf"><div class="ttname"><a href="#ggacef31600358009411b6fcea11ebe07f6a5d0ebcac70c848b4c09c9a35e40cfdaf">SOCK_DTLS_CLIENT</a></div><div class="ttdeci">@ SOCK_DTLS_CLIENT</div><div class="ttdoc">Endpoint client role.</div><div class="ttdef"><b>Definition</b> <a href="sock_2dtls_8h_source.html#l00616">dtls.h:616</a></div></div>
<div class="ttc" id="agroup__net__sock__udp_html_ga9bab7d0998b2c49e66bab0f03367298a"><div class="ttname"><a href="group__net__sock__udp.html#ga9bab7d0998b2c49e66bab0f03367298a">sock_udp_close</a></div><div class="ttdeci">void sock_udp_close(sock_udp_t *sock)</div><div class="ttdoc">Closes a UDP sock object.</div></div>
<div class="ttc" id="aipv6_2addr_8h_html"><div class="ttname"><a href="ipv6_2addr_8h.html">addr.h</a></div><div class="ttdoc">Definitions for IPv6 addresses.</div></div>
<div class="ttc" id="asock_2udp_8h_html"><div class="ttname"><a href="sock_2udp_8h.html">udp.h</a></div><div class="ttdoc">UDP sock definitions.</div></div>
<div class="ttc" id="astruct__sock__tl__ep_html_a1c9ec7e621447123a22646bb39fc81a9"><div class="ttname"><a href="struct__sock__tl__ep.html#a1c9ec7e621447123a22646bb39fc81a9">_sock_tl_ep::addr</a></div><div class="ttdeci">union _sock_tl_ep::@384 addr</div><div class="ttdoc">address</div></div>
<div class="ttc" id="astruct__sock__tl__ep_html_a4f667124619a9590a0471585f71b2213"><div class="ttname"><a href="struct__sock__tl__ep.html#a4f667124619a9590a0471585f71b2213">_sock_tl_ep::netif</a></div><div class="ttdeci">uint16_t netif</div><div class="ttdoc">stack-specific network interface ID</div><div class="ttdef"><b>Definition</b> <a href="sock_8h_source.html#l00246">sock.h:246</a></div></div>
<div class="ttc" id="astruct__sock__tl__ep_html_ac57a885cc2ffcebc1759e3ac4c60cec9"><div class="ttname"><a href="struct__sock__tl__ep.html#ac57a885cc2ffcebc1759e3ac4c60cec9">_sock_tl_ep::ipv6</a></div><div class="ttdeci">uint8_t ipv6[16]</div><div class="ttdoc">IPv6 address mode.</div><div class="ttdef"><b>Definition</b> <a href="sock_8h_source.html#l00230">sock.h:230</a></div></div>
<div class="ttc" id="astructgnrc__netif__t_html_a48524d59f708cc987051ff1dafe51fe7"><div class="ttname"><a href="structgnrc__netif__t.html#a48524d59f708cc987051ff1dafe51fe7">gnrc_netif_t::pid</a></div><div class="ttdeci">kernel_pid_t pid</div><div class="ttdoc">PID of the network interface's thread.</div><div class="ttdef"><b>Definition</b> <a href="gnrc_2netif_8h_source.html#l00226">netif.h:226</a></div></div>
<div class="ttc" id="aunionipv6__addr__t_html"><div class="ttname"><a href="unionipv6__addr__t.html">ipv6_addr_t</a></div><div class="ttdoc">Data type to represent an IPv6 address.</div><div class="ttdef"><b>Definition</b> <a href="ipv6_2addr_8h_source.html#l00072">addr.h:72</a></div></div>
</div><!-- fragment --><p> This is an example of a DTLS echo client.</p>
<p>Like the server, we must first create the UDP sock.</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structsock__udp.html">sock_udp_t</a> udp_sock;</div>
<div class="line"><a class="code hl_struct" href="struct__sock__tl__ep.html">sock_udp_ep_t</a> local = <a class="code hl_define" href="group__net__sock.html#ga3f10e5b714c03824d6dc4fff5d372b8f">SOCK_IPV6_EP_ANY</a>;</div>
<div class="line">local.<a class="code hl_variable" href="struct__sock__tl__ep.html#a00b5dbff09ee8e87806fff6280966140">port</a> = 12345;</div>
<div class="line"><a class="code hl_function" href="group__net__sock__udp.html#ga20fa4b890dff1c97a63075090e6f9d7d">sock_udp_create</a>(&amp;udp_sock, &amp;local, NULL, 0);</div>
</div><!-- fragment --><p>After that, we set the address of the remote endpoint and its listening port, which is DTLS_DEFAULT_PORT (20220).</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="struct__sock__tl__ep.html">sock_udp_ep_t</a> remote = <a class="code hl_define" href="group__net__sock.html#ga3f10e5b714c03824d6dc4fff5d372b8f">SOCK_IPV6_EP_ANY</a>;</div>
<div class="line">remote.<a class="code hl_variable" href="struct__sock__tl__ep.html#a00b5dbff09ee8e87806fff6280966140">port</a> = DTLS_DEFAULT_PORT;</div>
<div class="line">remote.<a class="code hl_variable" href="struct__sock__tl__ep.html#a4f667124619a9590a0471585f71b2213">netif</a> = <a class="code hl_function" href="group__net__gnrc__netif.html#ga54d0a1ce68aa7e555780b8ec48727a0a">gnrc_netif_iter</a>(NULL)-&gt;<a class="code hl_variable" href="structgnrc__netif__t.html#a48524d59f708cc987051ff1dafe51fe7">pid</a>;   <span class="comment">// only if gnrc_netif_highlander() returns true</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (!<a class="code hl_function" href="group__net__ipv6__addr.html#gaa8ae58e1fe2c3faacf94d53d6ce814d5">ipv6_addr_from_str</a>((<a class="code hl_union" href="unionipv6__addr__t.html">ipv6_addr_t</a> *)remote.<a class="code hl_variable" href="struct__sock__tl__ep.html#a1c9ec7e621447123a22646bb39fc81a9">addr</a>.<a class="code hl_variable" href="struct__sock__tl__ep.html#ac57a885cc2ffcebc1759e3ac4c60cec9">ipv6</a>, SERVER_ADDR)) {</div>
<div class="line">    puts(<span class="stringliteral">&quot;Error parsing destination address&quot;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> -1;</div>
<div class="line">}</div>
</div><!-- fragment --><p>After the UDP sock is created, we can proceed with creating the DTLS sock. Before sending the packet, we must first initiate a session handshake with the remote endpoint using <a class="el" href="#ga6ebde4fba6fd184710d1ec1c6285e7a2">sock_dtls_session_init()</a>. We will need to call <a class="el" href="#ga893395d4c18709210d66d979a2f9ea69">sock_dtls_recv()</a> to receive and process all the handshake packets. If the handshake is successful and the session is created, we send packets to it using <a class="el" href="#ga630360b12614e2b57fca0cd81cdf9e4e">sock_dtls_send()</a>. As we already know the session exists, we can set the timeout to <code>0</code> and listen to the reply with <a class="el" href="#ga893395d4c18709210d66d979a2f9ea69">sock_dtls_recv()</a>.</p>
<p>Alternatively, set the timeout to of <a class="el" href="#ga630360b12614e2b57fca0cd81cdf9e4e">sock_dtls_send()</a> to the duration we want to wait for the handshake process. We can also set the timeout to <a class="el" href="group__net__sock.html#gaf0c954b49c306f6c125d25ddba9f352e">SOCK_NO_TIMEOUT</a> to block indefinitely until handshake is complete. After handshake completes, the packet will be sent.</p>
<p><a class="el" href="#ga53b88f47412139d54c8e480404435ea8">sock_dtls_init()</a>, <a class="el" href="#ga893395d4c18709210d66d979a2f9ea69">sock_dtls_recv</a> and sock_dtls_close() only manages the DTLS layer. That means we still have to clean up the created UDP sock from before by calling <a class="el" href="group__net__sock__udp.html#ga9bab7d0998b2c49e66bab0f03367298a">sock_udp_close()</a> on our UDP sock in case of error or we reached the end of the application.</p>
<div class="fragment"><div class="line"><span class="keywordtype">char</span> rcv[128];</div>
<div class="line"><a class="code hl_struct" href="structsock__dtls.html">sock_dtls_t</a> dtls_sock;</div>
<div class="line"><a class="code hl_struct" href="structsock__dtls__session.html">sock_dtls_session_t</a> session;</div>
<div class="line"> </div>
<div class="line">[...]</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (sock_dtls_create(&amp;dtls_sock, &amp;udp_sock,</div>
<div class="line">                     SOCK_DTLS_CLIENT_TAG,</div>
<div class="line">                     <a class="code hl_enumvalue" href="#gga0c6a8ceda748c82eca58fbab436ca300a3d86ab5555dcad0072067eeca3db9696">SOCK_DTLS_1_2</a>, <a class="code hl_enumvalue" href="#ggacef31600358009411b6fcea11ebe07f6a5d0ebcac70c848b4c09c9a35e40cfdaf">SOCK_DTLS_CLIENT</a>) &lt; 0) {</div>
<div class="line">    puts(<span class="stringliteral">&quot;Error creating DTLS sock&quot;</span>);</div>
<div class="line">    <a class="code hl_function" href="group__net__sock__udp.html#ga9bab7d0998b2c49e66bab0f03367298a">sock_udp_close</a>(&amp;udp_sock);</div>
<div class="line">    <span class="keywordflow">return</span> -1;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="#ga6ebde4fba6fd184710d1ec1c6285e7a2">sock_dtls_session_init</a>(&amp;dtls_sock, &amp;remote, &amp;session) &lt; 0) {</div>
<div class="line">    puts(<span class="stringliteral">&quot;Error initiating session&quot;</span>);</div>
<div class="line">    sock_dtls_close(&amp;dtls_sock);</div>
<div class="line">    <a class="code hl_function" href="group__net__sock__udp.html#ga9bab7d0998b2c49e66bab0f03367298a">sock_udp_close</a>(&amp;udp_sock);</div>
<div class="line">    <span class="keywordflow">return</span> -1;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="#ga893395d4c18709210d66d979a2f9ea69">sock_dtls_recv</a>(&amp;dtls_sock, &amp;session, rcv, <span class="keyword">sizeof</span>(rcv),</div>
<div class="line">                   <a class="code hl_define" href="group__net__sock.html#gaf0c954b49c306f6c125d25ddba9f352e">SOCK_NO_TIMEOUT</a>) != -<a class="code hl_define" href="#ga3f7ccb93f455150d01aad0295d398762">SOCK_DTLS_HANDSHAKE</a>) {</div>
<div class="line">    puts(<span class="stringliteral">&quot;Error completing handshake&quot;</span>);</div>
<div class="line">    sock_dtls_close(&amp;dtls_sock);</div>
<div class="line">    <a class="code hl_function" href="group__net__sock__udp.html#ga9bab7d0998b2c49e66bab0f03367298a">sock_udp_close</a>(&amp;udp_sock);</div>
<div class="line">    <span class="keywordflow">return</span> -1;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> data[] = <span class="stringliteral">&quot;HELLO&quot;</span>;</div>
<div class="line"><span class="keywordtype">int</span> res = <a class="code hl_function" href="#ga630360b12614e2b57fca0cd81cdf9e4e">sock_dtls_send</a>(&amp;dtls_sock, &amp;session, data, <span class="keyword">sizeof</span>(data), 0);</div>
<div class="line"><span class="keywordflow">if</span> (res &gt;= 0) {</div>
<div class="line">    <a class="code hl_define" href="group__cpu__avr8__common__stdio__wrapper.html#gad2eb277496af160238e7306fff780ad2">printf</a>(<span class="stringliteral">&quot;Sent %d bytes: %*.s\n&quot;</span>, res, res, data);</div>
<div class="line">    res = <a class="code hl_function" href="#ga893395d4c18709210d66d979a2f9ea69">sock_dtls_recv</a>(&amp;dtls_sock, &amp;session, rcv, <span class="keyword">sizeof</span>(rcv),</div>
<div class="line">                         <a class="code hl_define" href="group__net__sock.html#gaf0c954b49c306f6c125d25ddba9f352e">SOCK_NO_TIMEOUT</a>);</div>
<div class="line">    <span class="keywordflow">if</span> (res &gt; 0) {</div>
<div class="line">        <a class="code hl_define" href="group__cpu__avr8__common__stdio__wrapper.html#gad2eb277496af160238e7306fff780ad2">printf</a>(<span class="stringliteral">&quot;Received %d bytes: %*.s\n&quot;</span>, res, res, rcv);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span> {</div>
<div class="line">    puts(<span class="stringliteral">&quot;Error sending data&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">sock_dtls_session_destroy(&amp;dtls_sock, &amp;session);</div>
<div class="line">sock_dtls_close(&amp;dtls_sock);</div>
<div class="line"><a class="code hl_function" href="group__net__sock__udp.html#ga9bab7d0998b2c49e66bab0f03367298a">sock_udp_close</a>(&amp;udp_sock);</div>
<div class="line"><span class="keywordflow">return</span> 0;</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md2078"></a>
Multi-credential handling</h3>
<p>Each sock needs at least one credential tag to operate. <code>sock_dtls_create</code> allows to optionally assign an initial credential. Extra credentials can be added and removed using <a class="el" href="group__net__sock__dtls__creds.html#gae9388932dba7c8ade1245ff296e810f7">sock_dtls_add_credential</a> and <a class="el" href="group__net__sock__dtls__creds.html#gad9d8b4af474253a60dc78078835a6e4d">sock_dtls_remove_credential</a> respectively (found in <code><a class="el" href="creds_8h.html" title="DTLS sock definitions.">net/sock/dtls/creds.h</a></code>).</p>
<h4><a class="anchor" id="autotoc_md2079"></a>
Pre-shared Keys Cipher Suites</h4>
<p>In the case of PSK, a server can optionally indicate a hint to help the client to decide which PSK Identity to use, using <a class="el" href="group__net__sock__dtls__creds.html#ga0023a4097d185cd6ee21e5097f51a49a">sock_dtls_set_server_psk_id_hint</a> (see <a href="https://tools.ietf.org/html/rfc4279#section-5.2">https://tools.ietf.org/html/rfc4279#section-5.2</a>). The client application can decide which credential to use based on the sent hint and/or the session information, by registering a callback with <a class="el" href="group__net__sock__dtls__creds.html#ga14d2d11e9dcf19049f330ad5c667580e">sock_dtls_set_client_psk_cb</a>. If no callback is registered, or fails to chose a tag (i.e. it returns <a class="el" href="group__net__credman.html#gaef3b87d09d3032ab13e653756f34da92">CREDMAN_TAG_EMPTY</a>), the credential is chosen as follows: if a hint is sent by the server, all credentials registered to the sock are checked for a matching <a class="el" href="structpsk__params__t.html#a2995108ed4d4a1a50651d6af4d609ef0">hint</a>. A credential is selected on matching hint. If no credential matches the hint or no hint is provided, the first PSK credential registered in the sock is used.</p>
<h4><a class="anchor" id="autotoc_md2080"></a>
Elliptic Curve Cryptography Cipher Suites</h4>
<p>When using ECC both client and server applications can register a callback to decide which of the registered credentials should be used, based on the session information. This is done using <a class="el" href="group__net__sock__dtls__creds.html#ga7524206606ab503113c5ffa83df1a2af">sock_dtls_set_rpk_cb</a>.</p>
<p>In both cases, if no callbacks are registered, the sock implementation will try to find a registered credential in the Sock's credential list, that matches the needed type. The first one that matches is used.</p>
<h4><a class="anchor" id="autotoc_md2081"></a>
Public key verification when using ECC</h4>
<p>By enabling the pseudomodule <code>sock_dtls_verify_public_key</code> the DTLS sock will verify the public key of the remote peer. When enabled, the DTLS sock will only accept a connection if the provided public key is in the list of public keys assigned to the specified sock. This only applies when using ECC ciphersuites (i.e., not PSK). </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="groups" name="groups"></a>
Topics</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__sock__dtls__creds.html">DTLS sock credentials API</a></td></tr>
<tr class="memdesc:group__net__sock__dtls__creds"><td class="mdescLeft">&#160;</td><td class="mdescRight">Credential handling for DTLS sock <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__net__sock__dtls__conf.html">SOCK DTLS compile configuration</a></td></tr>
<tr class="memdesc:group__net__sock__dtls__conf"><td class="mdescLeft">&#160;</td><td class="mdescRight"><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="files" name="files"></a>
Files</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sock_2dtls_8h.html">dtls.h</a></td></tr>
<tr class="memdesc:sock_2dtls_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">DTLS sock definitions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gad77967da0dcabd6ceea9e523897b6798" id="r_gad77967da0dcabd6ceea9e523897b6798"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad77967da0dcabd6ceea9e523897b6798">DTLS_HANDSHAKE_BUFSIZE</a>&#160;&#160;&#160;(1 &lt;&lt; <a class="el" href="group__net__sock__dtls__conf.html#ga0cbc6d1ac3648c3e4b6803d0272535ef">CONFIG_DTLS_HANDSHAKE_BUFSIZE_EXP</a>)</td></tr>
<tr class="memdesc:gad77967da0dcabd6ceea9e523897b6798"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size buffer used in handshake to hold credentials.  <br /></td></tr>
<tr class="separator:gad77967da0dcabd6ceea9e523897b6798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f7ccb93f455150d01aad0295d398762" id="r_ga3f7ccb93f455150d01aad0295d398762"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3f7ccb93f455150d01aad0295d398762">SOCK_DTLS_HANDSHAKE</a>&#160;&#160;&#160;(<a class="el" href="group__cpu__atmega__common.html#ga3396cf9fb0ff5af3a18dd2a2bbdb21e1">EXDEV</a>)</td></tr>
<tr class="memdesc:ga3f7ccb93f455150d01aad0295d398762"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return value for a successful handshake.  <br /></td></tr>
<tr class="separator:ga3f7ccb93f455150d01aad0295d398762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad41621093a9a2d9e7830e372125cb8fd" id="r_gad41621093a9a2d9e7830e372125cb8fd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad41621093a9a2d9e7830e372125cb8fd">CONFIG_DTLS_FORCE_EXTENDED_MASTER_SECRET</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:gad41621093a9a2d9e7830e372125cb8fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force extended master secret extension.  <br /></td></tr>
<tr class="separator:gad41621093a9a2d9e7830e372125cb8fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05770995cf620f04210dc5517517db70" id="r_ga05770995cf620f04210dc5517517db70"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga05770995cf620f04210dc5517517db70">CONFIG_DTLS_FORCE_RENEGOTIATION_INFO</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ga05770995cf620f04210dc5517517db70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force renegotiation info extension.  <br /></td></tr>
<tr class="separator:ga05770995cf620f04210dc5517517db70"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaa63acc71681400dd4b856ce09e27cafb" id="r_gaa63acc71681400dd4b856ce09e27cafb"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structsock__dtls.html">sock_dtls</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa63acc71681400dd4b856ce09e27cafb">sock_dtls_t</a></td></tr>
<tr class="memdesc:gaa63acc71681400dd4b856ce09e27cafb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for a DTLS sock object.  <br /></td></tr>
<tr class="separator:gaa63acc71681400dd4b856ce09e27cafb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8595b9670004ad4afc5738109ecce649" id="r_ga8595b9670004ad4afc5738109ecce649"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structsock__dtls__session.html">sock_dtls_session</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8595b9670004ad4afc5738109ecce649">sock_dtls_session_t</a></td></tr>
<tr class="memdesc:ga8595b9670004ad4afc5738109ecce649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about a created session.  <br /></td></tr>
<tr class="separator:ga8595b9670004ad4afc5738109ecce649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9512682d85257239769e4f62d3968839" id="r_ga9512682d85257239769e4f62d3968839"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structsock__udp__aux__rx__t.html">sock_udp_aux_rx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9512682d85257239769e4f62d3968839">sock_dtls_aux_rx_t</a></td></tr>
<tr class="memdesc:ga9512682d85257239769e4f62d3968839"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary data provided when receiving using an DTLS sock object.  <br /></td></tr>
<tr class="separator:ga9512682d85257239769e4f62d3968839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7bc6f25016a05b5b793eb5d4745166a" id="r_gac7bc6f25016a05b5b793eb5d4745166a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structsock__udp__aux__tx__t.html">sock_udp_aux_tx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac7bc6f25016a05b5b793eb5d4745166a">sock_dtls_aux_tx_t</a></td></tr>
<tr class="memdesc:gac7bc6f25016a05b5b793eb5d4745166a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary data provided when sending using an DTLS sock object.  <br /></td></tr>
<tr class="separator:gac7bc6f25016a05b5b793eb5d4745166a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga53b88f47412139d54c8e480404435ea8" id="r_ga53b88f47412139d54c8e480404435ea8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga53b88f47412139d54c8e480404435ea8">sock_dtls_init</a> (void)</td></tr>
<tr class="memdesc:ga53b88f47412139d54c8e480404435ea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called exactly once during <code>auto_init</code>.  <br /></td></tr>
<tr class="separator:ga53b88f47412139d54c8e480404435ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10998fac05f15688f9dd34a22c7bb682" id="r_ga10998fac05f15688f9dd34a22c7bb682"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga10998fac05f15688f9dd34a22c7bb682">sock_dtls_create</a> (<a class="el" href="group__net__sock__async.html#gaa63acc71681400dd4b856ce09e27cafb">sock_dtls_t</a> *sock, <a class="el" href="group__net__sock__async.html#ga3cb61a4ee66c9c235e4f22860658698c">sock_udp_t</a> *udp_sock, <a class="el" href="group__net__credman.html#ga89fc115fe10d879da7faf1c0d0f901a7">credman_tag_t</a> tag, unsigned version, unsigned role)</td></tr>
<tr class="memdesc:ga10998fac05f15688f9dd34a22c7bb682"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new DTLS sock object.  <br /></td></tr>
<tr class="separator:ga10998fac05f15688f9dd34a22c7bb682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c57588ebd846e5324bf24ffd97269a4" id="r_ga7c57588ebd846e5324bf24ffd97269a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__net__sock__async.html#ga3cb61a4ee66c9c235e4f22860658698c">sock_udp_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7c57588ebd846e5324bf24ffd97269a4">sock_dtls_get_udp_sock</a> (<a class="el" href="group__net__sock__async.html#gaa63acc71681400dd4b856ce09e27cafb">sock_dtls_t</a> *sock)</td></tr>
<tr class="memdesc:ga7c57588ebd846e5324bf24ffd97269a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get underlying UDP sock.  <br /></td></tr>
<tr class="separator:ga7c57588ebd846e5324bf24ffd97269a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ebde4fba6fd184710d1ec1c6285e7a2" id="r_ga6ebde4fba6fd184710d1ec1c6285e7a2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6ebde4fba6fd184710d1ec1c6285e7a2">sock_dtls_session_init</a> (<a class="el" href="group__net__sock__async.html#gaa63acc71681400dd4b856ce09e27cafb">sock_dtls_t</a> *sock, const <a class="el" href="group__net__sock__udp.html#gaedc829c7973d7870c1ec078f9ffd45a1">sock_udp_ep_t</a> *ep, <a class="el" href="#ga8595b9670004ad4afc5738109ecce649">sock_dtls_session_t</a> *remote)</td></tr>
<tr class="memdesc:ga6ebde4fba6fd184710d1ec1c6285e7a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize session handshake.  <br /></td></tr>
<tr class="separator:ga6ebde4fba6fd184710d1ec1c6285e7a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e2688dd03fe5d365ec81c4f82ff03ed" id="r_ga5e2688dd03fe5d365ec81c4f82ff03ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5e2688dd03fe5d365ec81c4f82ff03ed">sock_dtls_session_destroy</a> (<a class="el" href="group__net__sock__async.html#gaa63acc71681400dd4b856ce09e27cafb">sock_dtls_t</a> *sock, <a class="el" href="#ga8595b9670004ad4afc5738109ecce649">sock_dtls_session_t</a> *remote)</td></tr>
<tr class="memdesc:ga5e2688dd03fe5d365ec81c4f82ff03ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys an existing DTLS session.  <br /></td></tr>
<tr class="separator:ga5e2688dd03fe5d365ec81c4f82ff03ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaceffefc3c421cb696560e87ecf040161" id="r_gaceffefc3c421cb696560e87ecf040161"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaceffefc3c421cb696560e87ecf040161">sock_dtls_session_get_udp_ep</a> (const <a class="el" href="#ga8595b9670004ad4afc5738109ecce649">sock_dtls_session_t</a> *session, <a class="el" href="group__net__sock__udp.html#gaedc829c7973d7870c1ec078f9ffd45a1">sock_udp_ep_t</a> *ep)</td></tr>
<tr class="memdesc:gaceffefc3c421cb696560e87ecf040161"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the remote UDP endpoint from a session.  <br /></td></tr>
<tr class="separator:gaceffefc3c421cb696560e87ecf040161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddac5bc68779c993cc613042a2515b12" id="r_gaddac5bc68779c993cc613042a2515b12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaddac5bc68779c993cc613042a2515b12">sock_dtls_session_set_udp_ep</a> (<a class="el" href="#ga8595b9670004ad4afc5738109ecce649">sock_dtls_session_t</a> *session, const <a class="el" href="group__net__sock__udp.html#gaedc829c7973d7870c1ec078f9ffd45a1">sock_udp_ep_t</a> *ep)</td></tr>
<tr class="memdesc:gaddac5bc68779c993cc613042a2515b12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the remote UDP endpoint from a session.  <br /></td></tr>
<tr class="separator:gaddac5bc68779c993cc613042a2515b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91476f35b5ea85b789e19cb3fd256f42" id="r_ga91476f35b5ea85b789e19cb3fd256f42"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga91476f35b5ea85b789e19cb3fd256f42">sock_dtls_recv_aux</a> (<a class="el" href="group__net__sock__async.html#gaa63acc71681400dd4b856ce09e27cafb">sock_dtls_t</a> *sock, <a class="el" href="#ga8595b9670004ad4afc5738109ecce649">sock_dtls_session_t</a> *remote, void *data, size_t maxlen, uint32_t timeout, <a class="el" href="#ga9512682d85257239769e4f62d3968839">sock_dtls_aux_rx_t</a> *aux)</td></tr>
<tr class="memdesc:ga91476f35b5ea85b789e19cb3fd256f42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive handshake messages and application data from remote peer.  <br /></td></tr>
<tr class="separator:ga91476f35b5ea85b789e19cb3fd256f42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga893395d4c18709210d66d979a2f9ea69" id="r_ga893395d4c18709210d66d979a2f9ea69"><td class="memItemLeft" align="right" valign="top">static ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga893395d4c18709210d66d979a2f9ea69">sock_dtls_recv</a> (<a class="el" href="group__net__sock__async.html#gaa63acc71681400dd4b856ce09e27cafb">sock_dtls_t</a> *sock, <a class="el" href="#ga8595b9670004ad4afc5738109ecce649">sock_dtls_session_t</a> *remote, void *data, size_t maxlen, uint32_t timeout)</td></tr>
<tr class="memdesc:ga893395d4c18709210d66d979a2f9ea69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive handshake messages and application data from remote peer.  <br /></td></tr>
<tr class="separator:ga893395d4c18709210d66d979a2f9ea69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga208fb85350aa404db39305d6fe6cc0a9" id="r_ga208fb85350aa404db39305d6fe6cc0a9"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga208fb85350aa404db39305d6fe6cc0a9">sock_dtls_recv_buf_aux</a> (<a class="el" href="group__net__sock__async.html#gaa63acc71681400dd4b856ce09e27cafb">sock_dtls_t</a> *sock, <a class="el" href="#ga8595b9670004ad4afc5738109ecce649">sock_dtls_session_t</a> *remote, void **data, void **buf_ctx, uint32_t timeout, <a class="el" href="#ga9512682d85257239769e4f62d3968839">sock_dtls_aux_rx_t</a> *aux)</td></tr>
<tr class="memdesc:ga208fb85350aa404db39305d6fe6cc0a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrypts and provides stack-internal buffer space containing a message from a remote peer.  <br /></td></tr>
<tr class="separator:ga208fb85350aa404db39305d6fe6cc0a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga026748dd9ad74a8a216eaad086551a7d" id="r_ga026748dd9ad74a8a216eaad086551a7d"><td class="memItemLeft" align="right" valign="top">static ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga026748dd9ad74a8a216eaad086551a7d">sock_dtls_recv_buf</a> (<a class="el" href="group__net__sock__async.html#gaa63acc71681400dd4b856ce09e27cafb">sock_dtls_t</a> *sock, <a class="el" href="#ga8595b9670004ad4afc5738109ecce649">sock_dtls_session_t</a> *remote, void **data, void **buf_ctx, uint32_t timeout)</td></tr>
<tr class="memdesc:ga026748dd9ad74a8a216eaad086551a7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrypts and provides stack-internal buffer space containing a message from a remote peer.  <br /></td></tr>
<tr class="separator:ga026748dd9ad74a8a216eaad086551a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebdaa80fe988205e8aa2106898095e8c" id="r_gaebdaa80fe988205e8aa2106898095e8c"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaebdaa80fe988205e8aa2106898095e8c">sock_dtls_sendv_aux</a> (<a class="el" href="group__net__sock__async.html#gaa63acc71681400dd4b856ce09e27cafb">sock_dtls_t</a> *sock, <a class="el" href="#ga8595b9670004ad4afc5738109ecce649">sock_dtls_session_t</a> *remote, const <a class="el" href="group__sys__iolist.html#gaa17f91ef26edec149cd806d8457aa3a0">iolist_t</a> *snips, uint32_t timeout, <a class="el" href="#gac7bc6f25016a05b5b793eb5d4745166a">sock_dtls_aux_tx_t</a> *aux)</td></tr>
<tr class="memdesc:gaebdaa80fe988205e8aa2106898095e8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encrypts and sends a message to a remote peer with non-continous payload.  <br /></td></tr>
<tr class="separator:gaebdaa80fe988205e8aa2106898095e8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1abd23c69aef1066a139cfc2ffb0d3e7" id="r_ga1abd23c69aef1066a139cfc2ffb0d3e7"><td class="memItemLeft" align="right" valign="top">static ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1abd23c69aef1066a139cfc2ffb0d3e7">sock_dtls_send_aux</a> (<a class="el" href="group__net__sock__async.html#gaa63acc71681400dd4b856ce09e27cafb">sock_dtls_t</a> *sock, <a class="el" href="#ga8595b9670004ad4afc5738109ecce649">sock_dtls_session_t</a> *remote, const void *data, size_t len, uint32_t timeout, <a class="el" href="#gac7bc6f25016a05b5b793eb5d4745166a">sock_dtls_aux_tx_t</a> *aux)</td></tr>
<tr class="memdesc:ga1abd23c69aef1066a139cfc2ffb0d3e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encrypts and sends a message to a remote peer.  <br /></td></tr>
<tr class="separator:ga1abd23c69aef1066a139cfc2ffb0d3e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga630360b12614e2b57fca0cd81cdf9e4e" id="r_ga630360b12614e2b57fca0cd81cdf9e4e"><td class="memItemLeft" align="right" valign="top">static ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga630360b12614e2b57fca0cd81cdf9e4e">sock_dtls_send</a> (<a class="el" href="group__net__sock__async.html#gaa63acc71681400dd4b856ce09e27cafb">sock_dtls_t</a> *sock, <a class="el" href="#ga8595b9670004ad4afc5738109ecce649">sock_dtls_session_t</a> *remote, const void *data, size_t len, uint32_t timeout)</td></tr>
<tr class="memdesc:ga630360b12614e2b57fca0cd81cdf9e4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encrypts and sends a message to a remote peer.  <br /></td></tr>
<tr class="separator:ga630360b12614e2b57fca0cd81cdf9e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16197978f12dc0efd521e8dba2853c45" id="r_ga16197978f12dc0efd521e8dba2853c45"><td class="memItemLeft" align="right" valign="top">static ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga16197978f12dc0efd521e8dba2853c45">sock_dtls_sendv</a> (<a class="el" href="group__net__sock__async.html#gaa63acc71681400dd4b856ce09e27cafb">sock_dtls_t</a> *sock, <a class="el" href="#ga8595b9670004ad4afc5738109ecce649">sock_dtls_session_t</a> *remote, const <a class="el" href="group__sys__iolist.html#gaa17f91ef26edec149cd806d8457aa3a0">iolist_t</a> *snips, uint32_t timeout)</td></tr>
<tr class="memdesc:ga16197978f12dc0efd521e8dba2853c45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encrypts and sends a message to a remote peer with non-continous payload.  <br /></td></tr>
<tr class="separator:ga16197978f12dc0efd521e8dba2853c45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47fde8af808ceed2db7fefbb05bbd04c" id="r_ga47fde8af808ceed2db7fefbb05bbd04c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga47fde8af808ceed2db7fefbb05bbd04c">sock_dtls_close</a> (<a class="el" href="group__net__sock__async.html#gaa63acc71681400dd4b856ce09e27cafb">sock_dtls_t</a> *sock)</td></tr>
<tr class="memdesc:ga47fde8af808ceed2db7fefbb05bbd04c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes a DTLS sock.  <br /></td></tr>
<tr class="separator:ga47fde8af808ceed2db7fefbb05bbd04c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c6a8ceda748c82eca58fbab436ca300" id="r_ga0c6a8ceda748c82eca58fbab436ca300"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="#gga0c6a8ceda748c82eca58fbab436ca300a1c0824e2bb84e5d4654893ded0788bbb">SOCK_DTLS_1_0</a> = 1
, <a class="el" href="#gga0c6a8ceda748c82eca58fbab436ca300a3d86ab5555dcad0072067eeca3db9696">SOCK_DTLS_1_2</a> = 2
, <a class="el" href="#gga0c6a8ceda748c82eca58fbab436ca300ac5122daec5c2cf0c50766b073facde42">SOCK_DTLS_1_3</a> = 3
 }</td></tr>
<tr class="memdesc:ga0c6a8ceda748c82eca58fbab436ca300"><td class="mdescLeft">&#160;</td><td class="mdescRight">DTLS version number <a class="anchor" id="sock_dtls_prot_version"></a>.  <a href="#ga0c6a8ceda748c82eca58fbab436ca300">More...</a><br /></td></tr>
<tr class="separator:ga0c6a8ceda748c82eca58fbab436ca300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacef31600358009411b6fcea11ebe07f6" id="r_gacef31600358009411b6fcea11ebe07f6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="#ggacef31600358009411b6fcea11ebe07f6a5d0ebcac70c848b4c09c9a35e40cfdaf">SOCK_DTLS_CLIENT</a> = 1
, <a class="el" href="#ggacef31600358009411b6fcea11ebe07f6af8548d1d8748a66e59667582bed23a17">SOCK_DTLS_SERVER</a> = 2
 }</td></tr>
<tr class="memdesc:gacef31600358009411b6fcea11ebe07f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">DTLS role <a class="anchor" id="sock_dtls_role"></a>.  <a href="#gacef31600358009411b6fcea11ebe07f6">More...</a><br /></td></tr>
<tr class="separator:gacef31600358009411b6fcea11ebe07f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gad41621093a9a2d9e7830e372125cb8fd" name="gad41621093a9a2d9e7830e372125cb8fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad41621093a9a2d9e7830e372125cb8fd">&#9670;&#160;</a></span>CONFIG_DTLS_FORCE_EXTENDED_MASTER_SECRET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CONFIG_DTLS_FORCE_EXTENDED_MASTER_SECRET&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Force extended master secret extension. </p>

<p class="definition">Definition at line <a class="el" href="sock_2dtls_8h_source.html#l00588">588</a> of file <a class="el" href="sock_2dtls_8h_source.html">dtls.h</a>.</p>

</div>
</div>
<a id="ga05770995cf620f04210dc5517517db70" name="ga05770995cf620f04210dc5517517db70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05770995cf620f04210dc5517517db70">&#9670;&#160;</a></span>CONFIG_DTLS_FORCE_RENEGOTIATION_INFO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CONFIG_DTLS_FORCE_RENEGOTIATION_INFO&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Force renegotiation info extension. </p>

<p class="definition">Definition at line <a class="el" href="sock_2dtls_8h_source.html#l00595">595</a> of file <a class="el" href="sock_2dtls_8h_source.html">dtls.h</a>.</p>

</div>
</div>
<a id="gad77967da0dcabd6ceea9e523897b6798" name="gad77967da0dcabd6ceea9e523897b6798"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad77967da0dcabd6ceea9e523897b6798">&#9670;&#160;</a></span>DTLS_HANDSHAKE_BUFSIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DTLS_HANDSHAKE_BUFSIZE&#160;&#160;&#160;(1 &lt;&lt; <a class="el" href="group__net__sock__dtls__conf.html#ga0cbc6d1ac3648c3e4b6803d0272535ef">CONFIG_DTLS_HANDSHAKE_BUFSIZE_EXP</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Size buffer used in handshake to hold credentials. </p>

<p class="definition">Definition at line <a class="el" href="sock_2dtls_8h_source.html#l00576">576</a> of file <a class="el" href="sock_2dtls_8h_source.html">dtls.h</a>.</p>

</div>
</div>
<a id="ga3f7ccb93f455150d01aad0295d398762" name="ga3f7ccb93f455150d01aad0295d398762"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f7ccb93f455150d01aad0295d398762">&#9670;&#160;</a></span>SOCK_DTLS_HANDSHAKE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCK_DTLS_HANDSHAKE&#160;&#160;&#160;(<a class="el" href="group__cpu__atmega__common.html#ga3396cf9fb0ff5af3a18dd2a2bbdb21e1">EXDEV</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return value for a successful handshake. </p>

<p class="definition">Definition at line <a class="el" href="sock_2dtls_8h_source.html#l00582">582</a> of file <a class="el" href="sock_2dtls_8h_source.html">dtls.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga9512682d85257239769e4f62d3968839" name="ga9512682d85257239769e4f62d3968839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9512682d85257239769e4f62d3968839">&#9670;&#160;</a></span>sock_dtls_aux_rx_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structsock__udp__aux__rx__t.html">sock_udp_aux_rx_t</a> <a class="el" href="#ga9512682d85257239769e4f62d3968839">sock_dtls_aux_rx_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary data provided when receiving using an DTLS sock object. </p>
<dl class="section warning"><dt>Warning</dt><dd>Implementations of this API may rely on this type to be compatible with <a class="el" href="structsock__udp__aux__rx__t.html">sock_udp_aux_rx_t</a>. These implementations need to be updated, if this is no longer the case. Users of this API should not rely on this compatibility </dd></dl>

<p class="definition">Definition at line <a class="el" href="sock_2dtls_8h_source.html#l00646">646</a> of file <a class="el" href="sock_2dtls_8h_source.html">dtls.h</a>.</p>

</div>
</div>
<a id="gac7bc6f25016a05b5b793eb5d4745166a" name="gac7bc6f25016a05b5b793eb5d4745166a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7bc6f25016a05b5b793eb5d4745166a">&#9670;&#160;</a></span>sock_dtls_aux_tx_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structsock__udp__aux__tx__t.html">sock_udp_aux_tx_t</a> <a class="el" href="#gac7bc6f25016a05b5b793eb5d4745166a">sock_dtls_aux_tx_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary data provided when sending using an DTLS sock object. </p>
<dl class="section warning"><dt>Warning</dt><dd>Implementations of this API may rely on this type to be compatible with <a class="el" href="structsock__udp__aux__rx__t.html">sock_udp_aux_rx_t</a>. These implementations need to be updated, if this is no longer the case. Users of this API should not rely on this compatibility </dd></dl>

<p class="definition">Definition at line <a class="el" href="sock_2dtls_8h_source.html#l00656">656</a> of file <a class="el" href="sock_2dtls_8h_source.html">dtls.h</a>.</p>

</div>
</div>
<a id="ga8595b9670004ad4afc5738109ecce649" name="ga8595b9670004ad4afc5738109ecce649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8595b9670004ad4afc5738109ecce649">&#9670;&#160;</a></span>sock_dtls_session_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structsock__dtls__session.html">sock_dtls_session</a> <a class="el" href="#ga8595b9670004ad4afc5738109ecce649">sock_dtls_session_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Information about a created session. </p>

<p class="definition">Definition at line <a class="el" href="sock_2dtls_8h_source.html#l00636">636</a> of file <a class="el" href="sock_2dtls_8h_source.html">dtls.h</a>.</p>

</div>
</div>
<a id="gaa63acc71681400dd4b856ce09e27cafb" name="gaa63acc71681400dd4b856ce09e27cafb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa63acc71681400dd4b856ce09e27cafb">&#9670;&#160;</a></span>sock_dtls_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structsock__dtls.html">sock_dtls</a> <a class="el" href="group__net__sock__async.html#gaa63acc71681400dd4b856ce09e27cafb">sock_dtls_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for a DTLS sock object. </p>
<dl class="section note"><dt>Note</dt><dd>API implementers: <code>struct <a class="el" href="structsock__dtls.html" title="Information about DTLS sock.">sock_dtls</a></code> needs to be defined by an implementation-specific <code><a class="el" href="sock__dtls__types_8h.html" title="tinydtls-specific types and functions definitions">sock_dtls_types.h</a></code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sock_2dtls_8h_source.html#l00627">627</a> of file <a class="el" href="sock_2dtls_8h_source.html">dtls.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga0c6a8ceda748c82eca58fbab436ca300" name="ga0c6a8ceda748c82eca58fbab436ca300"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c6a8ceda748c82eca58fbab436ca300">&#9670;&#160;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DTLS version number <a class="anchor" id="sock_dtls_prot_version"></a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga0c6a8ceda748c82eca58fbab436ca300a1c0824e2bb84e5d4654893ded0788bbb" name="gga0c6a8ceda748c82eca58fbab436ca300a1c0824e2bb84e5d4654893ded0788bbb"></a>SOCK_DTLS_1_0&#160;</td><td class="fielddoc"><p>DTLS version 1.0. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0c6a8ceda748c82eca58fbab436ca300a3d86ab5555dcad0072067eeca3db9696" name="gga0c6a8ceda748c82eca58fbab436ca300a3d86ab5555dcad0072067eeca3db9696"></a>SOCK_DTLS_1_2&#160;</td><td class="fielddoc"><p>DTLS version 1.2. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0c6a8ceda748c82eca58fbab436ca300ac5122daec5c2cf0c50766b073facde42" name="gga0c6a8ceda748c82eca58fbab436ca300ac5122daec5c2cf0c50766b073facde42"></a>SOCK_DTLS_1_3&#160;</td><td class="fielddoc"><p>DTLS version 1.3. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="sock_2dtls_8h_source.html#l00603">603</a> of file <a class="el" href="sock_2dtls_8h_source.html">dtls.h</a>.</p>

</div>
</div>
<a id="gacef31600358009411b6fcea11ebe07f6" name="gacef31600358009411b6fcea11ebe07f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacef31600358009411b6fcea11ebe07f6">&#9670;&#160;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DTLS role <a class="anchor" id="sock_dtls_role"></a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggacef31600358009411b6fcea11ebe07f6a5d0ebcac70c848b4c09c9a35e40cfdaf" name="ggacef31600358009411b6fcea11ebe07f6a5d0ebcac70c848b4c09c9a35e40cfdaf"></a>SOCK_DTLS_CLIENT&#160;</td><td class="fielddoc"><p>Endpoint client role. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacef31600358009411b6fcea11ebe07f6af8548d1d8748a66e59667582bed23a17" name="ggacef31600358009411b6fcea11ebe07f6af8548d1d8748a66e59667582bed23a17"></a>SOCK_DTLS_SERVER&#160;</td><td class="fielddoc"><p>Endpoint server role. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="sock_2dtls_8h_source.html#l00615">615</a> of file <a class="el" href="sock_2dtls_8h_source.html">dtls.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga47fde8af808ceed2db7fefbb05bbd04c" name="ga47fde8af808ceed2db7fefbb05bbd04c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47fde8af808ceed2db7fefbb05bbd04c">&#9670;&#160;</a></span>sock_dtls_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sock_dtls_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__net__sock__async.html#gaa63acc71681400dd4b856ce09e27cafb">sock_dtls_t</a> *</td>          <td class="paramname"><span class="paramname"><em>sock</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes a DTLS sock. </p>
<p>Releases any memory allocated by sock_dtls_create(). This function does NOT close the UDP sock used by the DTLS sock. After the call to this function, user will have to call <a class="el" href="group__net__sock__udp.html#ga9bab7d0998b2c49e66bab0f03367298a">sock_udp_close()</a> to close the UDP sock.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>(sock != NULL)</code></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>DTLS sock to close </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga10998fac05f15688f9dd34a22c7bb682" name="ga10998fac05f15688f9dd34a22c7bb682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10998fac05f15688f9dd34a22c7bb682">&#9670;&#160;</a></span>sock_dtls_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sock_dtls_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__net__sock__async.html#gaa63acc71681400dd4b856ce09e27cafb">sock_dtls_t</a> *</td>          <td class="paramname"><span class="paramname"><em>sock</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__net__sock__async.html#ga3cb61a4ee66c9c235e4f22860658698c">sock_udp_t</a> *</td>          <td class="paramname"><span class="paramname"><em>udp_sock</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__net__credman.html#ga89fc115fe10d879da7faf1c0d0f901a7">credman_tag_t</a></td>          <td class="paramname"><span class="paramname"><em>tag</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>version</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>role</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new DTLS sock object. </p>
<p>Takes an initialized UDP sock and uses it for the transport. Memory allocation functions required by the underlying DTLS stack can be called in this function.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__net__credman.html" title="Credentials management module for (D)TLS">(D)TLS Credential Manager</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">sock</td><td>The resulting DTLS sock object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">udp_sock</td><td>Existing UDP sock initialized with <a class="el" href="group__net__sock__udp.html#ga20fa4b890dff1c97a63075090e6f9d7d">sock_udp_create()</a> to be used underneath. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>Credential tag of <code>sock</code>. The sock will only use credentials with the tags registered to it (see <a class="el" href="group__net__sock__dtls__creds.html#gae9388932dba7c8ade1245ff296e810f7">sock_dtls_add_credential</a>). Set to <a class="el" href="group__net__credman.html#gaef3b87d09d3032ab13e653756f34da92">CREDMAN_TAG_EMPTY</a> to create a sock with an empty tag list. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">version</td><td><a class="el" href="#sock_dtls_prot_version">DTLS version</a> to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">role</td><td><a class="el" href="#sock_dtls_role">Role</a> of the endpoint.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. </dd>
<dd>
-1 on error </dd></dl>

</div>
</div>
<a id="ga7c57588ebd846e5324bf24ffd97269a4" name="ga7c57588ebd846e5324bf24ffd97269a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c57588ebd846e5324bf24ffd97269a4">&#9670;&#160;</a></span>sock_dtls_get_udp_sock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__net__sock__async.html#ga3cb61a4ee66c9c235e4f22860658698c">sock_udp_t</a> * sock_dtls_get_udp_sock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__net__sock__async.html#gaa63acc71681400dd4b856ce09e27cafb">sock_dtls_t</a> *</td>          <td class="paramname"><span class="paramname"><em>sock</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get underlying UDP sock. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>sock != NULL</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sock</td><td>DTLS sock to get UDP sock from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The underlying UDP sock. </dd></dl>

</div>
</div>
<a id="ga53b88f47412139d54c8e480404435ea8" name="ga53b88f47412139d54c8e480404435ea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53b88f47412139d54c8e480404435ea8">&#9670;&#160;</a></span>sock_dtls_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sock_dtls_init </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called exactly once during <code>auto_init</code>. </p>
<p>Calls the initialization function required by the DTLS stack used. </p>

</div>
</div>
<a id="ga893395d4c18709210d66d979a2f9ea69" name="ga893395d4c18709210d66d979a2f9ea69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga893395d4c18709210d66d979a2f9ea69">&#9670;&#160;</a></span>sock_dtls_recv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ssize_t sock_dtls_recv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__net__sock__async.html#gaa63acc71681400dd4b856ce09e27cafb">sock_dtls_t</a> *</td>          <td class="paramname"><span class="paramname"><em>sock</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga8595b9670004ad4afc5738109ecce649">sock_dtls_session_t</a> *</td>          <td class="paramname"><span class="paramname"><em>remote</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>maxlen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>timeout</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receive handshake messages and application data from remote peer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sock</td><td>DTLS sock to use. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">remote</td><td>Remote DTLS session of the received data. Cannot be NULL. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>Pointer where the received data should be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxlen</td><td>Maximum space available at <code>data</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Receive timeout in microseconds. If 0 and no data is available, the function returns immediately. May be SOCK_NO_TIMEOUT to wait until data is available.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Function may block if data is not available and <code>timeout</code> != 0</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes received on success </dd>
<dd>
-SOCK_DTLS_HANDSHAKE when new handshake is completed </dd>
<dd>
-EADDRNOTAVAIL, if the local endpoint of <code>sock</code> is not set. </dd>
<dd>
-EAGAIN, if <code>timeout</code> is <code>0</code> and no data is available. </dd>
<dd>
-EINVAL, if <code>remote</code> is invalid or <code>sock</code> is not properly initialized (or closed while <a class="el" href="#ga893395d4c18709210d66d979a2f9ea69" title="Receive handshake messages and application data from remote peer.">sock_dtls_recv()</a> blocks). </dd>
<dd>
-ENOBUFS, if buffer space is not large enough to store received data. </dd>
<dd>
-ENOMEM, if no memory was available to receive <code>data</code>. </dd>
<dd>
-ETIMEDOUT, if <code>timeout</code> expired. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sock_2dtls_8h_source.html#l00821">821</a> of file <a class="el" href="sock_2dtls_8h_source.html">dtls.h</a>.</p>

</div>
</div>
<a id="ga91476f35b5ea85b789e19cb3fd256f42" name="ga91476f35b5ea85b789e19cb3fd256f42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91476f35b5ea85b789e19cb3fd256f42">&#9670;&#160;</a></span>sock_dtls_recv_aux()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t sock_dtls_recv_aux </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__net__sock__async.html#gaa63acc71681400dd4b856ce09e27cafb">sock_dtls_t</a> *</td>          <td class="paramname"><span class="paramname"><em>sock</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga8595b9670004ad4afc5738109ecce649">sock_dtls_session_t</a> *</td>          <td class="paramname"><span class="paramname"><em>remote</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>maxlen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>timeout</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga9512682d85257239769e4f62d3968839">sock_dtls_aux_rx_t</a> *</td>          <td class="paramname"><span class="paramname"><em>aux</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive handshake messages and application data from remote peer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sock</td><td>DTLS sock to use. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">remote</td><td>Remote DTLS session of the received data. Cannot be NULL. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>Pointer where the received data should be stored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxlen</td><td>Maximum space available at <code>data</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Receive timeout in microseconds. If 0 and no data is available, the function returns immediately. May be SOCK_NO_TIMEOUT to wait until data is available. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">aux</td><td>Auxiliary data about the received datagram. May be <code>NULL</code>, if it is not required by the application.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Function may block if data is not available and <code>timeout</code> != 0</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes received on success </dd>
<dd>
-SOCK_DTLS_HANDSHAKE when new handshake is completed </dd>
<dd>
-EADDRNOTAVAIL, if the local endpoint of <code>sock</code> is not set. </dd>
<dd>
-EAGAIN, if <code>timeout</code> is <code>0</code> and no data is available. </dd>
<dd>
-EINVAL, if <code>remote</code> is invalid or <code>sock</code> is not properly initialized (or closed while <a class="el" href="#ga893395d4c18709210d66d979a2f9ea69" title="Receive handshake messages and application data from remote peer.">sock_dtls_recv()</a> blocks). </dd>
<dd>
-ENOBUFS, if buffer space is not large enough to store received data. </dd>
<dd>
-ENOMEM, if no memory was available to receive <code>data</code>. </dd>
<dd>
-ETIMEDOUT, if <code>timeout</code> expired. </dd></dl>

</div>
</div>
<a id="ga026748dd9ad74a8a216eaad086551a7d" name="ga026748dd9ad74a8a216eaad086551a7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga026748dd9ad74a8a216eaad086551a7d">&#9670;&#160;</a></span>sock_dtls_recv_buf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ssize_t sock_dtls_recv_buf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__net__sock__async.html#gaa63acc71681400dd4b856ce09e27cafb">sock_dtls_t</a> *</td>          <td class="paramname"><span class="paramname"><em>sock</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga8595b9670004ad4afc5738109ecce649">sock_dtls_session_t</a> *</td>          <td class="paramname"><span class="paramname"><em>remote</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **</td>          <td class="paramname"><span class="paramname"><em>buf_ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>timeout</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decrypts and provides stack-internal buffer space containing a message from a remote peer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sock</td><td>DTLS sock to use. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">remote</td><td>Remote DTLS session of the received data. Cannot be NULL. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>Pointer to a stack-internal buffer space containing the received data. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buf_ctx</td><td>Stack-internal buffer context. If it points to a <code>NULL</code> pointer, the stack returns a new buffer space for a new packet. If it does not point to a <code>NULL</code> pointer, an existing context is assumed to get a next segment in a buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Receive timeout in microseconds. If 0 and no data is available, the function returns immediately. May be SOCK_NO_TIMEOUT to wait until data is available.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd><b class="text-danger">This feature is experimental!</b><br  />
 This function is quite new, not implemented for all stacks yet, and may be subject to sudden API changes. Do not use in production if this is unacceptable.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Function may block if data is not available and <code>timeout</code> != 0</dd>
<dd>
Function blocks if no packet is currently waiting.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes received on success. May not be the complete payload. Continue calling with the returned <code>buf_ctx</code> to get more buffers until result is 0 or an error. </dd>
<dd>
0, if no received data is available, but everything is in order. If <code>buf_ctx</code> was provided, it was released. </dd>
<dd>
-EADDRNOTAVAIL, if the local endpoint of <code>sock</code> is not set. </dd>
<dd>
-EAGAIN, if <code>timeout</code> is <code>0</code> and no data is available. </dd>
<dd>
-EINVAL, if <code>remote</code> is invalid or <code>sock</code> is not properly initialized (or closed while <a class="el" href="#ga893395d4c18709210d66d979a2f9ea69" title="Receive handshake messages and application data from remote peer.">sock_dtls_recv()</a> blocks). </dd>
<dd>
-ENOMEM, if no memory was available to receive <code>data</code>. </dd>
<dd>
-ETIMEDOUT, if <code>timeout</code> expired. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sock_2dtls_8h_source.html#l00915">915</a> of file <a class="el" href="sock_2dtls_8h_source.html">dtls.h</a>.</p>

</div>
</div>
<a id="ga208fb85350aa404db39305d6fe6cc0a9" name="ga208fb85350aa404db39305d6fe6cc0a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga208fb85350aa404db39305d6fe6cc0a9">&#9670;&#160;</a></span>sock_dtls_recv_buf_aux()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t sock_dtls_recv_buf_aux </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__net__sock__async.html#gaa63acc71681400dd4b856ce09e27cafb">sock_dtls_t</a> *</td>          <td class="paramname"><span class="paramname"><em>sock</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga8595b9670004ad4afc5738109ecce649">sock_dtls_session_t</a> *</td>          <td class="paramname"><span class="paramname"><em>remote</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **</td>          <td class="paramname"><span class="paramname"><em>buf_ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>timeout</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga9512682d85257239769e4f62d3968839">sock_dtls_aux_rx_t</a> *</td>          <td class="paramname"><span class="paramname"><em>aux</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrypts and provides stack-internal buffer space containing a message from a remote peer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sock</td><td>DTLS sock to use. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">remote</td><td>Remote DTLS session of the received data. Cannot be NULL. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>Pointer to a stack-internal buffer space containing the received data. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buf_ctx</td><td>Stack-internal buffer context. If it points to a <code>NULL</code> pointer, the stack returns a new buffer space for a new packet. If it does not point to a <code>NULL</code> pointer, an existing context is assumed to get a next segment in a buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Receive timeout in microseconds. If 0 and no data is available, the function returns immediately. May be SOCK_NO_TIMEOUT to wait until data is available. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">aux</td><td>Auxiliary data about the received datagram. May be <code>NULL</code>, if it is not required by the application.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd><b class="text-danger">This feature is experimental!</b><br  />
 This function is quite new, not implemented for all stacks yet, and may be subject to sudden API changes. Do not use in production if this is unacceptable.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Function may block if data is not available and <code>timeout</code> != 0</dd>
<dd>
Function blocks if no packet is currently waiting.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes received on success. May not be the complete payload. Continue calling with the returned <code>buf_ctx</code> to get more buffers until result is 0 or an error. </dd>
<dd>
0, if no received data is available, but everything is in order. If <code>buf_ctx</code> was provided, it was released. </dd>
<dd>
-EADDRNOTAVAIL, if the local endpoint of <code>sock</code> is not set. </dd>
<dd>
-EAGAIN, if <code>timeout</code> is <code>0</code> and no data is available. </dd>
<dd>
-EINVAL, if <code>remote</code> is invalid or <code>sock</code> is not properly initialized (or closed while <a class="el" href="#ga893395d4c18709210d66d979a2f9ea69" title="Receive handshake messages and application data from remote peer.">sock_dtls_recv()</a> blocks). </dd>
<dd>
-ENOMEM, if no memory was available to receive <code>data</code>. </dd>
<dd>
-ETIMEDOUT, if <code>timeout</code> expired. </dd></dl>

</div>
</div>
<a id="ga630360b12614e2b57fca0cd81cdf9e4e" name="ga630360b12614e2b57fca0cd81cdf9e4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga630360b12614e2b57fca0cd81cdf9e4e">&#9670;&#160;</a></span>sock_dtls_send()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ssize_t sock_dtls_send </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__net__sock__async.html#gaa63acc71681400dd4b856ce09e27cafb">sock_dtls_t</a> *</td>          <td class="paramname"><span class="paramname"><em>sock</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga8595b9670004ad4afc5738109ecce649">sock_dtls_session_t</a> *</td>          <td class="paramname"><span class="paramname"><em>remote</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>timeout</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encrypts and sends a message to a remote peer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sock</td><td>DTLS sock to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote</td><td>DTLS session to use. A new session will be created if no session exist between client and server. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer where the data to be send are stored </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of <code>data</code> to be send </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Handshake timeout in microseconds. If <code>timeout &gt; 0</code>, will start a new handshake if no session exists yet. The function will block until handshake completed or timed out. May be SOCK_NO_TIMEOUT to block indefinitely until handshake complete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When blocking, we will need an extra thread to call <a class="el" href="#ga893395d4c18709210d66d979a2f9ea69">sock_dtls_recv()</a> function to handle the incoming handshake messages. An example for a blocking handshake is:<ol type="1">
<li>Create an empty <a class="el" href="#ga8595b9670004ad4afc5738109ecce649">sock_dtls_session_t</a> object.</li>
<li>Set the UDP endpoint of the peer you want to connect to in the session object with <a class="el" href="#gaddac5bc68779c993cc613042a2515b12">sock_dtls_session_set_udp_ep()</a>.</li>
<li>Call <a class="el" href="#ga630360b12614e2b57fca0cd81cdf9e4e">sock_dtls_send()</a> with a timeout greater than 0. The send function blocks until the handshake completes or the timeout expires. If the handshake was successful the data has been sent.</li>
</ol>
</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes sent on success </dd>
<dd>
-ENOTCONN, if <code>timeout == 0</code> and no existing session exists with <code>remote</code> </dd>
<dd>
-EADDRINUSE, if <a class="el" href="structsock__dtls.html#a71b7e51c4a802f947f347e837f800612" title="Underlying UDP sock to use.">sock_dtls_t::udp_sock</a> has no local end-point. </dd>
<dd>
-EAFNOSUPPORT, if <code>remote-&gt;ep != NULL</code> and sock_dtls_session_t::ep::family of <code>remote</code> is != AF_UNSPEC and not supported. </dd>
<dd>
-EINVAL, if <a class="el" href="struct__sock__tl__ep.html#a1c9ec7e621447123a22646bb39fc81a9" title="address">sock_udp_ep_t::addr</a> of <code>remote-&gt;ep</code> is an invalid address. </dd>
<dd>
-EINVAL, if <a class="el" href="struct__sock__tl__ep.html#a00b5dbff09ee8e87806fff6280966140" title="transport layer port (in host byte order)">sock_udp_ep_t::port</a> of <code>remote-&gt;ep</code> is 0. </dd>
<dd>
-ENOMEM, if no memory was available to send <code>data</code>. </dd>
<dd>
-ETIMEDOUT, <code>0 &lt; timeout &lt; SOCK_NO_TIMEOUT</code> and timed out. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sock_2dtls_8h_source.html#l01049">1049</a> of file <a class="el" href="sock_2dtls_8h_source.html">dtls.h</a>.</p>

</div>
</div>
<a id="ga1abd23c69aef1066a139cfc2ffb0d3e7" name="ga1abd23c69aef1066a139cfc2ffb0d3e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1abd23c69aef1066a139cfc2ffb0d3e7">&#9670;&#160;</a></span>sock_dtls_send_aux()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ssize_t sock_dtls_send_aux </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__net__sock__async.html#gaa63acc71681400dd4b856ce09e27cafb">sock_dtls_t</a> *</td>          <td class="paramname"><span class="paramname"><em>sock</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga8595b9670004ad4afc5738109ecce649">sock_dtls_session_t</a> *</td>          <td class="paramname"><span class="paramname"><em>remote</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>timeout</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gac7bc6f25016a05b5b793eb5d4745166a">sock_dtls_aux_tx_t</a> *</td>          <td class="paramname"><span class="paramname"><em>aux</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encrypts and sends a message to a remote peer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sock</td><td>DTLS sock to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote</td><td>DTLS session to use. A new session will be created if no session exist between client and server. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer where the data to be send are stored </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of <code>data</code> to be send </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Handshake timeout in microseconds. If <code>timeout &gt; 0</code>, will start a new handshake if no session exists yet. The function will block until handshake completed or timed out. May be SOCK_NO_TIMEOUT to block indefinitely until handshake complete. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">aux</td><td>Auxiliary data about the transmission. May be <code>NULL</code>, if it is not required by the application.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When blocking, we will need an extra thread to call <a class="el" href="#ga893395d4c18709210d66d979a2f9ea69">sock_dtls_recv()</a> function to handle the incoming handshake messages.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes sent on success </dd>
<dd>
-ENOTCONN, if <code>timeout == 0</code> and no existing session exists with <code>remote</code> </dd>
<dd>
-EADDRINUSE, if <a class="el" href="structsock__dtls.html#a71b7e51c4a802f947f347e837f800612" title="Underlying UDP sock to use.">sock_dtls_t::udp_sock</a> has no local end-point. </dd>
<dd>
-EAFNOSUPPORT, if <code>remote-&gt;ep != NULL</code> and sock_dtls_session_t::ep::family of <code>remote</code> is != AF_UNSPEC and not supported. </dd>
<dd>
-EINVAL, if <a class="el" href="struct__sock__tl__ep.html#a1c9ec7e621447123a22646bb39fc81a9" title="address">sock_udp_ep_t::addr</a> of <code>remote-&gt;ep</code> is an invalid address. </dd>
<dd>
-EINVAL, if <a class="el" href="struct__sock__tl__ep.html#a00b5dbff09ee8e87806fff6280966140" title="transport layer port (in host byte order)">sock_udp_ep_t::port</a> of <code>remote-&gt;ep</code> is 0. </dd>
<dd>
-ENOMEM, if no memory was available to send <code>data</code>. </dd>
<dd>
-ETIMEDOUT, <code>0 &lt; timeout &lt; SOCK_NO_TIMEOUT</code> and timed out. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sock_2dtls_8h_source.html#l00995">995</a> of file <a class="el" href="sock_2dtls_8h_source.html">dtls.h</a>.</p>

</div>
</div>
<a id="ga16197978f12dc0efd521e8dba2853c45" name="ga16197978f12dc0efd521e8dba2853c45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16197978f12dc0efd521e8dba2853c45">&#9670;&#160;</a></span>sock_dtls_sendv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ssize_t sock_dtls_sendv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__net__sock__async.html#gaa63acc71681400dd4b856ce09e27cafb">sock_dtls_t</a> *</td>          <td class="paramname"><span class="paramname"><em>sock</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga8595b9670004ad4afc5738109ecce649">sock_dtls_session_t</a> *</td>          <td class="paramname"><span class="paramname"><em>remote</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__sys__iolist.html#gaa17f91ef26edec149cd806d8457aa3a0">iolist_t</a> *</td>          <td class="paramname"><span class="paramname"><em>snips</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>timeout</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encrypts and sends a message to a remote peer with non-continous payload. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sock</td><td>DTLS sock to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote</td><td>DTLS session to use. A new session will be created if no session exist between client and server. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">snips</td><td>List of payload chunks, will be processed in order. May be <code>NULL</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Handshake timeout in microseconds. If <code>timeout &gt; 0</code>, will start a new handshake if no session exists yet. The function will block until handshake completed or timed out. May be SOCK_NO_TIMEOUT to block indefinitely until handshake complete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When blocking, we will need an extra thread to call <a class="el" href="#ga893395d4c18709210d66d979a2f9ea69">sock_dtls_recv()</a> function to handle the incoming handshake messages. An example for a blocking handshake is:<ol type="1">
<li>Create an empty <a class="el" href="#ga8595b9670004ad4afc5738109ecce649">sock_dtls_session_t</a> object.</li>
<li>Set the UDP endpoint of the peer you want to connect to in the session object with <a class="el" href="#gaddac5bc68779c993cc613042a2515b12">sock_dtls_session_set_udp_ep()</a>.</li>
<li>Call <a class="el" href="#ga630360b12614e2b57fca0cd81cdf9e4e">sock_dtls_send()</a> with a timeout greater than 0. The send function blocks until the handshake completes or the timeout expires. If the handshake was successful the data has been sent.</li>
</ol>
</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes sent on success </dd>
<dd>
-ENOTCONN, if <code>timeout == 0</code> and no existing session exists with <code>remote</code> </dd>
<dd>
-EADDRINUSE, if <a class="el" href="structsock__dtls.html#a71b7e51c4a802f947f347e837f800612" title="Underlying UDP sock to use.">sock_dtls_t::udp_sock</a> has no local end-point. </dd>
<dd>
-EAFNOSUPPORT, if <code>remote-&gt;ep != NULL</code> and sock_dtls_session_t::ep::family of <code>remote</code> is != AF_UNSPEC and not supported. </dd>
<dd>
-EINVAL, if <a class="el" href="struct__sock__tl__ep.html#a1c9ec7e621447123a22646bb39fc81a9" title="address">sock_udp_ep_t::addr</a> of <code>remote-&gt;ep</code> is an invalid address. </dd>
<dd>
-EINVAL, if <a class="el" href="struct__sock__tl__ep.html#a00b5dbff09ee8e87806fff6280966140" title="transport layer port (in host byte order)">sock_udp_ep_t::port</a> of <code>remote-&gt;ep</code> is 0. </dd>
<dd>
-ENOMEM, if no memory was available to send <code>data</code>. </dd>
<dd>
-ETIMEDOUT, <code>0 &lt; timeout &lt; SOCK_NO_TIMEOUT</code> and timed out. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sock_2dtls_8h_source.html#l01097">1097</a> of file <a class="el" href="sock_2dtls_8h_source.html">dtls.h</a>.</p>

</div>
</div>
<a id="gaebdaa80fe988205e8aa2106898095e8c" name="gaebdaa80fe988205e8aa2106898095e8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaebdaa80fe988205e8aa2106898095e8c">&#9670;&#160;</a></span>sock_dtls_sendv_aux()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t sock_dtls_sendv_aux </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__net__sock__async.html#gaa63acc71681400dd4b856ce09e27cafb">sock_dtls_t</a> *</td>          <td class="paramname"><span class="paramname"><em>sock</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga8595b9670004ad4afc5738109ecce649">sock_dtls_session_t</a> *</td>          <td class="paramname"><span class="paramname"><em>remote</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__sys__iolist.html#gaa17f91ef26edec149cd806d8457aa3a0">iolist_t</a> *</td>          <td class="paramname"><span class="paramname"><em>snips</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>timeout</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gac7bc6f25016a05b5b793eb5d4745166a">sock_dtls_aux_tx_t</a> *</td>          <td class="paramname"><span class="paramname"><em>aux</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encrypts and sends a message to a remote peer with non-continous payload. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sock</td><td>DTLS sock to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote</td><td>DTLS session to use. A new session will be created if no session exist between client and server. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">snips</td><td>List of payload chunks, will be processed in order. May be <code>NULL</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Handshake timeout in microseconds. If <code>timeout &gt; 0</code>, will start a new handshake if no session exists yet. The function will block until handshake completed or timed out. May be SOCK_NO_TIMEOUT to block indefinitely until handshake complete. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">aux</td><td>Auxiliary data about the transmission. May be <code>NULL</code>, if it is not required by the application.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When blocking, we will need an extra thread to call <a class="el" href="#ga893395d4c18709210d66d979a2f9ea69">sock_dtls_recv()</a> function to handle the incoming handshake messages.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes sent on success </dd>
<dd>
-ENOTCONN, if <code>timeout == 0</code> and no existing session exists with <code>remote</code> </dd>
<dd>
-EADDRINUSE, if <a class="el" href="structsock__dtls.html#a71b7e51c4a802f947f347e837f800612" title="Underlying UDP sock to use.">sock_dtls_t::udp_sock</a> has no local end-point. </dd>
<dd>
-EAFNOSUPPORT, if <code>remote-&gt;ep != NULL</code> and sock_dtls_session_t::ep::family of <code>remote</code> is != AF_UNSPEC and not supported. </dd>
<dd>
-EINVAL, if <a class="el" href="struct__sock__tl__ep.html#a1c9ec7e621447123a22646bb39fc81a9" title="address">sock_udp_ep_t::addr</a> of <code>remote-&gt;ep</code> is an invalid address. </dd>
<dd>
-EINVAL, if <a class="el" href="struct__sock__tl__ep.html#a00b5dbff09ee8e87806fff6280966140" title="transport layer port (in host byte order)">sock_udp_ep_t::port</a> of <code>remote-&gt;ep</code> is 0. </dd>
<dd>
-ENOMEM, if no memory was available to send <code>data</code>. </dd>
<dd>
-ETIMEDOUT, <code>0 &lt; timeout &lt; SOCK_NO_TIMEOUT</code> and timed out. </dd></dl>

</div>
</div>
<a id="ga5e2688dd03fe5d365ec81c4f82ff03ed" name="ga5e2688dd03fe5d365ec81c4f82ff03ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e2688dd03fe5d365ec81c4f82ff03ed">&#9670;&#160;</a></span>sock_dtls_session_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sock_dtls_session_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__net__sock__async.html#gaa63acc71681400dd4b856ce09e27cafb">sock_dtls_t</a> *</td>          <td class="paramname"><span class="paramname"><em>sock</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga8595b9670004ad4afc5738109ecce649">sock_dtls_session_t</a> *</td>          <td class="paramname"><span class="paramname"><em>remote</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys an existing DTLS session. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>(sock != NULL) &amp;&amp; (ep != NULL)</code></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sock</td><td><a class="el" href="group__net__sock__async.html#gaa63acc71681400dd4b856ce09e27cafb">sock_dtls_t</a>, which the session is created on </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote</td><td>Remote session to destroy</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>For tinyDTLS this function destroys the session object right after notifying the remote peer about the closing. This is an interim solution, preventing endlessly blocked session slots, but allows as a consequence truncation attacks. More details in the <a href="https://github.com/eclipse/tinydtls/issues/95">issue</a>. </dd></dl>

</div>
</div>
<a id="gaceffefc3c421cb696560e87ecf040161" name="gaceffefc3c421cb696560e87ecf040161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaceffefc3c421cb696560e87ecf040161">&#9670;&#160;</a></span>sock_dtls_session_get_udp_ep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sock_dtls_session_get_udp_ep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ga8595b9670004ad4afc5738109ecce649">sock_dtls_session_t</a> *</td>          <td class="paramname"><span class="paramname"><em>session</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__net__sock__udp.html#gaedc829c7973d7870c1ec078f9ffd45a1">sock_udp_ep_t</a> *</td>          <td class="paramname"><span class="paramname"><em>ep</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the remote UDP endpoint from a session. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>(session != NULL) &amp;&amp; (ep != NULL)</code></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">session</td><td>DTLS session </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ep</td><td>UDP endpoint </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6ebde4fba6fd184710d1ec1c6285e7a2" name="ga6ebde4fba6fd184710d1ec1c6285e7a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ebde4fba6fd184710d1ec1c6285e7a2">&#9670;&#160;</a></span>sock_dtls_session_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sock_dtls_session_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__net__sock__async.html#gaa63acc71681400dd4b856ce09e27cafb">sock_dtls_t</a> *</td>          <td class="paramname"><span class="paramname"><em>sock</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__net__sock__udp.html#gaedc829c7973d7870c1ec078f9ffd45a1">sock_udp_ep_t</a> *</td>          <td class="paramname"><span class="paramname"><em>ep</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga8595b9670004ad4afc5738109ecce649">sock_dtls_session_t</a> *</td>          <td class="paramname"><span class="paramname"><em>remote</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize session handshake. </p>
<p>Sends a ClientHello message to initialize the handshake. Call <a class="el" href="#ga893395d4c18709210d66d979a2f9ea69">sock_dtls_recv()</a> to finish the handshake.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sock</td><td>DTLS sock to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Remote endpoint to start a handshake with </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">remote</td><td>Resulting session</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1, if new handshake is started </dd>
<dd>
0, if there is an existing session </dd>
<dd>
-ENOMEM, not enough memory to allocate for new peer </dd>
<dd>
-EADDRNOTAVAIL, if the local endpoint of <code>sock</code> is not set. </dd>
<dd>
-EINVAL, if <code>remote</code> is invalid or <code>sock</code> is not properly initialized (or closed while <a class="el" href="group__net__sock__udp.html#gacc31d9fd5c02e95e4ca7257c808e53ac" title="Receives a UDP message from a remote end point.">sock_udp_recv()</a> blocks). </dd></dl>

</div>
</div>
<a id="gaddac5bc68779c993cc613042a2515b12" name="gaddac5bc68779c993cc613042a2515b12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaddac5bc68779c993cc613042a2515b12">&#9670;&#160;</a></span>sock_dtls_session_set_udp_ep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sock_dtls_session_set_udp_ep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga8595b9670004ad4afc5738109ecce649">sock_dtls_session_t</a> *</td>          <td class="paramname"><span class="paramname"><em>session</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__net__sock__udp.html#gaedc829c7973d7870c1ec078f9ffd45a1">sock_udp_ep_t</a> *</td>          <td class="paramname"><span class="paramname"><em>ep</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the remote UDP endpoint from a session. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>(session != NULL) &amp;&amp; (ep != NULL)</code></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">session</td><td>DTLS session </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>UDP endpoint</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Function should only be needed when doing a blocking handshake with <a class="el" href="#ga630360b12614e2b57fca0cd81cdf9e4e">sock_dtls_send()</a> to set the remote UDP endpoint. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
    <div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
        <ul>
            <li class="footer">Generated on Mon Sep 23 2024 14:49:33 by <a href="http://www.doxygen.org/index.html">
                       <img class="footer" src="doxygen.png" alt="doxygen"></a> 1.12.0</li>
        </ul>
    </div>
    <!-- Include all compiled plugins (below), or include individual files as needed -->
    <script src="bootstrap.min.js"></script>
    <script src="jquery.smartmenus.min.js"></script>
    <script src="jquery.smartmenus.bootstrap.min.js"></script>
    <script src="riot-doxy.js"></script>
  </body>
</html>
