<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RIOT OS: Utility functions, macros, and types for</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<!-- <script type="text/javascript" src="jquery.js"></script> -->
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<!-- <link href="/pagefind/pagefind-ui.css" rel="stylesheet"> -->
<script src="/pagefind/pagefind-ui.js"></script>
<script>
  // Check whether the PagefindUI class is available
  if (typeof PagefindUI === 'undefined') {
    console.error('PagefindUI class is not available | Dev Build');
  } else {
    // // Remove the "searchstub" element and initialize the PagefindUI class
    // document.getElementById("#searchstub").remove();
    // Initialize the PagefindUI class with the element id "search"
    window.addEventListener('DOMContentLoaded', (event) => {
        new PagefindUI({ element: "#search", showSubResults: true });
    });
  }
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="global.css" rel="stylesheet" type="text/css" />
</head>
<body>
  <script>
    // Print the data within the NAVTREE variable from the navtreedata.js file
    var navtree = NAVTREE;
    console.log(navtree);
  </script>
<div class="flex flex-row gap-4 w-screen font-sans text-lg max-h-screen overscroll-contain justify-items-stretch bg-neutral-900">
  <!--Sidebar-->
  <div data-pagefind-ignore="all" class="w-1/3 max-w-md flex-auto h-screen bg-neutral-800 ring-2 ring-neutral-700 shadow-neutral-800 shadow-2xl rounded-xl p-3 ml-1 my-2 mr-3 flex flex-col justify-around">
    <div id="top" class="justify-self-center content-center items-center place-content-center">
      <img alt="Logo" src="riot-logo.svg"/>
      <div id="projectbrief">
        The friendly Operating System for the Internet of Things
      </div>
    </div>
    <div id="search" class="place-content-center" class="overflow-y-scroll max-h-64 bg-slate-400 ring-2 ring-white text-white" >
      <h1>Searchbar via Pagefind</h1>
      <!-- <div id="searchstub" class="flex items-center border border-gray-300 rounded-lg p-2 shadow-sm">
        <input type="text" placeholder="Search is only available in Production Build ..." class="flex-grow p-2 outline-none">
      </div> -->
    </div>
    <div id="navtree">
      <script>
        // The navtree variable is always a pair of two elements (key, value)
        // The key is the name we should display and the value is the link to the page
        // Generate the navtree from the navtreedata.js file and put it under the navtree div
        var navtree = NAVTREE[0][2];
        var navtreeHTML = "<h1>Navigation based on Doxygen</h1> <ul>";
        for (var i = 0; i < navtree.length; i++) {
          navtreeHTML += "<li><a href='" + navtree[i][1] + "'>" + navtree[i][0] + "</a></li>";
          if (i == 5) {
            navtreeHTML += '<li><h3 class="ring-2 ring-white"> Random Insert for Demonstration </h3></li>';
          }
        }
        navtreeHTML += "</ul>";
        document.getElementById("navtree").innerHTML = navtreeHTML;
      </script>
    </div>
    <ul>
      <li class="footer">
        Generated on Tue Sep 24 2024 11:16:27 by 
          <a href="http://www.doxygen.org/index.html">
            Doxygen
          </a> 
        1.12.0
      </li>
    </ul>
  </div>
  <!--Main Content-->
  <div class="hidden">
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',true);
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('group__sys__flash__utils.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Utility functions, macros, and types for<div class="ingroups"><a class="el" href="group__sys.html">System</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>read-only memory  
<a href="#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>read-only memory </p>
<p>This modules adds utility functions, macros, and functions for read-only memory. The goal is to hide the differences between modified architectures that map flash into the data address space (e.g. ARM) and those which doesn't (e.g. most AVR, Xtensa).</p>
<h1><a class="anchor" id="autotoc_md1977"></a>
Usage</h1>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="flash__utils_8h.html">flash_utils.h</a>&quot;</span></div>
<div class="ttc" id="aflash__utils_8h_html"><div class="ttname"><a href="flash__utils_8h.html">flash_utils.h</a></div><div class="ttdoc">Utility functions, macros, and types for read-only memory.</div></div>
</div><!-- fragment --><p>No module needs to be selected, this is a header-only implementation that is always available.</p>
<h1><a class="anchor" id="autotoc_md1978"></a>
Porting Code to Use <code>flash_utils</code></h1>
<p>This is mainly targeting applications developers to ease developing apps that work well on both legacy modified Harvard architectures (e.g. ATmega) and modern modified Harvard architectures (e.g. ARM, ATtiny, ...) as well as von-Neumann machines.</p>
<p>The intention is to limit in-tree use to a very small number of modules that yield the most "bang for the buck" and not leak the use of <code>flash_utils</code> through the API. Specifically, reverting to not using <code>flash_utils</code> should not be noticed by any user (unless looking at memory consumption). </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="files" name="files"></a>
Files</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flash__utils_8h.html">flash_utils.h</a></td></tr>
<tr class="memdesc:flash__utils_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility functions, macros, and types for read-only memory. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga6ac949979ebabc3d7130779422ead49a" id="r_ga6ac949979ebabc3d7130779422ead49a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6ac949979ebabc3d7130779422ead49a">FLASH_ATTR</a>&#160;&#160;&#160;&lt;IMPLEMTATION_DEFINED&gt;</td></tr>
<tr class="memdesc:ga6ac949979ebabc3d7130779422ead49a"><td class="mdescLeft">&#160;</td><td class="mdescRight">C type qualifier required to place a variable in flash.  <br /></td></tr>
<tr class="separator:ga6ac949979ebabc3d7130779422ead49a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03d3a3d9f0e2c56344cc5773edf59ed1" id="r_ga03d3a3d9f0e2c56344cc5773edf59ed1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga03d3a3d9f0e2c56344cc5773edf59ed1">PRIsflash</a>&#160;&#160;&#160;&lt;IMPLEMTATION_DEFINED&gt;</td></tr>
<tr class="memdesc:ga03d3a3d9f0e2c56344cc5773edf59ed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format specifier for printing <code>FLASH CONST char *</code>  <br /></td></tr>
<tr class="separator:ga03d3a3d9f0e2c56344cc5773edf59ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04035c94001df85bb7ed5c24d3e6257b" id="r_ga04035c94001df85bb7ed5c24d3e6257b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga04035c94001df85bb7ed5c24d3e6257b">TO_FLASH</a>(str_literal)</td></tr>
<tr class="memdesc:ga04035c94001df85bb7ed5c24d3e6257b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to allocate a string literal on flash and return a <code>FLASH_ATTR const char *</code> pointer to it Usage:  <br /></td></tr>
<tr class="separator:ga04035c94001df85bb7ed5c24d3e6257b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39a1a2e42dd44ab7f64836183f52668d" id="r_ga39a1a2e42dd44ab7f64836183f52668d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga39a1a2e42dd44ab7f64836183f52668d">FLASH_PUTS</a>(x)</td></tr>
<tr class="memdesc:ga39a1a2e42dd44ab7f64836183f52668d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience wrapper for <code>flash_puts(TO_FLASH("str literal"))</code>  <br /></td></tr>
<tr class="separator:ga39a1a2e42dd44ab7f64836183f52668d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga73b91c7dc9190b55abd2996aeedc5847" id="r_ga73b91c7dc9190b55abd2996aeedc5847"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga73b91c7dc9190b55abd2996aeedc5847">flash_strcmp</a> (const char *ram, <a class="el" href="#ga6ac949979ebabc3d7130779422ead49a">FLASH_ATTR</a> const char *flash)</td></tr>
<tr class="memdesc:ga73b91c7dc9190b55abd2996aeedc5847"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <code>strcmp()</code>, but the second string resides in flash.  <br /></td></tr>
<tr class="separator:ga73b91c7dc9190b55abd2996aeedc5847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c989264c8f44c899f54a4b22344f3ea" id="r_ga3c989264c8f44c899f54a4b22344f3ea"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3c989264c8f44c899f54a4b22344f3ea">flash_strncmp</a> (const char *ram, <a class="el" href="#ga6ac949979ebabc3d7130779422ead49a">FLASH_ATTR</a> const char *flash, size_t n)</td></tr>
<tr class="memdesc:ga3c989264c8f44c899f54a4b22344f3ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <code>strncmp()</code>, but the first string resides in flash.  <br /></td></tr>
<tr class="separator:ga3c989264c8f44c899f54a4b22344f3ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae26e20d6cb6b9626a8cf4fef9960ee61" id="r_gae26e20d6cb6b9626a8cf4fef9960ee61"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae26e20d6cb6b9626a8cf4fef9960ee61">flash_strlen</a> (<a class="el" href="#ga6ac949979ebabc3d7130779422ead49a">FLASH_ATTR</a> const char *flash)</td></tr>
<tr class="memdesc:gae26e20d6cb6b9626a8cf4fef9960ee61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <code>strlen()</code>, but the string resides in flash.  <br /></td></tr>
<tr class="separator:gae26e20d6cb6b9626a8cf4fef9960ee61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38768b888a88120c52296cb7b81ba4af" id="r_ga38768b888a88120c52296cb7b81ba4af"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga38768b888a88120c52296cb7b81ba4af">flash_strcpy</a> (char *ram, <a class="el" href="#ga6ac949979ebabc3d7130779422ead49a">FLASH_ATTR</a> const char *flash)</td></tr>
<tr class="memdesc:ga38768b888a88120c52296cb7b81ba4af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <code>strcpy()</code>, but the source flash resides in flash.  <br /></td></tr>
<tr class="separator:ga38768b888a88120c52296cb7b81ba4af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4e2486d0fcef9824733e672ae5bab1e" id="r_gad4e2486d0fcef9824733e672ae5bab1e"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad4e2486d0fcef9824733e672ae5bab1e">flash_strncpy</a> (char *ram, <a class="el" href="#ga6ac949979ebabc3d7130779422ead49a">FLASH_ATTR</a> const char *flash, size_t n)</td></tr>
<tr class="memdesc:gad4e2486d0fcef9824733e672ae5bab1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <code>strncpy()</code>, but the source flash resides in flash.  <br /></td></tr>
<tr class="separator:gad4e2486d0fcef9824733e672ae5bab1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac52c4e2c8557542bc7c0b05707c02837" id="r_gac52c4e2c8557542bc7c0b05707c02837"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac52c4e2c8557542bc7c0b05707c02837">flash_printf</a> (<a class="el" href="#ga6ac949979ebabc3d7130779422ead49a">FLASH_ATTR</a> const char *flash,...)</td></tr>
<tr class="memdesc:gac52c4e2c8557542bc7c0b05707c02837"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <code><a class="el" href="group__cpu__avr8__common__stdio__wrapper.html#gad2eb277496af160238e7306fff780ad2" title="A wrapper for the printf() function that passes arguments through unmodified, but fails to compile if...">printf()</a></code>, but the format string resides in flash.  <br /></td></tr>
<tr class="separator:gac52c4e2c8557542bc7c0b05707c02837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga786c1fe92f7cbed8e4c9fdbd75d93a85" id="r_ga786c1fe92f7cbed8e4c9fdbd75d93a85"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga786c1fe92f7cbed8e4c9fdbd75d93a85">flash_vprintf</a> (<a class="el" href="#ga6ac949979ebabc3d7130779422ead49a">FLASH_ATTR</a> const char *flash, va_list args)</td></tr>
<tr class="memdesc:ga786c1fe92f7cbed8e4c9fdbd75d93a85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <code>vprintf()</code>, but the format string resides in flash.  <br /></td></tr>
<tr class="separator:ga786c1fe92f7cbed8e4c9fdbd75d93a85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf4143091f8bf5c9a408d1961f79034c" id="r_gaaf4143091f8bf5c9a408d1961f79034c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaaf4143091f8bf5c9a408d1961f79034c">flash_fprintf</a> (FILE *stream, <a class="el" href="#ga6ac949979ebabc3d7130779422ead49a">FLASH_ATTR</a> const char *flash,...)</td></tr>
<tr class="memdesc:gaaf4143091f8bf5c9a408d1961f79034c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <code>fprintf()</code>, but the format string resides in flash.  <br /></td></tr>
<tr class="separator:gaaf4143091f8bf5c9a408d1961f79034c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b7492913dd9d3a362d8da1d64bbdaec" id="r_ga1b7492913dd9d3a362d8da1d64bbdaec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1b7492913dd9d3a362d8da1d64bbdaec">flash_vfprintf</a> (FILE *stream, <a class="el" href="#ga6ac949979ebabc3d7130779422ead49a">FLASH_ATTR</a> const char *flash, va_list args)</td></tr>
<tr class="memdesc:ga1b7492913dd9d3a362d8da1d64bbdaec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <code>vfprintf()</code>, but the format string resides in flash.  <br /></td></tr>
<tr class="separator:ga1b7492913dd9d3a362d8da1d64bbdaec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1415448138a652b4cc728a6831e6694a" id="r_ga1415448138a652b4cc728a6831e6694a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1415448138a652b4cc728a6831e6694a">flash_snprintf</a> (char *buf, size_t buf_len, <a class="el" href="#ga6ac949979ebabc3d7130779422ead49a">FLASH_ATTR</a> const char *flash,...)</td></tr>
<tr class="memdesc:ga1415448138a652b4cc728a6831e6694a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <code>snprintf()</code>, but the format string resides in flash.  <br /></td></tr>
<tr class="separator:ga1415448138a652b4cc728a6831e6694a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9cc79147675fcd5fb80d391c3ba1510" id="r_gad9cc79147675fcd5fb80d391c3ba1510"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad9cc79147675fcd5fb80d391c3ba1510">flash_vsnprintf</a> (char *buf, size_t buf_len, <a class="el" href="#ga6ac949979ebabc3d7130779422ead49a">FLASH_ATTR</a> const char *flash, va_list args)</td></tr>
<tr class="memdesc:gad9cc79147675fcd5fb80d391c3ba1510"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <code>vsnprintf()</code>, but the format string resides in flash.  <br /></td></tr>
<tr class="separator:gad9cc79147675fcd5fb80d391c3ba1510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee2a02e74e608ac3cc669a411b80fcc4" id="r_gaee2a02e74e608ac3cc669a411b80fcc4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaee2a02e74e608ac3cc669a411b80fcc4">flash_puts</a> (<a class="el" href="#ga6ac949979ebabc3d7130779422ead49a">FLASH_ATTR</a> const char *flash)</td></tr>
<tr class="memdesc:gaee2a02e74e608ac3cc669a411b80fcc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <code>puts()</code>, but the string resides in flash.  <br /></td></tr>
<tr class="separator:gaee2a02e74e608ac3cc669a411b80fcc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf63eb6268539c514da6b0c70ada7b730" id="r_gaf63eb6268539c514da6b0c70ada7b730"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf63eb6268539c514da6b0c70ada7b730">flash_memcpy</a> (void *dest, <a class="el" href="#ga6ac949979ebabc3d7130779422ead49a">FLASH_ATTR</a> const void *src, size_t n)</td></tr>
<tr class="memdesc:gaf63eb6268539c514da6b0c70ada7b730"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <code>memcpy()</code>, but <code>src</code> resides in flash.  <br /></td></tr>
<tr class="separator:gaf63eb6268539c514da6b0c70ada7b730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace95cb109c48a69e04ca4c1ca6180c78" id="r_gace95cb109c48a69e04ca4c1ca6180c78"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gace95cb109c48a69e04ca4c1ca6180c78">flash_print_str</a> (<a class="el" href="#ga6ac949979ebabc3d7130779422ead49a">FLASH_ATTR</a> const char *flash)</td></tr>
<tr class="memdesc:gace95cb109c48a69e04ca4c1ca6180c78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="#gaee2a02e74e608ac3cc669a411b80fcc4">flash_puts</a> but without line break.  <br /></td></tr>
<tr class="separator:gace95cb109c48a69e04ca4c1ca6180c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga6ac949979ebabc3d7130779422ead49a" name="ga6ac949979ebabc3d7130779422ead49a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ac949979ebabc3d7130779422ead49a">&#9670;&#160;</a></span>FLASH_ATTR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FLASH_ATTR&#160;&#160;&#160;&lt;IMPLEMTATION_DEFINED&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>C type qualifier required to place a variable in flash. </p>

<p class="definition">Definition at line <a class="el" href="flash__utils_8h_source.html#l00068">68</a> of file <a class="el" href="flash__utils_8h_source.html">flash_utils.h</a>.</p>

</div>
</div>
<a id="ga39a1a2e42dd44ab7f64836183f52668d" name="ga39a1a2e42dd44ab7f64836183f52668d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39a1a2e42dd44ab7f64836183f52668d">&#9670;&#160;</a></span>FLASH_PUTS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FLASH_PUTS</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code hl_function" href="#gaee2a02e74e608ac3cc669a411b80fcc4">flash_puts</a>(<a class="code hl_define" href="#ga04035c94001df85bb7ed5c24d3e6257b">TO_FLASH</a>(x))</div>
<div class="ttc" id="agroup__sys__flash__utils_html_ga04035c94001df85bb7ed5c24d3e6257b"><div class="ttname"><a href="#ga04035c94001df85bb7ed5c24d3e6257b">TO_FLASH</a></div><div class="ttdeci">#define TO_FLASH(str_literal)</div><div class="ttdoc">Macro to allocate a string literal on flash and return a FLASH_ATTR const char * pointer to it Usage:</div><div class="ttdef"><b>Definition</b> <a href="flash__utils_8h_source.html#l00091">flash_utils.h:91</a></div></div>
<div class="ttc" id="agroup__sys__flash__utils_html_gaee2a02e74e608ac3cc669a411b80fcc4"><div class="ttname"><a href="#gaee2a02e74e608ac3cc669a411b80fcc4">flash_puts</a></div><div class="ttdeci">void flash_puts(FLASH_ATTR const char *flash)</div><div class="ttdoc">Like puts(), but the string resides in flash.</div></div>
</div><!-- fragment -->
<p>A convenience wrapper for <code>flash_puts(TO_FLASH("str literal"))</code> </p>
<p>Usage: </p><div class="fragment"><div class="line"><a class="code hl_define" href="#ga39a1a2e42dd44ab7f64836183f52668d">FLASH_PUTS</a>(<span class="stringliteral">&quot;Hello world!&quot;</span>);</div>
<div class="ttc" id="agroup__sys__flash__utils_html_ga39a1a2e42dd44ab7f64836183f52668d"><div class="ttname"><a href="#ga39a1a2e42dd44ab7f64836183f52668d">FLASH_PUTS</a></div><div class="ttdeci">#define FLASH_PUTS(x)</div><div class="ttdoc">A convenience wrapper for flash_puts(TO_FLASH(&quot;str literal&quot;))</div><div class="ttdef"><b>Definition</b> <a href="flash__utils_8h_source.html#l00240">flash_utils.h:240</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="flash__utils_8h_source.html#l00240">240</a> of file <a class="el" href="flash__utils_8h_source.html">flash_utils.h</a>.</p>

</div>
</div>
<a id="ga03d3a3d9f0e2c56344cc5773edf59ed1" name="ga03d3a3d9f0e2c56344cc5773edf59ed1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03d3a3d9f0e2c56344cc5773edf59ed1">&#9670;&#160;</a></span>PRIsflash</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PRIsflash&#160;&#160;&#160;&lt;IMPLEMTATION_DEFINED&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format specifier for printing <code>FLASH CONST char *</code> </p>
<p>Usage:</p>
<div class="fragment"><div class="line"><a class="code hl_define" href="#ga6ac949979ebabc3d7130779422ead49a">FLASH_ATTR</a> <span class="keyword">const</span> <span class="keywordtype">char</span> fmt[] = <span class="stringliteral">&quot;I am printing \&quot;%&quot;</span> <a class="code hl_define" href="#ga03d3a3d9f0e2c56344cc5773edf59ed1">PRIsflash</a> <span class="stringliteral">&quot;\&quot; from flash\n&quot;</span>;</div>
<div class="line"><a class="code hl_define" href="#ga6ac949979ebabc3d7130779422ead49a">FLASH_ATTR</a> <span class="keyword">const</span> <span class="keywordtype">char</span> msg[] = <span class="stringliteral">&quot;message from flash&quot;</span>;</div>
<div class="line"><a class="code hl_function" href="#gac52c4e2c8557542bc7c0b05707c02837">flash_printf</a>(fmt, msg);</div>
<div class="ttc" id="agroup__sys__flash__utils_html_ga03d3a3d9f0e2c56344cc5773edf59ed1"><div class="ttname"><a href="#ga03d3a3d9f0e2c56344cc5773edf59ed1">PRIsflash</a></div><div class="ttdeci">#define PRIsflash</div><div class="ttdoc">Format specifier for printing FLASH CONST char *</div><div class="ttdef"><b>Definition</b> <a href="flash__utils_8h_source.html#l00080">flash_utils.h:80</a></div></div>
<div class="ttc" id="agroup__sys__flash__utils_html_ga6ac949979ebabc3d7130779422ead49a"><div class="ttname"><a href="#ga6ac949979ebabc3d7130779422ead49a">FLASH_ATTR</a></div><div class="ttdeci">#define FLASH_ATTR</div><div class="ttdoc">C type qualifier required to place a variable in flash.</div><div class="ttdef"><b>Definition</b> <a href="flash__utils_8h_source.html#l00068">flash_utils.h:68</a></div></div>
<div class="ttc" id="agroup__sys__flash__utils_html_gac52c4e2c8557542bc7c0b05707c02837"><div class="ttname"><a href="#gac52c4e2c8557542bc7c0b05707c02837">flash_printf</a></div><div class="ttdeci">int flash_printf(FLASH_ATTR const char *flash,...)</div><div class="ttdoc">Like printf(), but the format string resides in flash.</div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="flash__utils_8h_source.html#l00080">80</a> of file <a class="el" href="flash__utils_8h_source.html">flash_utils.h</a>.</p>

</div>
</div>
<a id="ga04035c94001df85bb7ed5c24d3e6257b" name="ga04035c94001df85bb7ed5c24d3e6257b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04035c94001df85bb7ed5c24d3e6257b">&#9670;&#160;</a></span>TO_FLASH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TO_FLASH</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>str_literal</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">&lt;IMPLEMTATION_DEFINED&gt;</div>
</div><!-- fragment -->
<p>Macro to allocate a string literal on flash and return a <code>FLASH_ATTR const char *</code> pointer to it Usage: </p>
<div class="fragment"><div class="line"><a class="code hl_function" href="#gaee2a02e74e608ac3cc669a411b80fcc4">flash_puts</a>(<a class="code hl_define" href="#ga04035c94001df85bb7ed5c24d3e6257b">TO_FLASH</a>(<span class="stringliteral">&quot;Hello world&quot;</span>));</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="flash__utils_8h_source.html#l00091">91</a> of file <a class="el" href="flash__utils_8h_source.html">flash_utils.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaaf4143091f8bf5c9a408d1961f79034c" name="gaaf4143091f8bf5c9a408d1961f79034c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf4143091f8bf5c9a408d1961f79034c">&#9670;&#160;</a></span>flash_fprintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int flash_fprintf </td>
          <td>(</td>
          <td class="paramtype">FILE *</td>          <td class="paramname"><span class="paramname"><em>stream</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga6ac949979ebabc3d7130779422ead49a">FLASH_ATTR</a> const char *</td>          <td class="paramname"><span class="paramname"><em>flash</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <code>fprintf()</code>, but the format string resides in flash. </p>
<p>This will be a zero-overhead wrapper on top of <code>fprintf()</code> for von-Neumann architectures or Harvard architectures that also map their flash into the data address space. </p>

</div>
</div>
<a id="gaf63eb6268539c514da6b0c70ada7b730" name="gaf63eb6268539c514da6b0c70ada7b730"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf63eb6268539c514da6b0c70ada7b730">&#9670;&#160;</a></span>flash_memcpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * flash_memcpy </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga6ac949979ebabc3d7130779422ead49a">FLASH_ATTR</a> const void *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <code>memcpy()</code>, but <code>src</code> resides in flash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dest</td><td>buffer to copy into </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>flash data to copy </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of bytes to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gace95cb109c48a69e04ca4c1ca6180c78" name="gace95cb109c48a69e04ca4c1ca6180c78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace95cb109c48a69e04ca4c1ca6180c78">&#9670;&#160;</a></span>flash_print_str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void flash_print_str </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga6ac949979ebabc3d7130779422ead49a">FLASH_ATTR</a> const char *</td>          <td class="paramname"><span class="paramname"><em>flash</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Like <a class="el" href="#gaee2a02e74e608ac3cc669a411b80fcc4">flash_puts</a> but without line break. </p>

<p class="definition">Definition at line <a class="el" href="flash__utils_8h_source.html#l00245">245</a> of file <a class="el" href="flash__utils_8h_source.html">flash_utils.h</a>.</p>

</div>
</div>
<a id="gac52c4e2c8557542bc7c0b05707c02837" name="gac52c4e2c8557542bc7c0b05707c02837"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac52c4e2c8557542bc7c0b05707c02837">&#9670;&#160;</a></span>flash_printf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int flash_printf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga6ac949979ebabc3d7130779422ead49a">FLASH_ATTR</a> const char *</td>          <td class="paramname"><span class="paramname"><em>flash</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <code><a class="el" href="group__cpu__avr8__common__stdio__wrapper.html#gad2eb277496af160238e7306fff780ad2" title="A wrapper for the printf() function that passes arguments through unmodified, but fails to compile if...">printf()</a></code>, but the format string resides in flash. </p>
<p>This will be a zero-overhead wrapper on top of <code><a class="el" href="group__cpu__avr8__common__stdio__wrapper.html#gad2eb277496af160238e7306fff780ad2" title="A wrapper for the printf() function that passes arguments through unmodified, but fails to compile if...">printf()</a></code> for von-Neumann architectures or Harvard architectures that also map their flash into the data address space. </p>

</div>
</div>
<a id="gaee2a02e74e608ac3cc669a411b80fcc4" name="gaee2a02e74e608ac3cc669a411b80fcc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee2a02e74e608ac3cc669a411b80fcc4">&#9670;&#160;</a></span>flash_puts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flash_puts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga6ac949979ebabc3d7130779422ead49a">FLASH_ATTR</a> const char *</td>          <td class="paramname"><span class="paramname"><em>flash</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <code>puts()</code>, but the string resides in flash. </p>
<p>This will be a zero-overhead wrapper on top of <code>puts()</code> for von-Neumann architectures or Harvard architectures that also map their flash into the data address space. </p>

</div>
</div>
<a id="ga1415448138a652b4cc728a6831e6694a" name="ga1415448138a652b4cc728a6831e6694a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1415448138a652b4cc728a6831e6694a">&#9670;&#160;</a></span>flash_snprintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int flash_snprintf </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>buf_len</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga6ac949979ebabc3d7130779422ead49a">FLASH_ATTR</a> const char *</td>          <td class="paramname"><span class="paramname"><em>flash</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <code>snprintf()</code>, but the format string resides in flash. </p>
<p>This will be a zero-overhead wrapper on top of <code>snprintf()</code> for von-Neumann architectures or Harvard architectures that also map their flash into the data address space. </p>

</div>
</div>
<a id="ga73b91c7dc9190b55abd2996aeedc5847" name="ga73b91c7dc9190b55abd2996aeedc5847"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga73b91c7dc9190b55abd2996aeedc5847">&#9670;&#160;</a></span>flash_strcmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int flash_strcmp </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>ram</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga6ac949979ebabc3d7130779422ead49a">FLASH_ATTR</a> const char *</td>          <td class="paramname"><span class="paramname"><em>flash</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <code>strcmp()</code>, but the second string resides in flash. </p>
<p>This will be a zero-overhead wrapper on top of <code>strcmp()</code> for von-Neumann architectures or Harvard architectures that also map their flash into the data address space. </p>

</div>
</div>
<a id="ga38768b888a88120c52296cb7b81ba4af" name="ga38768b888a88120c52296cb7b81ba4af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38768b888a88120c52296cb7b81ba4af">&#9670;&#160;</a></span>flash_strcpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * flash_strcpy </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>ram</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga6ac949979ebabc3d7130779422ead49a">FLASH_ATTR</a> const char *</td>          <td class="paramname"><span class="paramname"><em>flash</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <code>strcpy()</code>, but the source flash resides in flash. </p>
<p>This will be a zero-overhead wrapper on top of <code>strcpy()</code> for von-Neumann architectures or Harvard architectures that also map their flash into the data address space. </p>

</div>
</div>
<a id="gae26e20d6cb6b9626a8cf4fef9960ee61" name="gae26e20d6cb6b9626a8cf4fef9960ee61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae26e20d6cb6b9626a8cf4fef9960ee61">&#9670;&#160;</a></span>flash_strlen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t flash_strlen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga6ac949979ebabc3d7130779422ead49a">FLASH_ATTR</a> const char *</td>          <td class="paramname"><span class="paramname"><em>flash</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <code>strlen()</code>, but the string resides in flash. </p>
<p>This will be a zero-overhead wrapper on top of <code>strlen()</code> for von-Neumann architectures or Harvard architectures that also map their flash into the data address space. </p>

</div>
</div>
<a id="ga3c989264c8f44c899f54a4b22344f3ea" name="ga3c989264c8f44c899f54a4b22344f3ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c989264c8f44c899f54a4b22344f3ea">&#9670;&#160;</a></span>flash_strncmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int flash_strncmp </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>ram</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga6ac949979ebabc3d7130779422ead49a">FLASH_ATTR</a> const char *</td>          <td class="paramname"><span class="paramname"><em>flash</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <code>strncmp()</code>, but the first string resides in flash. </p>
<p>This will be a zero-overhead wrapper on top of <code>strncmp()</code> for von-Neumann architectures or Harvard architectures that also map their flash into the data address space. </p>

</div>
</div>
<a id="gad4e2486d0fcef9824733e672ae5bab1e" name="gad4e2486d0fcef9824733e672ae5bab1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4e2486d0fcef9824733e672ae5bab1e">&#9670;&#160;</a></span>flash_strncpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * flash_strncpy </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>ram</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga6ac949979ebabc3d7130779422ead49a">FLASH_ATTR</a> const char *</td>          <td class="paramname"><span class="paramname"><em>flash</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <code>strncpy()</code>, but the source flash resides in flash. </p>
<p>This will be a zero-overhead wrapper on top of <code>strncpy()</code> for von-Neumann architectures or Harvard architectures that also map their flash into the data address space. </p>

</div>
</div>
<a id="ga1b7492913dd9d3a362d8da1d64bbdaec" name="ga1b7492913dd9d3a362d8da1d64bbdaec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b7492913dd9d3a362d8da1d64bbdaec">&#9670;&#160;</a></span>flash_vfprintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int flash_vfprintf </td>
          <td>(</td>
          <td class="paramtype">FILE *</td>          <td class="paramname"><span class="paramname"><em>stream</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga6ac949979ebabc3d7130779422ead49a">FLASH_ATTR</a> const char *</td>          <td class="paramname"><span class="paramname"><em>flash</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <code>vfprintf()</code>, but the format string resides in flash. </p>
<p>This will be a zero-overhead wrapper on top of <code>vfprintf()</code> for von-Neumann architectures or Harvard architectures that also map their flash into the data address space. </p>

</div>
</div>
<a id="ga786c1fe92f7cbed8e4c9fdbd75d93a85" name="ga786c1fe92f7cbed8e4c9fdbd75d93a85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga786c1fe92f7cbed8e4c9fdbd75d93a85">&#9670;&#160;</a></span>flash_vprintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int flash_vprintf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga6ac949979ebabc3d7130779422ead49a">FLASH_ATTR</a> const char *</td>          <td class="paramname"><span class="paramname"><em>flash</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <code>vprintf()</code>, but the format string resides in flash. </p>
<p>This will be a zero-overhead wrapper on top of <code>vprintf()</code> for von-Neumann architectures or Harvard architectures that also map their flash into the data address space. </p>

</div>
</div>
<a id="gad9cc79147675fcd5fb80d391c3ba1510" name="gad9cc79147675fcd5fb80d391c3ba1510"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9cc79147675fcd5fb80d391c3ba1510">&#9670;&#160;</a></span>flash_vsnprintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int flash_vsnprintf </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>buf_len</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga6ac949979ebabc3d7130779422ead49a">FLASH_ATTR</a> const char *</td>          <td class="paramname"><span class="paramname"><em>flash</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <code>vsnprintf()</code>, but the format string resides in flash. </p>
<p>This will be a zero-overhead wrapper on top of <code>vsnprintf()</code> for von-Neumann architectures or Harvard architectures that also map their flash into the data address space. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->

    </div>
  </body>
</html>
