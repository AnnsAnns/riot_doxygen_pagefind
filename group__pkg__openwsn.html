<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RIOT OS: OpenWSN network stack</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<!-- <script type="text/javascript" src="jquery.js"></script> -->
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<!-- <link href="/pagefind/pagefind-ui.css" rel="stylesheet"> -->
<script src="/pagefind/pagefind-ui.js"></script>
<script>
  // Check whether the PagefindUI class is available
  if (typeof PagefindUI === 'undefined') {
    console.error('PagefindUI class is not available | Dev Build');
  } else {
    // // Remove the "searchstub" element and initialize the PagefindUI class
    // document.getElementById("#searchstub").remove();
    // Initialize the PagefindUI class with the element id "search"
    window.addEventListener('DOMContentLoaded', (event) => {
        new PagefindUI({ element: "#search", showSubResults: true });
    });
  }
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="global.css" rel="stylesheet" type="text/css" />
</head>
<body>
  <script>
    // Print the data within the NAVTREE variable from the navtreedata.js file
    var navtree = NAVTREE;
    console.log(navtree);
  </script>
<div class="flex flex-row gap-4 w-screen font-sans text-lg max-h-screen overscroll-contain justify-items-stretch bg-neutral-900">
  <!--Sidebar-->
  <div data-pagefind-ignore="all" class="w-1/3 max-w-md flex-auto h-screen bg-neutral-800 ring-2 ring-neutral-700 shadow-neutral-800 shadow-2xl rounded-xl p-3 ml-1 my-2 mr-3 flex flex-col justify-around">
    <div id="top" class="justify-self-center content-center items-center place-content-center">
      <img alt="Logo" src="riot-logo.svg"/>
      <div id="projectbrief">
        The friendly Operating System for the Internet of Things
      </div>
    </div>
    <div id="search" class="place-content-center" class="overflow-y-scroll max-h-64 bg-slate-400 ring-2 ring-white text-white" >
      <h1>Searchbar via Pagefind</h1>
      <!-- <div id="searchstub" class="flex items-center border border-gray-300 rounded-lg p-2 shadow-sm">
        <input type="text" placeholder="Search is only available in Production Build ..." class="flex-grow p-2 outline-none">
      </div> -->
    </div>
    <div id="navtree">
      <script>
        // The navtree variable is always a pair of two elements (key, value)
        // The key is the name we should display and the value is the link to the page
        // Generate the navtree from the navtreedata.js file and put it under the navtree div
        var navtree = NAVTREE[0][2];
        var navtreeHTML = "<h1>Navigation based on Doxygen</h1> <ul>";
        for (var i = 0; i < navtree.length; i++) {
          navtreeHTML += "<li><a href='" + navtree[i][1] + "'>" + navtree[i][0] + "</a></li>";
          if (i == 5) {
            navtreeHTML += '<li><h3 class="ring-2 ring-white"> Random Insert for Demonstration </h3></li>';
          }
        }
        navtreeHTML += "</ul>";
        document.getElementById("navtree").innerHTML = navtreeHTML;
      </script>
    </div>
    <ul>
      <li class="footer">
        Generated on Tue Sep 24 2024 11:16:27 by 
          <a href="http://www.doxygen.org/index.html">
            Doxygen
          </a> 
        1.12.0
      </li>
    </ul>
  </div>
  <!--Main Content-->
  <div class="hidden">
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search',true);
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('group__pkg__openwsn.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#groups">Topics</a> &#124;
<a href="#files">Files</a>  </div>
  <div class="headertitle"><div class="title">OpenWSN network stack<div class="ingroups"><a class="el" href="group__pkg.html">Packages</a> &#124; <a class="el" href="group__net.html">Networking</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Provides a RIOT adaption of the OpenWSN network stack  
<a href="#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Provides a RIOT adaption of the OpenWSN network stack </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://github.com/openwsn-berkeley/openwsn-fw">https://github.com/openwsn-berkeley/openwsn-fw</a> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd><b class="text-danger">This feature is experimental!</b><br  />
 </dd></dl>
<h1><a class="anchor" id="autotoc_md1878"></a>
OpenWSN RIOT Port</h1>
<p>This implementation integrates the <a href="https://github.com/openwsn-berkeley/openwsn-fw">OpenWSN</a> full network stack (UDP, IPv6 (6LoWPAN), RPL, 6TiSCH) into RIOT.</p>
<p>It can be used instead of GNRC on supported 802.15.4 radios, and compared to GNRC, provides a full 6TiSCH implementation. It supports RIOT's <a class="el" href="group__net__sock.html">Sock API</a> API, so it can be used as a drop-in replacement for application built on top of <a class="el" href="group__net__sock.html">Sock API</a>.</p>
<p>This port provides a new RIOT "board" to the OpenWSN software. In this way RIOT's hardware abstraction connects to OpenWSN's interfaces.</p>
<p>The simple scheduling mechanism in OpenWSN is run in a RIOT thread with second highest priority after the radio thread (THREAD_PRIORITY_MAIN - 4).</p>
<p>The current port of OpenWSN currently needs a root node that works along an external tool that performs routing and handles join procedure: <a href="https://github.com/openwsn-berkeley/openvisualizer">Openvisualizer</a></p>
<h2><a class="anchor" id="autotoc_md1879"></a>
Joining a network</h2>
<p>The first thing a new mote will need to do is to find a network. On boot it will actively be listening for enhanced beacons. Once a beacon is received it will adjust its timers drift and synchronize with the network. Re-synchronization will be happening constantly to compensate for oscillator and timer drifts.</p>
<p>Once synchronized the node will need to join the network. OpenWSN uses CoJP <a href="https://datatracker.ietf.org/doc/draft-ietf-6tisch-minimal-security/">constrained join protocol</a> an the stack itself only handles Join Requests. The JRC (join registrar/coordinator, a central entity) is not running on the root node, but alongside it, in the <code>OpenVisualizer</code> external tool. This functionality is now optional but can be included through the <code>openwsn_cjoin</code> module.</p>
<p>Once joined the device has the required keys to start listening to DIS (DODAG Information Solicitation) messages and to send DIO (DODAG Information Object) requests. Once it knows about the topology of the network it is able to send packets.</p>
<p>OpenWSN uses source routing. This means that unless the recipient of a packet is one of the parents in the RPL tree the packet will have to go up the tree to the root node. But in OpenWSN RPL implementation the node does not know how to route, instead it is <code>OpenVisualizer</code> which generates an SRH (Source Routing Header), attaches to the incoming packet and sends it down the tree.</p>
<h2><a class="anchor" id="autotoc_md1880"></a>
Hardware abstraction implementation</h2>
<p>Following, details about the implementation of selected hardware modules.</p>
<h3><a class="anchor" id="autotoc_md1881"></a>
sctimer</h3>
<p>The <code>sctimer</code> ("single compare timer") in OpenWSN is the lowest timer abstraction which is used by the higher layer timer module <code>opentimers</code>. In the end it is responsible for scheduling on the MAC layer. To enable low power energy modes, this timer usually uses the RTC (real time clock) or RTT (real time timer) module.</p>
<p>This port has two possible implementations or sctimer, one on top of periph_rtt and another on top of ztimer, <code>sctimer_rtt</code> and <code>sctimer_ztimer</code> respectively. If possible <code>ztimer</code> should be preferred, being a virtual timer it will allow RIOT applications/modules to use the low level RTT timer. But ztimer (any virtual timer) has some overhead which can be costly depending on the different platforms used, specially when <code>openserial</code> is required. More on this in openserial and Known Issues.</p>
<h4><a class="anchor" id="autotoc_md1882"></a>
sctimer_ztimer</h4>
<p>In order to get the most portable code, this implementation uses ztimer and defines a new <code><a class="el" href="structztimer__clock.html" title="ztimer device structure">ztimer_clock</a></code> (<code>ZTIMER_32768</code>) that operates at 32768Khz to have a resolution of ~30usec/tick (same as OpenWSN).</p>
<p>When available <code>ZTIMER_32768</code> will be built on top of <code>periph_rtt</code> to get low power capabilities. If not it will be built on top of a regular timer. In either case it will be shifted up if the base frequency is lower than 32768Hz or frac if higher.</p>
<p>When next interrupt to schedule is already late, current time, implementations in OpenWSN directly trigger a hardware interrupt. Until able to trigger sw isr directly a callback is set 0 ticks in the future, which internally will be set to <code>now + RTT_MIN_OFFSET</code>.</p>
<h4><a class="anchor" id="autotoc_md1883"></a>
sctimer_rtt</h4>
<p>In order to reduce overhead this implementation uses bare RTT. It expects a RTT running at 32768Hz to have a resolution of ~30usec/tick (same as OpenWSN). If <code>RTT_FREQUENCY</code> is lower than 32768Hz then a simple time-division mechanism will be used to speed up the clock. This only works if <code>RTT_FREQUENCY</code> is 32768Hz/2.</p>
<p>When next interrupt to schedule is already late, current time, Implementations in OpenWSN directly trigger a hardware interrupt. Until able to trigger sw isr directly a callback is set <code>RTT_MIN_OFFSET</code> ticks in the future.</p>
<h3><a class="anchor" id="autotoc_md1884"></a>
radio</h3>
<p>The radio adaptation maps to RIOT's <a class="el" href="structnetdev.html">netdev</a> API or on <a class="el" href="group__drivers__ieee802154__hal.html">IEEE802.15.4 Radio Hardware Abstraction Layer</a> API. The later is preferred but not yet supported by all boards.</p>
<p>Hardware MAC layer features such as CSMA/CA, ACK handling and retransmissions are handled by OpenWSN, so the radio driver must support disabling AUTOACK and CSMA handling by the hardware. Frame filtering must as well be disabled.</p>
<p>OpenWSN needs to be notified when a frame reception/transmission starts and when it ends. Without these synchronization can still work but in a deteriorated way.</p>
<p>OpenWSN expects to recover crc information on every received frame even if it will simply drop frames with invalid crc. The stack can function correctly if radio drivers automatically drop frames with an invalid crc (i.e. the stack doesn't get notified about these frames).</p>
<h4><a class="anchor" id="autotoc_md1885"></a>
ieee802154_hal</h4>
<p>The radio drivers should support the following caps: </p><pre class="fragment">- `IEEE802154_CAP_IRQ_RX_START`
- `IEEE802154_CAP_IRQ_TX_START`
</pre><p>For CRC error handling: </p><pre class="fragment">- `IEEE802154_CAP_IRQ_CRC_ERROR`
</pre><h4><a class="anchor" id="autotoc_md1886"></a>
netdev</h4>
<p>The radio adaptation preloads the buffer so <code>NETOPT_PRELOADING</code> must be supported.</p>
<p>The radio drivers should support the following netdev events: </p><pre class="fragment">- `NETDEV_EVENT_RX_STARTED`
- `NETDEV_EVENT_TX_STARTED`
- `NETDEV_EVENT_RX_COMPLETE`
- `NETDEV_EVENT_TX_COMPLETE`
</pre><h3><a class="anchor" id="autotoc_md1887"></a>
uart</h3>
<p>In RIOT, the first configured uart device is mapped to STDIO in most cases. In OpenWSN however, the <code>openserial</code> tool uses uart to feed external software running on a host computer such as <a href="https://github.com/openwsn-berkeley/openvisualizer">Openvisualizer</a>. To enable use of these tools, an uart adaptation is provided.</p>
<p>This is provided through the <code>openwsn_serial</code> (<code>openserial</code>) module. It will use the next available uart that is not used by STDIO (checking STDIO_UART_DEV). When multiple uart are available STDIO and <code>openserial</code> can be used in parallel. If <code>stdio_null</code> is used then <code>openserial</code> will use <code>STDIO_UART_DEV</code>, otherwise it will use the next available uart. e.g. If <code>STDIO_UART_DEV = <a class="el" href="group__drivers__periph__uart.html#gafc5afd63560d27731d2517b3005f3294" title="Default UART device access macro.">UART_DEV(1)</a></code> <code>OPENWSN_UART_DEV = <a class="el" href="group__drivers__periph__uart.html#gafc5afd63560d27731d2517b3005f3294" title="Default UART device access macro.">UART_DEV(0)</a></code> if there are uarts.</p>
<p>OpenWSN uart abstraction makes use of tx hardware interrupts to execute a previously registered callback after every byte is sent out. These interrupts are currently not defined in RIOT in a generic way, so instead a timer is set to fire shortly after a byte is written.</p>
<p>It uses <code>ztimer</code> to set the timer since it's already pulled in as a dependency.</p>
<h3><a class="anchor" id="autotoc_md1888"></a>
Openserial</h3>
<p>As was mentioned before any OpenWSN network will require a root node which is connected to an <code>OpenVisualizer</code> instance running on a host computer. Interaction between <code>OpenVisualizer</code> and the root-node is done over serial. As OpenWSN uses source routing, this means that ultimately all network traffic must go from the root node to <code>OpenVisualizer</code> and back.</p>
<p>OpenSerial uses software flow control (XonXoff) to turn off serial activity while time critical TSCH operation are ongoing. But software flow control can cause issues since delays in the serial pipe (either because of a remote connection, buffers, etc..) can lead to bytes being transmitted when one side is not yet ready.</p>
<p>Serial data is transmitted as High-Level Data Link Control (HDLC) frames. Since network traffic is tunneled through the serial pipe, in order to to have a stable connection these packets must not be lost. Packets can be lost in multiple ways but at the end it reduces to bytes being overridden in the uart reception buffer.</p>
<ol type="1">
<li>The last byte in an HDCL frame is received</li>
<li>Serial pipe delays hindering XonXoff operation</li>
<li>Interrupts are masked or higher/equal ISR are running</li>
</ol>
<ol type="1">
<li>When the last byte of a frame is received some parsing and handling of the frame occur. This takes some time and during that time OpenSerial can't handle more incoming bytes. This in practice limits the baudrate depending on the CPU's speed.</li>
<li>This can occur when a debugger/virtual-port might act as a buffer between the mote and the host, or when there is a latency in the connection (for example tcp connection to iotlab).</li>
<li><p class="startli">Since uart reception is interrupted based if the uart ISR is not serviced for too long then bytes start overriding each other in the reception buffer. In an application where only OpenWSN is running then there are 3 functions/operations that run in ISR or with disabled ISR.</p>
<p class="startli">(a) <code>opentimers_timer_callback</code> (OpenWSN timer abstraction callback) (b) <code>sctimer_setCompare</code> and <code>sctimer_readCounter</code> (c) <code>ztimer_handler</code></p>
</li>
</ol>
<p>(a) and (b) are closely related since <code>opentimers_timer_callback</code> will itself call <code>sctimer_setCompare</code> and <code>sctimer_readCounter</code>. And this itself will depend on <code>ztimer_set</code> and <code>ztimer_now</code> or <code>rtt_get_counter</code> or <code>rtt_set_alarm</code> execution time.</p>
<p>(c) is also related to (a) (b) since <code>ztimer_handler</code> will also call <code>opentimers_timer_callback</code> as well as the underlying <code>rtt</code> functions.</p>
<p>Since a 115200 baudrate means ~1byte every 10us, none of the above can take longer than that or bytes could be lost at that baudrate.</p>
<p>Because of the above mentioned reasons, it is preferable to use <code>sctimer_rtt</code> for the root node or "border router" on an OpenWSN network, since this reduces the likeliness of packets being lost. For non root nodes, OpenSerial only provides debugging information so no special care needs to be taken.</p>
<p>It is also recommended that the root node should act as a border router running only the OpenWSN stack to avoid other threads/ISR disrupting serial reception.</p>
<h2><a class="anchor" id="autotoc_md1889"></a>
Tested Platforms and Pin configurations</h2>
<p>So far, this has been successfully tested on <code>iotlab-m3</code>,<code>nucleo-f103</code> and <code>samr21-xpro</code>, all based on at86rf23x radios. These radios make use of the <code>radio_netdev</code> adaptation.</p>
<h3><a class="anchor" id="autotoc_md1890"></a>
Synchronization</h3>
<p>To join a network a node must first receive EB (enhanced beacons). Once an EB is received the node will be synchronized with the network. Synchronization times are not deterministic, they depend on the following:</p>
<p><code>SLOTFRAME_LENGTH*SLOTDURATION*P_CHANNEL*P_EB</code></p>
<p><code>SLOTFRAME_LENGTH</code> in OpenWSN is 101, and this port uses 20ms as the slotOffset duration. <code>P_EB</code> specifies the a probability for a node to transmit an EB. By default it's 10%, that means that on average it will take 10 tries before an EB is transmitted. <code>P_CHANNEL</code> is the probability for the transmitter's and receiver channel to match. If channel hopping is disabled this means that the average worst case scenario is <code>101*20ms*10 ~= 20s</code>, so 20s for synchronization to take place. <code>EB_PORTION</code> can be changed to increase the likelihood of EB to be sent. This can also be achieved by reducing <code>SLOTFRAME_LENGTH</code>, but the later can have an impact on the MSF (Minimal Scheduling Function). If too few cells are available this could increase the likelihood of collisions.</p>
<p>On the other hand if channel hopping is enabled then the joining node picks a random channel to start listening on. The transmitter also picks a random channel to start transmitting on and then follows a channel hopping template. This would take on average ~8 tries for it to hit the correct channel for the first time, and then it would hit it every 16 hops, on average this could lead synchronization times of around <code>320s</code>.</p>
<p>If nodes are having trouble in staying synchronized increasing <code>P_EB</code> by reducing the value of <code>EB_PORTION</code> can also be done. Note that <code>EB_PORTION</code> and <code>SLOTFRAME_LENGTH</code> are not configurable by default so need to be overridden with <code>CFLAGS</code>.</p>
<p>See <a href="https://openwsn.atlassian.net/wiki/spaces/OW/pages/132055073/Tune+parameters+in+OpenWSN">Tune parameters in OpenWSN</a> for more details.</p>
<h3><a class="anchor" id="autotoc_md1891"></a>
Timing</h3>
<p>Timing is essential for OpenWSN to work properly. For optimal results most parameters in <code><a class="el" href="board__info_8h.html">board_info.h</a></code> should be measured for the specific hardware used. OpenWSN has done that for most of their boards. These values can not be taken directly from OpenWSN since they do not necessarily use the same TIMER's or clock speeds.</p>
<p>For more details on those parameters refer to: <a href="https://openwsn.atlassian.net/wiki/spaces/OW/pages/688251/State+Machine">https://openwsn.atlassian.net/wiki/spaces/OW/pages/688251/State+Machine</a></p>
<p>Since all these parameters are HW dependent, it also means that hybrid networks (different type of underlying hardware) might desynchronize often, or not manage to keep in sync at all.</p>
<p>Print messages during TSCH operation should be avoided since these can disrupt TSCH timings.</p>
<h3><a class="anchor" id="autotoc_md1892"></a>
ledpins &amp; debugpins</h3>
<p>The OpenWSN software provides different hooks all over the stack to toggle different LEDs as well as debug pins to examine state and scheduling of a node. Default configuration files are provided for both. The LED configuration maps to RIOTs <code>LEDX_PIN</code> definitions, if available. On Nucleo boards LED0 line is shared SPI, so is not used.</p>
<p>The default configuration can be overwritten by setting <code>OPENWSN_LEDS_DEFAULT</code> in the form of <code>leds_config_t</code>. The debugpins work similarly by setting <code>OPENWSN_DEBUGPINS_BOARD</code> in the form of <code>debugpins_config_t</code>.</p>
<p>The default configuration maps to OpenWSN reference hardware <code>openmote-b</code>.</p>
<h2><a class="anchor" id="autotoc_md1893"></a>
Optional Modules and Features</h2>
<p>The following modules are optional and can be disabled if not needed, or to lower the stack footprint.</p>
<ul>
<li><code>openwsn_cjoin</code>: this enabled the use of Constrained Join Protocol (CoJP)</li>
<li><code>openwsn_6lo_fragmentation</code>: this enable 6LoWPAN fragmentation</li>
<li><code>openwsn_iee802154e_security</code>: enable link layer security</li>
<li><code>openwsn_adaptive_msf</code>: allow the MSF algorithm to dynamically remove and allocate slots</li>
</ul>
<h2><a class="anchor" id="autotoc_md1894"></a>
Testing and debugging</h2>
<p>List of some items which are helpful to explore the functionality of OpenWSN:</p>
<ul>
<li>LED pins and debug pins as mentioned above in combination with a logic analyzer. The expected behavior is described in: <a href="https://openwsn.atlassian.net/wiki/spaces/OW/pages/688257/Schedules">OpenWSN wiki</a>.</li>
<li>The provided test application provides a UDP client and server. If the UDP server is able to receive packets, the mechanism is considered to work correctly. You should also be able to ping the device from your host. See <code>tests/pkg/openwsn/README.md</code> for more details.</li>
<li>To speed up synchronization and make sniffing easier you can disable channel hopping by setting (<code>CFLAGS=-DIEEE802154E_SINGLE_CHANNEL=26</code>).</li>
<li>To sniff the packets either use a 802.15.4 capable board and follow at: <a href="https://github.com/RIOT-OS/applications/blob/master/sniffer/tools/README.md">https://github.com/RIOT-OS/applications/blob/master/sniffer/tools/README.md</a>. Alternatively use a Raspberry Pi with an external radio such as Openlabs and incorporate Linux WPAN tools. In addition to that, there's also other hardware such as the ATUSB IEEE 802.15.4 USB Adapter which can directly be used on your Linux computer with WPAN tools installed. If you conduct your experiments on the IoT-LAB testbed you might want to use a: <a href="https://www.iot-lab.info/tutorials/radio-sniffer">sniffer profile</a>.</li>
<li>To explore the channel hopping mechanism there are rather expensive multi-channel sniffers such as the BeamLogic 802.15.4 Site Analyzer that can sniff all channels simultaneously. Alternatively you can set up multiple separate sniffer devices locally or make use of the <code>sniffer_aggregator</code> on the IoT-LAB testbed.</li>
<li><p class="startli">To test Openserial on a given platform the target <code>make openv-serial</code> can be used on a BOARD flashed with <code>tests/pkg/openwsn</code> (<code>USEMODULE=openwsn_serial</code>) must be included as well. The following output should appear:</p>
<div class="fragment"><div class="line">Test Setup:</div>
<div class="line">------------------</div>
<div class="line">Iterations:    100</div>
<div class="line">Packet length: 100</div>
<div class="line">Echo timeout:    2</div>
<div class="line"> </div>
<div class="line">Test Progress:</div>
<div class="line"> </div>
<div class="line">  [####################################]  100%</div>
<div class="line"> </div>
<div class="line">Test Statistics:</div>
<div class="line">------------------</div>
<div class="line">Pkts <a class="code hl_function" href="group__posix__sockets.html#ga3ed135eb9019c8945718d03da23546c9">send</a>:      100</div>
<div class="line">Echo success:   100</div>
<div class="line">Echo timeout:     0</div>
<div class="line">Echo corrupted:   0</div>
<div class="ttc" id="agroup__posix__sockets_html_ga3ed135eb9019c8945718d03da23546c9"><div class="ttname"><a href="group__posix__sockets.html#ga3ed135eb9019c8945718d03da23546c9">send</a></div><div class="ttdeci">static ssize_t send(int socket, const void *buffer, size_t length, int flags)</div><div class="ttdoc">Send a message on a socket.</div><div class="ttdef"><b>Definition</b> <a href="socket_8h_source.html#l00456">socket.h:456</a></div></div>
</div><!-- fragment --></li>
</ul>
<p>The test should be considered passing if success rate is &gt; 98%.</p>
<h2><a class="anchor" id="autotoc_md1895"></a>
Known Issues</h2>
<p>The following errors might be visible when using <code>openwsn_serial</code>:</p>
<ul>
<li><code>[OPENSERIAL] wrong CRC in input Buffer</code></li>
</ul>
<p>Since a timer is set to simulate a uart transmit interrupt, it can happen that the interrupt is missed if another interrupt occurs during that time, this seems to lead to the input buffer missing a byte and so CRC fails. More details where given in the <code>openserial</code> section.</p>
<ul>
<li><code>[IEEE802154E] wdDataDuration overflows while at state 19 in slotOffset 0</code></li>
</ul>
<p>This error can show up when the radio starts receiving (receives the SFD) and therefore triggers a <code>NETDEV_RX_STARTED</code> but then no <code>NETDEV_TX_STARTED</code> event follows. This happens when packets with invalid CRC are received. netdev currently silently drops these packets without notifying upper layers. But this does not affect the stack operation, so they can be ignored.</p>
<ul>
<li><code>[IEEE802154E] large timeCorr.: -18 ticks (code loc. 0)</code></li>
</ul>
<p>Most crystals used to clock the RTT will drift even those with a very similarly drift (10-30ppm). It's is normal then for motes adjust their timerCorr as long as it stays within the above mentioned margins and if motes are able to stay synchronized over the long run. If there aren't then maybe <a class="el" href="board__info_8h.html">board_info.h</a> parameters require tuning for the specific platform.</p>
<ul>
<li><code>[JRC:ERROR] Type-error in conversion of 5N=ex</code></li>
</ul>
<p>This errors happen when a node tries to rejoin the network. This error is only associated to a log print, so can be ignored.</p>
<ul>
<li><code>[coap:WARNING] coapRcBadRequest(reason=OSCOAP unprotect failed: oscoapError(reason=Replay protection failed))</code></li>
</ul>
<p>The join procedure uses a replay window. If a node had already joined the network and for some reason attempts to rejoin again, then the replay windows will need to expire for it's join request to be accepted.</p>
<p>The following errors are platform specific.</p>
<ul>
<li>samr21-xpro issues:<ul>
<li>The serial debugger hinders Openserial operation, an ftdi device must be used.</li>
</ul>
</li>
<li>sam0 issues:<ul>
<li>sam0 requires 180us busy loops every time an alarm is set or the counter is read. Because of the later only <code>sctimer_rtt</code> can be used and the max. tested baudrate for openserial is of 19200 bauds.</li>
</ul>
</li>
<li>iotlab-m3 issues:<ul>
<li>openserial does not work reliably over 57600 bauds or when using sctimer_ztimer.</li>
</ul>
</li>
</ul>
<p>Other errors:</p>
<ul>
<li>missed characters over stdio</li>
</ul>
<p>TSCH state machine disable occurs in IRQ context and disables IRQ during time critical sections. This can cause bytes sent over stdio to be missed.</p>
<h2><a class="anchor" id="autotoc_md1896"></a>
Todos</h2>
<ul>
<li><code>sctimer</code> to trigger an ISR immediately using software interrupts.</li>
<li>The UART wrapper uses ztimer to fake an interrupt after one byte has been sent. This should also be done with software interrupts.</li>
</ul>
<h2><a class="anchor" id="autotoc_md1897"></a>
Future Steps</h2>
<p>It would be desirable to achieve an extraction of the MAC layer. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="groups" name="groups"></a>
Topics</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pkg__openwsn__sock.html">OpenWSN-specific implementation of the sock API</a></td></tr>
<tr class="memdesc:group__pkg__openwsn__sock"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides an implementation of the <a class="el" href="group__net__sock.html">Sock API</a> by the <a class="el" href="group__pkg__openwsn.html">OpenWSN network stack</a> <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="files" name="files"></a>
Files</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="board__info_8h.html">board_info.h</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openwsn_8h.html">openwsn.h</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openwsn__board_8h.html">openwsn_board.h</a></td></tr>
<tr class="memdesc:openwsn__board_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">RIOT HAL is provided as a new "board", a "RIOT board" to OpenWSN hardware abstraction interfaces. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openwsn__debugpins_8h.html">openwsn_debugpins.h</a></td></tr>
<tr class="memdesc:openwsn__debugpins_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides an adaption of OpenWSN debug pin handling to RIOTs handling of GPIOs. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openwsn__debugpins__params_8h.html">openwsn_debugpins_params.h</a></td></tr>
<tr class="memdesc:openwsn__debugpins__params_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default configuration for the OpenWSN debugpins. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openwsn__leds_8h.html">openwsn_leds.h</a></td></tr>
<tr class="memdesc:openwsn__leds_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides an adaption of OpenWSN led handling to RIOTs handling of LEDs and/or GPIOs. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openwsn__leds__params_8h.html">openwsn_leds_params.h</a></td></tr>
<tr class="memdesc:openwsn__leds__params_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default configuration for the OpenWSN leds. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openwsn__log_8h.html">openwsn_log.h</a></td></tr>
<tr class="memdesc:openwsn__log_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">System logging header OpenWSN definitions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openwsn__radio_8h.html">openwsn_radio.h</a></td></tr>
<tr class="memdesc:openwsn__radio_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">RIOT adaption of the "radio" bsp module definitions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="openwsn__uart_8h.html">openwsn_uart.h</a></td></tr>
<tr class="memdesc:openwsn__uart_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">For details on the implementation check pkg/openwsn/doc.txt. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="scheduler__types_8h.html">scheduler_types.h</a></td></tr>
<tr class="memdesc:scheduler__types_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">RIOT scheduler types variable declaration. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
</div><!-- doc-content -->

    </div>
  </body>
</html>
